{"version":3,"file":"index.js","sources":["../webpack://kustomize-action/./node_modules/@actions/artifact/lib/artifact-client.js","../webpack://kustomize-action/./node_modules/@actions/artifact/lib/internal/artifact-client.js","../webpack://kustomize-action/./node_modules/@actions/artifact/lib/internal/config-variables.js","../webpack://kustomize-action/./node_modules/@actions/artifact/lib/internal/download-http-client.js","../webpack://kustomize-action/./node_modules/@actions/artifact/lib/internal/download-specification.js","../webpack://kustomize-action/./node_modules/@actions/artifact/lib/internal/http-manager.js","../webpack://kustomize-action/./node_modules/@actions/artifact/lib/internal/status-reporter.js","../webpack://kustomize-action/./node_modules/@actions/artifact/lib/internal/upload-gzip.js","../webpack://kustomize-action/./node_modules/@actions/artifact/lib/internal/upload-http-client.js","../webpack://kustomize-action/./node_modules/@actions/artifact/lib/internal/upload-specification.js","../webpack://kustomize-action/./node_modules/@actions/artifact/lib/internal/utils.js","../webpack://kustomize-action/./node_modules/@actions/core/lib/command.js","../webpack://kustomize-action/./node_modules/@actions/core/lib/core.js","../webpack://kustomize-action/./node_modules/@actions/core/lib/file-command.js","../webpack://kustomize-action/./node_modules/@actions/core/lib/utils.js","../webpack://kustomize-action/./node_modules/@actions/http-client/auth.js","../webpack://kustomize-action/./node_modules/@actions/http-client/index.js","../webpack://kustomize-action/./node_modules/@actions/http-client/proxy.js","../webpack://kustomize-action/./node_modules/balanced-match/index.js","../webpack://kustomize-action/./node_modules/brace-expansion/index.js","../webpack://kustomize-action/./node_modules/concat-map/index.js","../webpack://kustomize-action/./node_modules/dotenv/lib/main.js","../webpack://kustomize-action/./node_modules/fs.realpath/index.js","../webpack://kustomize-action/./node_modules/fs.realpath/old.js","../webpack://kustomize-action/./node_modules/glob/common.js","../webpack://kustomize-action/./node_modules/glob/glob.js","../webpack://kustomize-action/./node_modules/glob/sync.js","../webpack://kustomize-action/./node_modules/inflight/inflight.js","../webpack://kustomize-action/./node_modules/inherits/inherits.js","../webpack://kustomize-action/./node_modules/inherits/inherits_browser.js","../webpack://kustomize-action/./node_modules/minimatch/minimatch.js","../webpack://kustomize-action/./node_modules/once/once.js","../webpack://kustomize-action/./node_modules/path-is-absolute/index.js","../webpack://kustomize-action/./node_modules/rimraf/rimraf.js","../webpack://kustomize-action/./node_modules/tmp-promise/index.js","../webpack://kustomize-action/./node_modules/tmp-promise/node_modules/tmp/lib/tmp.js","../webpack://kustomize-action/./node_modules/tmp/lib/tmp.js","../webpack://kustomize-action/./node_modules/tmp/node_modules/rimraf/rimraf.js","../webpack://kustomize-action/./node_modules/tunnel/index.js","../webpack://kustomize-action/./node_modules/tunnel/lib/tunnel.js","../webpack://kustomize-action/./node_modules/wrappy/wrappy.js","../webpack://kustomize-action/./node_modules/yaml/dist/Document-2cf6b08c.js","../webpack://kustomize-action/./node_modules/yaml/dist/PlainValue-ec8e588e.js","../webpack://kustomize-action/./node_modules/yaml/dist/Schema-42e9705c.js","../webpack://kustomize-action/./node_modules/yaml/dist/index.js","../webpack://kustomize-action/./node_modules/yaml/dist/parse-cst.js","../webpack://kustomize-action/./node_modules/yaml/dist/resolveSeq-4a68b39b.js","../webpack://kustomize-action/./node_modules/yaml/dist/warnings-39684f17.js","../webpack://kustomize-action/./node_modules/yaml/index.js","../webpack://kustomize-action/./src/validation/schemas/azureIdentity.js","../webpack://kustomize-action/./src/validation/schemas/azureIdentityBinding.js","../webpack://kustomize-action/./src/validation/schemas/azureIdentityException.js","../webpack://kustomize-action/./src/validation/schemas/common.js","../webpack://kustomize-action/./src/validation/schemas/customResourceDefinition.js","../webpack://kustomize-action/./src/validation/schemas/globalNetworkPolicy.js","../webpack://kustomize-action/./src/validation/schemas/index.js","../webpack://kustomize-action/./src/validation/schemas/istio.js","../webpack://kustomize-action/./src/validation/schemas/networkPolicy.js","../webpack://kustomize-action/./src/validation/schemas/sealedSecrets.js","../webpack://kustomize-action/./src/validation/server.js","../webpack://kustomize-action/./src/cleanYaml.ts","../webpack://kustomize-action/./src/index.ts","../webpack://kustomize-action/./src/kustomize.ts","../webpack://kustomize-action/./src/logger.ts","../webpack://kustomize-action/./src/outputs.ts","../webpack://kustomize-action/./src/resourceFilter.ts","../webpack://kustomize-action/./src/setup.ts","../webpack://kustomize-action/./src/utils.ts","../webpack://kustomize-action/./src/validation/index.ts","../webpack://kustomize-action/external \"assert\"","../webpack://kustomize-action/external \"child_process\"","../webpack://kustomize-action/external \"crypto\"","../webpack://kustomize-action/external \"events\"","../webpack://kustomize-action/external \"fs\"","../webpack://kustomize-action/external \"http\"","../webpack://kustomize-action/external \"https\"","../webpack://kustomize-action/external \"net\"","../webpack://kustomize-action/external \"os\"","../webpack://kustomize-action/external \"path\"","../webpack://kustomize-action/external \"perf_hooks\"","../webpack://kustomize-action/external \"stream\"","../webpack://kustomize-action/external \"tls\"","../webpack://kustomize-action/external \"url\"","../webpack://kustomize-action/external \"util\"","../webpack://kustomize-action/external \"zlib\"","../webpack://kustomize-action/webpack/bootstrap","../webpack://kustomize-action/webpack/runtime/compat","../webpack://kustomize-action/webpack/startup"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst artifact_client_1 = require(\"./internal/artifact-client\");\n/**\n * Constructs an ArtifactClient\n */\nfunction create() {\n    return artifact_client_1.DefaultArtifactClient.create();\n}\nexports.create = create;\n//# sourceMappingURL=artifact-client.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core = __importStar(require(\"@actions/core\"));\nconst upload_specification_1 = require(\"./upload-specification\");\nconst upload_http_client_1 = require(\"./upload-http-client\");\nconst utils_1 = require(\"./utils\");\nconst download_http_client_1 = require(\"./download-http-client\");\nconst download_specification_1 = require(\"./download-specification\");\nconst config_variables_1 = require(\"./config-variables\");\nconst path_1 = require(\"path\");\nclass DefaultArtifactClient {\n    /**\n     * Constructs a DefaultArtifactClient\n     */\n    static create() {\n        return new DefaultArtifactClient();\n    }\n    /**\n     * Uploads an artifact\n     */\n    uploadArtifact(name, files, rootDirectory, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            utils_1.checkArtifactName(name);\n            // Get specification for the files being uploaded\n            const uploadSpecification = upload_specification_1.getUploadSpecification(name, rootDirectory, files);\n            const uploadResponse = {\n                artifactName: name,\n                artifactItems: [],\n                size: 0,\n                failedItems: []\n            };\n            const uploadHttpClient = new upload_http_client_1.UploadHttpClient();\n            if (uploadSpecification.length === 0) {\n                core.warning(`No files found that can be uploaded`);\n            }\n            else {\n                // Create an entry for the artifact in the file container\n                const response = yield uploadHttpClient.createArtifactInFileContainer(name, options);\n                if (!response.fileContainerResourceUrl) {\n                    core.debug(response.toString());\n                    throw new Error('No URL provided by the Artifact Service to upload an artifact to');\n                }\n                core.debug(`Upload Resource URL: ${response.fileContainerResourceUrl}`);\n                // Upload each of the files that were found concurrently\n                const uploadResult = yield uploadHttpClient.uploadArtifactToFileContainer(response.fileContainerResourceUrl, uploadSpecification, options);\n                // Update the size of the artifact to indicate we are done uploading\n                // The uncompressed size is used for display when downloading a zip of the artifact from the UI\n                yield uploadHttpClient.patchArtifactSize(uploadResult.totalSize, name);\n                core.info(`Finished uploading artifact ${name}. Reported size is ${uploadResult.uploadSize} bytes. There were ${uploadResult.failedItems.length} items that failed to upload`);\n                uploadResponse.artifactItems = uploadSpecification.map(item => item.absoluteFilePath);\n                uploadResponse.size = uploadResult.uploadSize;\n                uploadResponse.failedItems = uploadResult.failedItems;\n            }\n            return uploadResponse;\n        });\n    }\n    downloadArtifact(name, path, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const downloadHttpClient = new download_http_client_1.DownloadHttpClient();\n            const artifacts = yield downloadHttpClient.listArtifacts();\n            if (artifacts.count === 0) {\n                throw new Error(`Unable to find any artifacts for the associated workflow`);\n            }\n            const artifactToDownload = artifacts.value.find(artifact => {\n                return artifact.name === name;\n            });\n            if (!artifactToDownload) {\n                throw new Error(`Unable to find an artifact with the name: ${name}`);\n            }\n            const items = yield downloadHttpClient.getContainerItems(artifactToDownload.name, artifactToDownload.fileContainerResourceUrl);\n            if (!path) {\n                path = config_variables_1.getWorkSpaceDirectory();\n            }\n            path = path_1.normalize(path);\n            path = path_1.resolve(path);\n            // During upload, empty directories are rejected by the remote server so there should be no artifacts that consist of only empty directories\n            const downloadSpecification = download_specification_1.getDownloadSpecification(name, items.value, path, (options === null || options === void 0 ? void 0 : options.createArtifactFolder) || false);\n            if (downloadSpecification.filesToDownload.length === 0) {\n                core.info(`No downloadable files were found for the artifact: ${artifactToDownload.name}`);\n            }\n            else {\n                // Create all necessary directories recursively before starting any download\n                yield utils_1.createDirectoriesForArtifact(downloadSpecification.directoryStructure);\n                core.info('Directory structure has been setup for the artifact');\n                yield utils_1.createEmptyFilesForArtifact(downloadSpecification.emptyFilesToCreate);\n                yield downloadHttpClient.downloadSingleArtifact(downloadSpecification.filesToDownload);\n            }\n            return {\n                artifactName: name,\n                downloadPath: downloadSpecification.rootDownloadLocation\n            };\n        });\n    }\n    downloadAllArtifacts(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const downloadHttpClient = new download_http_client_1.DownloadHttpClient();\n            const response = [];\n            const artifacts = yield downloadHttpClient.listArtifacts();\n            if (artifacts.count === 0) {\n                core.info('Unable to find any artifacts for the associated workflow');\n                return response;\n            }\n            if (!path) {\n                path = config_variables_1.getWorkSpaceDirectory();\n            }\n            path = path_1.normalize(path);\n            path = path_1.resolve(path);\n            let downloadedArtifacts = 0;\n            while (downloadedArtifacts < artifacts.count) {\n                const currentArtifactToDownload = artifacts.value[downloadedArtifacts];\n                downloadedArtifacts += 1;\n                // Get container entries for the specific artifact\n                const items = yield downloadHttpClient.getContainerItems(currentArtifactToDownload.name, currentArtifactToDownload.fileContainerResourceUrl);\n                const downloadSpecification = download_specification_1.getDownloadSpecification(currentArtifactToDownload.name, items.value, path, true);\n                if (downloadSpecification.filesToDownload.length === 0) {\n                    core.info(`No downloadable files were found for any artifact ${currentArtifactToDownload.name}`);\n                }\n                else {\n                    yield utils_1.createDirectoriesForArtifact(downloadSpecification.directoryStructure);\n                    yield utils_1.createEmptyFilesForArtifact(downloadSpecification.emptyFilesToCreate);\n                    yield downloadHttpClient.downloadSingleArtifact(downloadSpecification.filesToDownload);\n                }\n                response.push({\n                    artifactName: currentArtifactToDownload.name,\n                    downloadPath: downloadSpecification.rootDownloadLocation\n                });\n            }\n            return response;\n        });\n    }\n}\nexports.DefaultArtifactClient = DefaultArtifactClient;\n//# sourceMappingURL=artifact-client.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// The number of concurrent uploads that happens at the same time\nfunction getUploadFileConcurrency() {\n    return 2;\n}\nexports.getUploadFileConcurrency = getUploadFileConcurrency;\n// When uploading large files that can't be uploaded with a single http call, this controls\n// the chunk size that is used during upload\nfunction getUploadChunkSize() {\n    return 8 * 1024 * 1024; // 8 MB Chunks\n}\nexports.getUploadChunkSize = getUploadChunkSize;\n// The maximum number of retries that can be attempted before an upload or download fails\nfunction getRetryLimit() {\n    return 5;\n}\nexports.getRetryLimit = getRetryLimit;\n// With exponential backoff, the larger the retry count, the larger the wait time before another attempt\n// The retry multiplier controls by how much the backOff time increases depending on the number of retries\nfunction getRetryMultiplier() {\n    return 1.5;\n}\nexports.getRetryMultiplier = getRetryMultiplier;\n// The initial wait time if an upload or download fails and a retry is being attempted for the first time\nfunction getInitialRetryIntervalInMilliseconds() {\n    return 3000;\n}\nexports.getInitialRetryIntervalInMilliseconds = getInitialRetryIntervalInMilliseconds;\n// The number of concurrent downloads that happens at the same time\nfunction getDownloadFileConcurrency() {\n    return 2;\n}\nexports.getDownloadFileConcurrency = getDownloadFileConcurrency;\nfunction getRuntimeToken() {\n    const token = process.env['ACTIONS_RUNTIME_TOKEN'];\n    if (!token) {\n        throw new Error('Unable to get ACTIONS_RUNTIME_TOKEN env variable');\n    }\n    return token;\n}\nexports.getRuntimeToken = getRuntimeToken;\nfunction getRuntimeUrl() {\n    const runtimeUrl = process.env['ACTIONS_RUNTIME_URL'];\n    if (!runtimeUrl) {\n        throw new Error('Unable to get ACTIONS_RUNTIME_URL env variable');\n    }\n    return runtimeUrl;\n}\nexports.getRuntimeUrl = getRuntimeUrl;\nfunction getWorkFlowRunId() {\n    const workFlowRunId = process.env['GITHUB_RUN_ID'];\n    if (!workFlowRunId) {\n        throw new Error('Unable to get GITHUB_RUN_ID env variable');\n    }\n    return workFlowRunId;\n}\nexports.getWorkFlowRunId = getWorkFlowRunId;\nfunction getWorkSpaceDirectory() {\n    const workspaceDirectory = process.env['GITHUB_WORKSPACE'];\n    if (!workspaceDirectory) {\n        throw new Error('Unable to get GITHUB_WORKSPACE env variable');\n    }\n    return workspaceDirectory;\n}\nexports.getWorkSpaceDirectory = getWorkSpaceDirectory;\nfunction getRetentionDays() {\n    return process.env['GITHUB_RETENTION_DAYS'];\n}\nexports.getRetentionDays = getRetentionDays;\n//# sourceMappingURL=config-variables.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = __importStar(require(\"fs\"));\nconst core = __importStar(require(\"@actions/core\"));\nconst zlib = __importStar(require(\"zlib\"));\nconst utils_1 = require(\"./utils\");\nconst url_1 = require(\"url\");\nconst status_reporter_1 = require(\"./status-reporter\");\nconst perf_hooks_1 = require(\"perf_hooks\");\nconst http_manager_1 = require(\"./http-manager\");\nconst config_variables_1 = require(\"./config-variables\");\nclass DownloadHttpClient {\n    constructor() {\n        this.downloadHttpManager = new http_manager_1.HttpManager(config_variables_1.getDownloadFileConcurrency(), '@actions/artifact-download');\n        // downloads are usually significantly faster than uploads so display status information every second\n        this.statusReporter = new status_reporter_1.StatusReporter(1000);\n    }\n    /**\n     * Gets a list of all artifacts that are in a specific container\n     */\n    listArtifacts() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const artifactUrl = utils_1.getArtifactUrl();\n            // use the first client from the httpManager, `keep-alive` is not used so the connection will close immediately\n            const client = this.downloadHttpManager.getClient(0);\n            const headers = utils_1.getDownloadHeaders('application/json');\n            const response = yield client.get(artifactUrl, headers);\n            const body = yield response.readBody();\n            if (utils_1.isSuccessStatusCode(response.message.statusCode) && body) {\n                return JSON.parse(body);\n            }\n            utils_1.displayHttpDiagnostics(response);\n            throw new Error(`Unable to list artifacts for the run. Resource Url ${artifactUrl}`);\n        });\n    }\n    /**\n     * Fetches a set of container items that describe the contents of an artifact\n     * @param artifactName the name of the artifact\n     * @param containerUrl the artifact container URL for the run\n     */\n    getContainerItems(artifactName, containerUrl) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // the itemPath search parameter controls which containers will be returned\n            const resourceUrl = new url_1.URL(containerUrl);\n            resourceUrl.searchParams.append('itemPath', artifactName);\n            // use the first client from the httpManager, `keep-alive` is not used so the connection will close immediately\n            const client = this.downloadHttpManager.getClient(0);\n            const headers = utils_1.getDownloadHeaders('application/json');\n            const response = yield client.get(resourceUrl.toString(), headers);\n            const body = yield response.readBody();\n            if (utils_1.isSuccessStatusCode(response.message.statusCode) && body) {\n                return JSON.parse(body);\n            }\n            utils_1.displayHttpDiagnostics(response);\n            throw new Error(`Unable to get ContainersItems from ${resourceUrl}`);\n        });\n    }\n    /**\n     * Concurrently downloads all the files that are part of an artifact\n     * @param downloadItems information about what items to download and where to save them\n     */\n    downloadSingleArtifact(downloadItems) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const DOWNLOAD_CONCURRENCY = config_variables_1.getDownloadFileConcurrency();\n            // limit the number of files downloaded at a single time\n            core.debug(`Download file concurrency is set to ${DOWNLOAD_CONCURRENCY}`);\n            const parallelDownloads = [...new Array(DOWNLOAD_CONCURRENCY).keys()];\n            let currentFile = 0;\n            let downloadedFiles = 0;\n            core.info(`Total number of files that will be downloaded: ${downloadItems.length}`);\n            this.statusReporter.setTotalNumberOfFilesToProcess(downloadItems.length);\n            this.statusReporter.start();\n            yield Promise.all(parallelDownloads.map((index) => __awaiter(this, void 0, void 0, function* () {\n                while (currentFile < downloadItems.length) {\n                    const currentFileToDownload = downloadItems[currentFile];\n                    currentFile += 1;\n                    const startTime = perf_hooks_1.performance.now();\n                    yield this.downloadIndividualFile(index, currentFileToDownload.sourceLocation, currentFileToDownload.targetPath);\n                    if (core.isDebug()) {\n                        core.debug(`File: ${++downloadedFiles}/${downloadItems.length}. ${currentFileToDownload.targetPath} took ${(perf_hooks_1.performance.now() - startTime).toFixed(3)} milliseconds to finish downloading`);\n                    }\n                    this.statusReporter.incrementProcessedCount();\n                }\n            })))\n                .catch(error => {\n                throw new Error(`Unable to download the artifact: ${error}`);\n            })\n                .finally(() => {\n                this.statusReporter.stop();\n                // safety dispose all connections\n                this.downloadHttpManager.disposeAndReplaceAllClients();\n            });\n        });\n    }\n    /**\n     * Downloads an individual file\n     * @param httpClientIndex the index of the http client that is used to make all of the calls\n     * @param artifactLocation origin location where a file will be downloaded from\n     * @param downloadPath destination location for the file being downloaded\n     */\n    downloadIndividualFile(httpClientIndex, artifactLocation, downloadPath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let retryCount = 0;\n            const retryLimit = config_variables_1.getRetryLimit();\n            const destinationStream = fs.createWriteStream(downloadPath);\n            const headers = utils_1.getDownloadHeaders('application/json', true, true);\n            // a single GET request is used to download a file\n            const makeDownloadRequest = () => __awaiter(this, void 0, void 0, function* () {\n                const client = this.downloadHttpManager.getClient(httpClientIndex);\n                return yield client.get(artifactLocation, headers);\n            });\n            // check the response headers to determine if the file was compressed using gzip\n            const isGzip = (incomingHeaders) => {\n                return ('content-encoding' in incomingHeaders &&\n                    incomingHeaders['content-encoding'] === 'gzip');\n            };\n            // Increments the current retry count and then checks if the retry limit has been reached\n            // If there have been too many retries, fail so the download stops. If there is a retryAfterValue value provided,\n            // it will be used\n            const backOff = (retryAfterValue) => __awaiter(this, void 0, void 0, function* () {\n                retryCount++;\n                if (retryCount > retryLimit) {\n                    return Promise.reject(new Error(`Retry limit has been reached. Unable to download ${artifactLocation}`));\n                }\n                else {\n                    this.downloadHttpManager.disposeAndReplaceClient(httpClientIndex);\n                    if (retryAfterValue) {\n                        // Back off by waiting the specified time denoted by the retry-after header\n                        core.info(`Backoff due to too many requests, retry #${retryCount}. Waiting for ${retryAfterValue} milliseconds before continuing the download`);\n                        yield new Promise(resolve => setTimeout(resolve, retryAfterValue));\n                    }\n                    else {\n                        // Back off using an exponential value that depends on the retry count\n                        const backoffTime = utils_1.getExponentialRetryTimeInMilliseconds(retryCount);\n                        core.info(`Exponential backoff for retry #${retryCount}. Waiting for ${backoffTime} milliseconds before continuing the download`);\n                        yield new Promise(resolve => setTimeout(resolve, backoffTime));\n                    }\n                    core.info(`Finished backoff for retry #${retryCount}, continuing with download`);\n                }\n            });\n            // keep trying to download a file until a retry limit has been reached\n            while (retryCount <= retryLimit) {\n                let response;\n                try {\n                    response = yield makeDownloadRequest();\n                }\n                catch (error) {\n                    // if an error is caught, it is usually indicative of a timeout so retry the download\n                    core.info('An error occurred while attempting to download a file');\n                    // eslint-disable-next-line no-console\n                    console.log(error);\n                    // increment the retryCount and use exponential backoff to wait before making the next request\n                    yield backOff();\n                    continue;\n                }\n                if (utils_1.isSuccessStatusCode(response.message.statusCode)) {\n                    // The body contains the contents of the file however calling response.readBody() causes all the content to be converted to a string\n                    // which can cause some gzip encoded data to be lost\n                    // Instead of using response.readBody(), response.message is a readableStream that can be directly used to get the raw body contents\n                    return this.pipeResponseToFile(response, destinationStream, isGzip(response.message.headers));\n                }\n                else if (utils_1.isRetryableStatusCode(response.message.statusCode)) {\n                    core.info(`A ${response.message.statusCode} response code has been received while attempting to download an artifact`);\n                    // if a throttled status code is received, try to get the retryAfter header value, else differ to standard exponential backoff\n                    utils_1.isThrottledStatusCode(response.message.statusCode)\n                        ? yield backOff(utils_1.tryGetRetryAfterValueTimeInMilliseconds(response.message.headers))\n                        : yield backOff();\n                }\n                else {\n                    // Some unexpected response code, fail immediately and stop the download\n                    utils_1.displayHttpDiagnostics(response);\n                    return Promise.reject(new Error(`Unexpected http ${response.message.statusCode} during download for ${artifactLocation}`));\n                }\n            }\n        });\n    }\n    /**\n     * Pipes the response from downloading an individual file to the appropriate destination stream while decoding gzip content if necessary\n     * @param response the http response received when downloading a file\n     * @param destinationStream the stream where the file should be written to\n     * @param isGzip a boolean denoting if the content is compressed using gzip and if we need to decode it\n     */\n    pipeResponseToFile(response, destinationStream, isGzip) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield new Promise((resolve, reject) => {\n                if (isGzip) {\n                    const gunzip = zlib.createGunzip();\n                    response.message\n                        .pipe(gunzip)\n                        .pipe(destinationStream)\n                        .on('close', () => {\n                        resolve();\n                    })\n                        .on('error', error => {\n                        core.error(`An error has been encountered while decompressing and writing a downloaded file to ${destinationStream.path}`);\n                        reject(error);\n                    });\n                }\n                else {\n                    response.message\n                        .pipe(destinationStream)\n                        .on('close', () => {\n                        resolve();\n                    })\n                        .on('error', error => {\n                        core.error(`An error has been encountered while writing a downloaded file to ${destinationStream.path}`);\n                        reject(error);\n                    });\n                }\n            });\n            return;\n        });\n    }\n}\nexports.DownloadHttpClient = DownloadHttpClient;\n//# sourceMappingURL=download-http-client.js.map","\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst path = __importStar(require(\"path\"));\n/**\n * Creates a specification for a set of files that will be downloaded\n * @param artifactName the name of the artifact\n * @param artifactEntries a set of container entries that describe that files that make up an artifact\n * @param downloadPath the path where the artifact will be downloaded to\n * @param includeRootDirectory specifies if there should be an extra directory (denoted by the artifact name) where the artifact files should be downloaded to\n */\nfunction getDownloadSpecification(artifactName, artifactEntries, downloadPath, includeRootDirectory) {\n    // use a set for the directory paths so that there are no duplicates\n    const directories = new Set();\n    const specifications = {\n        rootDownloadLocation: includeRootDirectory\n            ? path.join(downloadPath, artifactName)\n            : downloadPath,\n        directoryStructure: [],\n        emptyFilesToCreate: [],\n        filesToDownload: []\n    };\n    for (const entry of artifactEntries) {\n        // Ignore artifacts in the container that don't begin with the same name\n        if (entry.path.startsWith(`${artifactName}/`) ||\n            entry.path.startsWith(`${artifactName}\\\\`)) {\n            // normalize all separators to the local OS\n            const normalizedPathEntry = path.normalize(entry.path);\n            // entry.path always starts with the artifact name, if includeRootDirectory is false, remove the name from the beginning of the path\n            const filePath = path.join(downloadPath, includeRootDirectory\n                ? normalizedPathEntry\n                : normalizedPathEntry.replace(artifactName, ''));\n            // Case insensitive folder structure maintained in the backend, not every folder is created so the 'folder'\n            // itemType cannot be relied upon. The file must be used to determine the directory structure\n            if (entry.itemType === 'file') {\n                // Get the directories that we need to create from the filePath for each individual file\n                directories.add(path.dirname(filePath));\n                if (entry.fileLength === 0) {\n                    // An empty file was uploaded, create the empty files locally so that no extra http calls are made\n                    specifications.emptyFilesToCreate.push(filePath);\n                }\n                else {\n                    specifications.filesToDownload.push({\n                        sourceLocation: entry.contentLocation,\n                        targetPath: filePath\n                    });\n                }\n            }\n        }\n    }\n    specifications.directoryStructure = Array.from(directories);\n    return specifications;\n}\nexports.getDownloadSpecification = getDownloadSpecification;\n//# sourceMappingURL=download-specification.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./utils\");\n/**\n * Used for managing http clients during either upload or download\n */\nclass HttpManager {\n    constructor(clientCount, userAgent) {\n        if (clientCount < 1) {\n            throw new Error('There must be at least one client');\n        }\n        this.userAgent = userAgent;\n        this.clients = new Array(clientCount).fill(utils_1.createHttpClient(userAgent));\n    }\n    getClient(index) {\n        return this.clients[index];\n    }\n    // client disposal is necessary if a keep-alive connection is used to properly close the connection\n    // for more information see: https://github.com/actions/http-client/blob/04e5ad73cd3fd1f5610a32116b0759eddf6570d2/index.ts#L292\n    disposeAndReplaceClient(index) {\n        this.clients[index].dispose();\n        this.clients[index] = utils_1.createHttpClient(this.userAgent);\n    }\n    disposeAndReplaceAllClients() {\n        for (const [index] of this.clients.entries()) {\n            this.disposeAndReplaceClient(index);\n        }\n    }\n}\nexports.HttpManager = HttpManager;\n//# sourceMappingURL=http-manager.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_1 = require(\"@actions/core\");\n/**\n * Status Reporter that displays information about the progress/status of an artifact that is being uploaded or downloaded\n *\n * Variable display time that can be adjusted using the displayFrequencyInMilliseconds variable\n * The total status of the upload/download gets displayed according to this value\n * If there is a large file that is being uploaded, extra information about the individual status can also be displayed using the updateLargeFileStatus function\n */\nclass StatusReporter {\n    constructor(displayFrequencyInMilliseconds) {\n        this.totalNumberOfFilesToProcess = 0;\n        this.processedCount = 0;\n        this.largeFiles = new Map();\n        this.totalFileStatus = undefined;\n        this.largeFileStatus = undefined;\n        this.displayFrequencyInMilliseconds = displayFrequencyInMilliseconds;\n    }\n    setTotalNumberOfFilesToProcess(fileTotal) {\n        this.totalNumberOfFilesToProcess = fileTotal;\n    }\n    start() {\n        // displays information about the total upload/download status\n        this.totalFileStatus = setInterval(() => {\n            // display 1 decimal place without any rounding\n            const percentage = this.formatPercentage(this.processedCount, this.totalNumberOfFilesToProcess);\n            core_1.info(`Total file count: ${this.totalNumberOfFilesToProcess} ---- Processed file #${this.processedCount} (${percentage.slice(0, percentage.indexOf('.') + 2)}%)`);\n        }, this.displayFrequencyInMilliseconds);\n        // displays extra information about any large files that take a significant amount of time to upload or download every 1 second\n        this.largeFileStatus = setInterval(() => {\n            for (const value of Array.from(this.largeFiles.values())) {\n                core_1.info(value);\n            }\n            // delete all entries in the map after displaying the information so it will not be displayed again unless explicitly added\n            this.largeFiles.clear();\n        }, 1000);\n    }\n    // if there is a large file that is being uploaded in chunks, this is used to display extra information about the status of the upload\n    updateLargeFileStatus(fileName, numerator, denominator) {\n        // display 1 decimal place without any rounding\n        const percentage = this.formatPercentage(numerator, denominator);\n        const displayInformation = `Uploading ${fileName} (${percentage.slice(0, percentage.indexOf('.') + 2)}%)`;\n        // any previously added display information should be overwritten for the specific large file because a map is being used\n        this.largeFiles.set(fileName, displayInformation);\n    }\n    stop() {\n        if (this.totalFileStatus) {\n            clearInterval(this.totalFileStatus);\n        }\n        if (this.largeFileStatus) {\n            clearInterval(this.largeFileStatus);\n        }\n    }\n    incrementProcessedCount() {\n        this.processedCount++;\n    }\n    formatPercentage(numerator, denominator) {\n        // toFixed() rounds, so use extra precision to display accurate information even though 4 decimal places are not displayed\n        return ((numerator / denominator) * 100).toFixed(4).toString();\n    }\n}\nexports.StatusReporter = StatusReporter;\n//# sourceMappingURL=status-reporter.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = __importStar(require(\"fs\"));\nconst zlib = __importStar(require(\"zlib\"));\nconst util_1 = require(\"util\");\nconst stat = util_1.promisify(fs.stat);\n/**\n * Creates a Gzip compressed file of an original file at the provided temporary filepath location\n * @param {string} originalFilePath filepath of whatever will be compressed. The original file will be unmodified\n * @param {string} tempFilePath the location of where the Gzip file will be created\n * @returns the size of gzip file that gets created\n */\nfunction createGZipFileOnDisk(originalFilePath, tempFilePath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            const inputStream = fs.createReadStream(originalFilePath);\n            const gzip = zlib.createGzip();\n            const outputStream = fs.createWriteStream(tempFilePath);\n            inputStream.pipe(gzip).pipe(outputStream);\n            outputStream.on('finish', () => __awaiter(this, void 0, void 0, function* () {\n                // wait for stream to finish before calculating the size which is needed as part of the Content-Length header when starting an upload\n                const size = (yield stat(tempFilePath)).size;\n                resolve(size);\n            }));\n            outputStream.on('error', error => {\n                // eslint-disable-next-line no-console\n                console.log(error);\n                reject;\n            });\n        });\n    });\n}\nexports.createGZipFileOnDisk = createGZipFileOnDisk;\n/**\n * Creates a GZip file in memory using a buffer. Should be used for smaller files to reduce disk I/O\n * @param originalFilePath the path to the original file that is being GZipped\n * @returns a buffer with the GZip file\n */\nfunction createGZipFileInBuffer(originalFilePath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n            var e_1, _a;\n            const inputStream = fs.createReadStream(originalFilePath);\n            const gzip = zlib.createGzip();\n            inputStream.pipe(gzip);\n            // read stream into buffer, using experimental async iterators see https://github.com/nodejs/readable-stream/issues/403#issuecomment-479069043\n            const chunks = [];\n            try {\n                for (var gzip_1 = __asyncValues(gzip), gzip_1_1; gzip_1_1 = yield gzip_1.next(), !gzip_1_1.done;) {\n                    const chunk = gzip_1_1.value;\n                    chunks.push(chunk);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (gzip_1_1 && !gzip_1_1.done && (_a = gzip_1.return)) yield _a.call(gzip_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            resolve(Buffer.concat(chunks));\n        }));\n    });\n}\nexports.createGZipFileInBuffer = createGZipFileInBuffer;\n//# sourceMappingURL=upload-gzip.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = __importStar(require(\"fs\"));\nconst core = __importStar(require(\"@actions/core\"));\nconst tmp = __importStar(require(\"tmp-promise\"));\nconst stream = __importStar(require(\"stream\"));\nconst utils_1 = require(\"./utils\");\nconst config_variables_1 = require(\"./config-variables\");\nconst util_1 = require(\"util\");\nconst url_1 = require(\"url\");\nconst perf_hooks_1 = require(\"perf_hooks\");\nconst status_reporter_1 = require(\"./status-reporter\");\nconst http_manager_1 = require(\"./http-manager\");\nconst upload_gzip_1 = require(\"./upload-gzip\");\nconst stat = util_1.promisify(fs.stat);\nclass UploadHttpClient {\n    constructor() {\n        this.uploadHttpManager = new http_manager_1.HttpManager(config_variables_1.getUploadFileConcurrency(), '@actions/artifact-upload');\n        this.statusReporter = new status_reporter_1.StatusReporter(10000);\n    }\n    /**\n     * Creates a file container for the new artifact in the remote blob storage/file service\n     * @param {string} artifactName Name of the artifact being created\n     * @returns The response from the Artifact Service if the file container was successfully created\n     */\n    createArtifactInFileContainer(artifactName, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const parameters = {\n                Type: 'actions_storage',\n                Name: artifactName\n            };\n            // calculate retention period\n            if (options && options.retentionDays) {\n                const maxRetentionStr = config_variables_1.getRetentionDays();\n                parameters.RetentionDays = utils_1.getProperRetention(options.retentionDays, maxRetentionStr);\n            }\n            const data = JSON.stringify(parameters, null, 2);\n            const artifactUrl = utils_1.getArtifactUrl();\n            // use the first client from the httpManager, `keep-alive` is not used so the connection will close immediately\n            const client = this.uploadHttpManager.getClient(0);\n            const headers = utils_1.getUploadHeaders('application/json', false);\n            const rawResponse = yield client.post(artifactUrl, data, headers);\n            const body = yield rawResponse.readBody();\n            if (utils_1.isSuccessStatusCode(rawResponse.message.statusCode) && body) {\n                return JSON.parse(body);\n            }\n            else if (utils_1.isForbiddenStatusCode(rawResponse.message.statusCode)) {\n                // if a 403 is returned when trying to create a file container, the customer has exceeded\n                // their storage quota so no new artifact containers can be created\n                throw new Error(`Artifact storage quota has been hit. Unable to upload any new artifacts`);\n            }\n            else {\n                utils_1.displayHttpDiagnostics(rawResponse);\n                throw new Error(`Unable to create a container for the artifact ${artifactName} at ${artifactUrl}`);\n            }\n        });\n    }\n    /**\n     * Concurrently upload all of the files in chunks\n     * @param {string} uploadUrl Base Url for the artifact that was created\n     * @param {SearchResult[]} filesToUpload A list of information about the files being uploaded\n     * @returns The size of all the files uploaded in bytes\n     */\n    uploadArtifactToFileContainer(uploadUrl, filesToUpload, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const FILE_CONCURRENCY = config_variables_1.getUploadFileConcurrency();\n            const MAX_CHUNK_SIZE = config_variables_1.getUploadChunkSize();\n            core.debug(`File Concurrency: ${FILE_CONCURRENCY}, and Chunk Size: ${MAX_CHUNK_SIZE}`);\n            const parameters = [];\n            // by default, file uploads will continue if there is an error unless specified differently in the options\n            let continueOnError = true;\n            if (options) {\n                if (options.continueOnError === false) {\n                    continueOnError = false;\n                }\n            }\n            // prepare the necessary parameters to upload all the files\n            for (const file of filesToUpload) {\n                const resourceUrl = new url_1.URL(uploadUrl);\n                resourceUrl.searchParams.append('itemPath', file.uploadFilePath);\n                parameters.push({\n                    file: file.absoluteFilePath,\n                    resourceUrl: resourceUrl.toString(),\n                    maxChunkSize: MAX_CHUNK_SIZE,\n                    continueOnError\n                });\n            }\n            const parallelUploads = [...new Array(FILE_CONCURRENCY).keys()];\n            const failedItemsToReport = [];\n            let currentFile = 0;\n            let completedFiles = 0;\n            let uploadFileSize = 0;\n            let totalFileSize = 0;\n            let abortPendingFileUploads = false;\n            this.statusReporter.setTotalNumberOfFilesToProcess(filesToUpload.length);\n            this.statusReporter.start();\n            // only allow a certain amount of files to be uploaded at once, this is done to reduce potential errors\n            yield Promise.all(parallelUploads.map((index) => __awaiter(this, void 0, void 0, function* () {\n                while (currentFile < filesToUpload.length) {\n                    const currentFileParameters = parameters[currentFile];\n                    currentFile += 1;\n                    if (abortPendingFileUploads) {\n                        failedItemsToReport.push(currentFileParameters.file);\n                        continue;\n                    }\n                    const startTime = perf_hooks_1.performance.now();\n                    const uploadFileResult = yield this.uploadFileAsync(index, currentFileParameters);\n                    if (core.isDebug()) {\n                        core.debug(`File: ${++completedFiles}/${filesToUpload.length}. ${currentFileParameters.file} took ${(perf_hooks_1.performance.now() - startTime).toFixed(3)} milliseconds to finish upload`);\n                    }\n                    uploadFileSize += uploadFileResult.successfulUploadSize;\n                    totalFileSize += uploadFileResult.totalSize;\n                    if (uploadFileResult.isSuccess === false) {\n                        failedItemsToReport.push(currentFileParameters.file);\n                        if (!continueOnError) {\n                            // fail fast\n                            core.error(`aborting artifact upload`);\n                            abortPendingFileUploads = true;\n                        }\n                    }\n                    this.statusReporter.incrementProcessedCount();\n                }\n            })));\n            this.statusReporter.stop();\n            // done uploading, safety dispose all connections\n            this.uploadHttpManager.disposeAndReplaceAllClients();\n            core.info(`Total size of all the files uploaded is ${uploadFileSize} bytes`);\n            return {\n                uploadSize: uploadFileSize,\n                totalSize: totalFileSize,\n                failedItems: failedItemsToReport\n            };\n        });\n    }\n    /**\n     * Asynchronously uploads a file. The file is compressed and uploaded using GZip if it is determined to save space.\n     * If the upload file is bigger than the max chunk size it will be uploaded via multiple calls\n     * @param {number} httpClientIndex The index of the httpClient that is being used to make all of the calls\n     * @param {UploadFileParameters} parameters Information about the file that needs to be uploaded\n     * @returns The size of the file that was uploaded in bytes along with any failed uploads\n     */\n    uploadFileAsync(httpClientIndex, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const totalFileSize = (yield stat(parameters.file)).size;\n            let offset = 0;\n            let isUploadSuccessful = true;\n            let failedChunkSizes = 0;\n            let uploadFileSize = 0;\n            let isGzip = true;\n            // the file that is being uploaded is less than 64k in size, to increase throughput and to minimize disk I/O\n            // for creating a new GZip file, an in-memory buffer is used for compression\n            if (totalFileSize < 65536) {\n                const buffer = yield upload_gzip_1.createGZipFileInBuffer(parameters.file);\n                //An open stream is needed in the event of a failure and we need to retry. If a NodeJS.ReadableStream is directly passed in,\n                // it will not properly get reset to the start of the stream if a chunk upload needs to be retried\n                let openUploadStream;\n                if (totalFileSize < buffer.byteLength) {\n                    // compression did not help with reducing the size, use a readable stream from the original file for upload\n                    openUploadStream = () => fs.createReadStream(parameters.file);\n                    isGzip = false;\n                    uploadFileSize = totalFileSize;\n                }\n                else {\n                    // create a readable stream using a PassThrough stream that is both readable and writable\n                    openUploadStream = () => {\n                        const passThrough = new stream.PassThrough();\n                        passThrough.end(buffer);\n                        return passThrough;\n                    };\n                    uploadFileSize = buffer.byteLength;\n                }\n                const result = yield this.uploadChunk(httpClientIndex, parameters.resourceUrl, openUploadStream, 0, uploadFileSize - 1, uploadFileSize, isGzip, totalFileSize);\n                if (!result) {\n                    // chunk failed to upload\n                    isUploadSuccessful = false;\n                    failedChunkSizes += uploadFileSize;\n                    core.warning(`Aborting upload for ${parameters.file} due to failure`);\n                }\n                return {\n                    isSuccess: isUploadSuccessful,\n                    successfulUploadSize: uploadFileSize - failedChunkSizes,\n                    totalSize: totalFileSize\n                };\n            }\n            else {\n                // the file that is being uploaded is greater than 64k in size, a temporary file gets created on disk using the\n                // npm tmp-promise package and this file gets used to create a GZipped file\n                const tempFile = yield tmp.file();\n                // create a GZip file of the original file being uploaded, the original file should not be modified in any way\n                uploadFileSize = yield upload_gzip_1.createGZipFileOnDisk(parameters.file, tempFile.path);\n                let uploadFilePath = tempFile.path;\n                // compression did not help with size reduction, use the original file for upload and delete the temp GZip file\n                if (totalFileSize < uploadFileSize) {\n                    uploadFileSize = totalFileSize;\n                    uploadFilePath = parameters.file;\n                    isGzip = false;\n                }\n                let abortFileUpload = false;\n                // upload only a single chunk at a time\n                while (offset < uploadFileSize) {\n                    const chunkSize = Math.min(uploadFileSize - offset, parameters.maxChunkSize);\n                    // if an individual file is greater than 100MB (1024*1024*100) in size, display extra information about the upload status\n                    if (uploadFileSize > 104857600) {\n                        this.statusReporter.updateLargeFileStatus(parameters.file, offset, uploadFileSize);\n                    }\n                    const start = offset;\n                    const end = offset + chunkSize - 1;\n                    offset += parameters.maxChunkSize;\n                    if (abortFileUpload) {\n                        // if we don't want to continue in the event of an error, any pending upload chunks will be marked as failed\n                        failedChunkSizes += chunkSize;\n                        continue;\n                    }\n                    const result = yield this.uploadChunk(httpClientIndex, parameters.resourceUrl, () => fs.createReadStream(uploadFilePath, {\n                        start,\n                        end,\n                        autoClose: false\n                    }), start, end, uploadFileSize, isGzip, totalFileSize);\n                    if (!result) {\n                        // Chunk failed to upload, report as failed and do not continue uploading any more chunks for the file. It is possible that part of a chunk was\n                        // successfully uploaded so the server may report a different size for what was uploaded\n                        isUploadSuccessful = false;\n                        failedChunkSizes += chunkSize;\n                        core.warning(`Aborting upload for ${parameters.file} due to failure`);\n                        abortFileUpload = true;\n                    }\n                }\n                // Delete the temporary file that was created as part of the upload. If the temp file does not get manually deleted by\n                // calling cleanup, it gets removed when the node process exits. For more info see: https://www.npmjs.com/package/tmp-promise#about\n                yield tempFile.cleanup();\n                return {\n                    isSuccess: isUploadSuccessful,\n                    successfulUploadSize: uploadFileSize - failedChunkSizes,\n                    totalSize: totalFileSize\n                };\n            }\n        });\n    }\n    /**\n     * Uploads a chunk of an individual file to the specified resourceUrl. If the upload fails and the status code\n     * indicates a retryable status, we try to upload the chunk as well\n     * @param {number} httpClientIndex The index of the httpClient being used to make all the necessary calls\n     * @param {string} resourceUrl Url of the resource that the chunk will be uploaded to\n     * @param {NodeJS.ReadableStream} openStream Stream of the file that will be uploaded\n     * @param {number} start Starting byte index of file that the chunk belongs to\n     * @param {number} end Ending byte index of file that the chunk belongs to\n     * @param {number} uploadFileSize Total size of the file in bytes that is being uploaded\n     * @param {boolean} isGzip Denotes if we are uploading a Gzip compressed stream\n     * @param {number} totalFileSize Original total size of the file that is being uploaded\n     * @returns if the chunk was successfully uploaded\n     */\n    uploadChunk(httpClientIndex, resourceUrl, openStream, start, end, uploadFileSize, isGzip, totalFileSize) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // prepare all the necessary headers before making any http call\n            const headers = utils_1.getUploadHeaders('application/octet-stream', true, isGzip, totalFileSize, end - start + 1, utils_1.getContentRange(start, end, uploadFileSize));\n            const uploadChunkRequest = () => __awaiter(this, void 0, void 0, function* () {\n                const client = this.uploadHttpManager.getClient(httpClientIndex);\n                return yield client.sendStream('PUT', resourceUrl, openStream(), headers);\n            });\n            let retryCount = 0;\n            const retryLimit = config_variables_1.getRetryLimit();\n            // Increments the current retry count and then checks if the retry limit has been reached\n            // If there have been too many retries, fail so the download stops\n            const incrementAndCheckRetryLimit = (response) => {\n                retryCount++;\n                if (retryCount > retryLimit) {\n                    if (response) {\n                        utils_1.displayHttpDiagnostics(response);\n                    }\n                    core.info(`Retry limit has been reached for chunk at offset ${start} to ${resourceUrl}`);\n                    return true;\n                }\n                return false;\n            };\n            const backOff = (retryAfterValue) => __awaiter(this, void 0, void 0, function* () {\n                this.uploadHttpManager.disposeAndReplaceClient(httpClientIndex);\n                if (retryAfterValue) {\n                    core.info(`Backoff due to too many requests, retry #${retryCount}. Waiting for ${retryAfterValue} milliseconds before continuing the upload`);\n                    yield new Promise(resolve => setTimeout(resolve, retryAfterValue));\n                }\n                else {\n                    const backoffTime = utils_1.getExponentialRetryTimeInMilliseconds(retryCount);\n                    core.info(`Exponential backoff for retry #${retryCount}. Waiting for ${backoffTime} milliseconds before continuing the upload at offset ${start}`);\n                    yield new Promise(resolve => setTimeout(resolve, backoffTime));\n                }\n                core.info(`Finished backoff for retry #${retryCount}, continuing with upload`);\n                return;\n            });\n            // allow for failed chunks to be retried multiple times\n            while (retryCount <= retryLimit) {\n                let response;\n                try {\n                    response = yield uploadChunkRequest();\n                }\n                catch (error) {\n                    // if an error is caught, it is usually indicative of a timeout so retry the upload\n                    core.info(`An error has been caught http-client index ${httpClientIndex}, retrying the upload`);\n                    // eslint-disable-next-line no-console\n                    console.log(error);\n                    if (incrementAndCheckRetryLimit()) {\n                        return false;\n                    }\n                    yield backOff();\n                    continue;\n                }\n                // Always read the body of the response. There is potential for a resource leak if the body is not read which will\n                // result in the connection remaining open along with unintended consequences when trying to dispose of the client\n                yield response.readBody();\n                if (utils_1.isSuccessStatusCode(response.message.statusCode)) {\n                    return true;\n                }\n                else if (utils_1.isRetryableStatusCode(response.message.statusCode)) {\n                    core.info(`A ${response.message.statusCode} status code has been received, will attempt to retry the upload`);\n                    if (incrementAndCheckRetryLimit(response)) {\n                        return false;\n                    }\n                    utils_1.isThrottledStatusCode(response.message.statusCode)\n                        ? yield backOff(utils_1.tryGetRetryAfterValueTimeInMilliseconds(response.message.headers))\n                        : yield backOff();\n                }\n                else {\n                    core.error(`Unexpected response. Unable to upload chunk to ${resourceUrl}`);\n                    utils_1.displayHttpDiagnostics(response);\n                    return false;\n                }\n            }\n            return false;\n        });\n    }\n    /**\n     * Updates the size of the artifact from -1 which was initially set when the container was first created for the artifact.\n     * Updating the size indicates that we are done uploading all the contents of the artifact\n     */\n    patchArtifactSize(size, artifactName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const headers = utils_1.getUploadHeaders('application/json', false);\n            const resourceUrl = new url_1.URL(utils_1.getArtifactUrl());\n            resourceUrl.searchParams.append('artifactName', artifactName);\n            const parameters = { Size: size };\n            const data = JSON.stringify(parameters, null, 2);\n            core.debug(`URL is ${resourceUrl.toString()}`);\n            // use the first client from the httpManager, `keep-alive` is not used so the connection will close immediately\n            const client = this.uploadHttpManager.getClient(0);\n            const response = yield client.patch(resourceUrl.toString(), data, headers);\n            const body = yield response.readBody();\n            if (utils_1.isSuccessStatusCode(response.message.statusCode)) {\n                core.debug(`Artifact ${artifactName} has been successfully uploaded, total size in bytes: ${size}`);\n            }\n            else if (response.message.statusCode === 404) {\n                throw new Error(`An Artifact with the name ${artifactName} was not found`);\n            }\n            else {\n                utils_1.displayHttpDiagnostics(response);\n                core.info(body);\n                throw new Error(`Unable to finish uploading artifact ${artifactName} to ${resourceUrl}`);\n            }\n        });\n    }\n}\nexports.UploadHttpClient = UploadHttpClient;\n//# sourceMappingURL=upload-http-client.js.map","\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = __importStar(require(\"fs\"));\nconst core_1 = require(\"@actions/core\");\nconst path_1 = require(\"path\");\nconst utils_1 = require(\"./utils\");\n/**\n * Creates a specification that describes how each file that is part of the artifact will be uploaded\n * @param artifactName the name of the artifact being uploaded. Used during upload to denote where the artifact is stored on the server\n * @param rootDirectory an absolute file path that denotes the path that should be removed from the beginning of each artifact file\n * @param artifactFiles a list of absolute file paths that denote what should be uploaded as part of the artifact\n */\nfunction getUploadSpecification(artifactName, rootDirectory, artifactFiles) {\n    utils_1.checkArtifactName(artifactName);\n    const specifications = [];\n    if (!fs.existsSync(rootDirectory)) {\n        throw new Error(`Provided rootDirectory ${rootDirectory} does not exist`);\n    }\n    if (!fs.lstatSync(rootDirectory).isDirectory()) {\n        throw new Error(`Provided rootDirectory ${rootDirectory} is not a valid directory`);\n    }\n    // Normalize and resolve, this allows for either absolute or relative paths to be used\n    rootDirectory = path_1.normalize(rootDirectory);\n    rootDirectory = path_1.resolve(rootDirectory);\n    /*\n       Example to demonstrate behavior\n       \n       Input:\n         artifactName: my-artifact\n         rootDirectory: '/home/user/files/plz-upload'\n         artifactFiles: [\n           '/home/user/files/plz-upload/file1.txt',\n           '/home/user/files/plz-upload/file2.txt',\n           '/home/user/files/plz-upload/dir/file3.txt'\n         ]\n       \n       Output:\n         specifications: [\n           ['/home/user/files/plz-upload/file1.txt', 'my-artifact/file1.txt'],\n           ['/home/user/files/plz-upload/file1.txt', 'my-artifact/file2.txt'],\n           ['/home/user/files/plz-upload/file1.txt', 'my-artifact/dir/file3.txt']\n         ]\n    */\n    for (let file of artifactFiles) {\n        if (!fs.existsSync(file)) {\n            throw new Error(`File ${file} does not exist`);\n        }\n        if (!fs.lstatSync(file).isDirectory()) {\n            // Normalize and resolve, this allows for either absolute or relative paths to be used\n            file = path_1.normalize(file);\n            file = path_1.resolve(file);\n            if (!file.startsWith(rootDirectory)) {\n                throw new Error(`The rootDirectory: ${rootDirectory} is not a parent directory of the file: ${file}`);\n            }\n            // Check for forbidden characters in file paths that will be rejected during upload\n            const uploadPath = file.replace(rootDirectory, '');\n            utils_1.checkArtifactFilePath(uploadPath);\n            /*\n              uploadFilePath denotes where the file will be uploaded in the file container on the server. During a run, if multiple artifacts are uploaded, they will all\n              be saved in the same container. The artifact name is used as the root directory in the container to separate and distinguish uploaded artifacts\n      \n              path.join handles all the following cases and would return 'artifact-name/file-to-upload.txt\n                join('artifact-name/', 'file-to-upload.txt')\n                join('artifact-name/', '/file-to-upload.txt')\n                join('artifact-name', 'file-to-upload.txt')\n                join('artifact-name', '/file-to-upload.txt')\n            */\n            specifications.push({\n                absoluteFilePath: file,\n                uploadFilePath: path_1.join(artifactName, uploadPath)\n            });\n        }\n        else {\n            // Directories are rejected by the server during upload\n            core_1.debug(`Removing ${file} from rawSearchResults because it is a directory`);\n        }\n    }\n    return specifications;\n}\nexports.getUploadSpecification = getUploadSpecification;\n//# sourceMappingURL=upload-specification.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_1 = require(\"@actions/core\");\nconst fs_1 = require(\"fs\");\nconst http_client_1 = require(\"@actions/http-client\");\nconst auth_1 = require(\"@actions/http-client/auth\");\nconst config_variables_1 = require(\"./config-variables\");\n/**\n * Returns a retry time in milliseconds that exponentially gets larger\n * depending on the amount of retries that have been attempted\n */\nfunction getExponentialRetryTimeInMilliseconds(retryCount) {\n    if (retryCount < 0) {\n        throw new Error('RetryCount should not be negative');\n    }\n    else if (retryCount === 0) {\n        return config_variables_1.getInitialRetryIntervalInMilliseconds();\n    }\n    const minTime = config_variables_1.getInitialRetryIntervalInMilliseconds() * config_variables_1.getRetryMultiplier() * retryCount;\n    const maxTime = minTime * config_variables_1.getRetryMultiplier();\n    // returns a random number between the minTime (inclusive) and the maxTime (exclusive)\n    return Math.random() * (maxTime - minTime) + minTime;\n}\nexports.getExponentialRetryTimeInMilliseconds = getExponentialRetryTimeInMilliseconds;\n/**\n * Parses a env variable that is a number\n */\nfunction parseEnvNumber(key) {\n    const value = Number(process.env[key]);\n    if (Number.isNaN(value) || value < 0) {\n        return undefined;\n    }\n    return value;\n}\nexports.parseEnvNumber = parseEnvNumber;\n/**\n * Various utility functions to help with the necessary API calls\n */\nfunction getApiVersion() {\n    return '6.0-preview';\n}\nexports.getApiVersion = getApiVersion;\nfunction isSuccessStatusCode(statusCode) {\n    if (!statusCode) {\n        return false;\n    }\n    return statusCode >= 200 && statusCode < 300;\n}\nexports.isSuccessStatusCode = isSuccessStatusCode;\nfunction isForbiddenStatusCode(statusCode) {\n    if (!statusCode) {\n        return false;\n    }\n    return statusCode === http_client_1.HttpCodes.Forbidden;\n}\nexports.isForbiddenStatusCode = isForbiddenStatusCode;\nfunction isRetryableStatusCode(statusCode) {\n    if (!statusCode) {\n        return false;\n    }\n    const retryableStatusCodes = [\n        http_client_1.HttpCodes.BadGateway,\n        http_client_1.HttpCodes.ServiceUnavailable,\n        http_client_1.HttpCodes.GatewayTimeout,\n        http_client_1.HttpCodes.TooManyRequests,\n        413 // Payload Too Large\n    ];\n    return retryableStatusCodes.includes(statusCode);\n}\nexports.isRetryableStatusCode = isRetryableStatusCode;\nfunction isThrottledStatusCode(statusCode) {\n    if (!statusCode) {\n        return false;\n    }\n    return statusCode === http_client_1.HttpCodes.TooManyRequests;\n}\nexports.isThrottledStatusCode = isThrottledStatusCode;\n/**\n * Attempts to get the retry-after value from a set of http headers. The retry time\n * is originally denoted in seconds, so if present, it is converted to milliseconds\n * @param headers all the headers received when making an http call\n */\nfunction tryGetRetryAfterValueTimeInMilliseconds(headers) {\n    if (headers['retry-after']) {\n        const retryTime = Number(headers['retry-after']);\n        if (!isNaN(retryTime)) {\n            core_1.info(`Retry-After header is present with a value of ${retryTime}`);\n            return retryTime * 1000;\n        }\n        core_1.info(`Returned retry-after header value: ${retryTime} is non-numeric and cannot be used`);\n        return undefined;\n    }\n    core_1.info(`No retry-after header was found. Dumping all headers for diagnostic purposes`);\n    // eslint-disable-next-line no-console\n    console.log(headers);\n    return undefined;\n}\nexports.tryGetRetryAfterValueTimeInMilliseconds = tryGetRetryAfterValueTimeInMilliseconds;\nfunction getContentRange(start, end, total) {\n    // Format: `bytes start-end/fileSize\n    // start and end are inclusive\n    // For a 200 byte chunk starting at byte 0:\n    // Content-Range: bytes 0-199/200\n    return `bytes ${start}-${end}/${total}`;\n}\nexports.getContentRange = getContentRange;\n/**\n * Sets all the necessary headers when downloading an artifact\n * @param {string} contentType the type of content being uploaded\n * @param {boolean} isKeepAlive is the same connection being used to make multiple calls\n * @param {boolean} acceptGzip can we accept a gzip encoded response\n * @param {string} acceptType the type of content that we can accept\n * @returns appropriate headers to make a specific http call during artifact download\n */\nfunction getDownloadHeaders(contentType, isKeepAlive, acceptGzip) {\n    const requestOptions = {};\n    if (contentType) {\n        requestOptions['Content-Type'] = contentType;\n    }\n    if (isKeepAlive) {\n        requestOptions['Connection'] = 'Keep-Alive';\n        // keep alive for at least 10 seconds before closing the connection\n        requestOptions['Keep-Alive'] = '10';\n    }\n    if (acceptGzip) {\n        // if we are expecting a response with gzip encoding, it should be using an octet-stream in the accept header\n        requestOptions['Accept-Encoding'] = 'gzip';\n        requestOptions['Accept'] = `application/octet-stream;api-version=${getApiVersion()}`;\n    }\n    else {\n        // default to application/json if we are not working with gzip content\n        requestOptions['Accept'] = `application/json;api-version=${getApiVersion()}`;\n    }\n    return requestOptions;\n}\nexports.getDownloadHeaders = getDownloadHeaders;\n/**\n * Sets all the necessary headers when uploading an artifact\n * @param {string} contentType the type of content being uploaded\n * @param {boolean} isKeepAlive is the same connection being used to make multiple calls\n * @param {boolean} isGzip is the connection being used to upload GZip compressed content\n * @param {number} uncompressedLength the original size of the content if something is being uploaded that has been compressed\n * @param {number} contentLength the length of the content that is being uploaded\n * @param {string} contentRange the range of the content that is being uploaded\n * @returns appropriate headers to make a specific http call during artifact upload\n */\nfunction getUploadHeaders(contentType, isKeepAlive, isGzip, uncompressedLength, contentLength, contentRange) {\n    const requestOptions = {};\n    requestOptions['Accept'] = `application/json;api-version=${getApiVersion()}`;\n    if (contentType) {\n        requestOptions['Content-Type'] = contentType;\n    }\n    if (isKeepAlive) {\n        requestOptions['Connection'] = 'Keep-Alive';\n        // keep alive for at least 10 seconds before closing the connection\n        requestOptions['Keep-Alive'] = '10';\n    }\n    if (isGzip) {\n        requestOptions['Content-Encoding'] = 'gzip';\n        requestOptions['x-tfs-filelength'] = uncompressedLength;\n    }\n    if (contentLength) {\n        requestOptions['Content-Length'] = contentLength;\n    }\n    if (contentRange) {\n        requestOptions['Content-Range'] = contentRange;\n    }\n    return requestOptions;\n}\nexports.getUploadHeaders = getUploadHeaders;\nfunction createHttpClient(userAgent) {\n    return new http_client_1.HttpClient(userAgent, [\n        new auth_1.BearerCredentialHandler(config_variables_1.getRuntimeToken())\n    ]);\n}\nexports.createHttpClient = createHttpClient;\nfunction getArtifactUrl() {\n    const artifactUrl = `${config_variables_1.getRuntimeUrl()}_apis/pipelines/workflows/${config_variables_1.getWorkFlowRunId()}/artifacts?api-version=${getApiVersion()}`;\n    core_1.debug(`Artifact Url: ${artifactUrl}`);\n    return artifactUrl;\n}\nexports.getArtifactUrl = getArtifactUrl;\n/**\n * Uh oh! Something might have gone wrong during either upload or download. The IHtttpClientResponse object contains information\n * about the http call that was made by the actions http client. This information might be useful to display for diagnostic purposes, but\n * this entire object is really big and most of the information is not really useful. This function takes the response object and displays only\n * the information that we want.\n *\n * Certain information such as the TLSSocket and the Readable state are not really useful for diagnostic purposes so they can be avoided.\n * Other information such as the headers, the response code and message might be useful, so this is displayed.\n */\nfunction displayHttpDiagnostics(response) {\n    core_1.info(`##### Begin Diagnostic HTTP information #####\nStatus Code: ${response.message.statusCode}\nStatus Message: ${response.message.statusMessage}\nHeader Information: ${JSON.stringify(response.message.headers, undefined, 2)}\n###### End Diagnostic HTTP information ######`);\n}\nexports.displayHttpDiagnostics = displayHttpDiagnostics;\n/**\n * Invalid characters that cannot be in the artifact name or an uploaded file. Will be rejected\n * from the server if attempted to be sent over. These characters are not allowed due to limitations with certain\n * file systems such as NTFS. To maintain platform-agnostic behavior, all characters that are not supported by an\n * individual filesystem/platform will not be supported on all fileSystems/platforms\n *\n * FilePaths can include characters such as \\ and / which are not permitted in the artifact name alone\n */\nconst invalidArtifactFilePathCharacters = ['\"', ':', '<', '>', '|', '*', '?'];\nconst invalidArtifactNameCharacters = [\n    ...invalidArtifactFilePathCharacters,\n    '\\\\',\n    '/'\n];\n/**\n * Scans the name of the artifact to make sure there are no illegal characters\n */\nfunction checkArtifactName(name) {\n    if (!name) {\n        throw new Error(`Artifact name: ${name}, is incorrectly provided`);\n    }\n    for (const invalidChar of invalidArtifactNameCharacters) {\n        if (name.includes(invalidChar)) {\n            throw new Error(`Artifact name is not valid: ${name}. Contains character: \"${invalidChar}\". Invalid artifact name characters include: ${invalidArtifactNameCharacters.toString()}.`);\n        }\n    }\n}\nexports.checkArtifactName = checkArtifactName;\n/**\n * Scans the name of the filePath used to make sure there are no illegal characters\n */\nfunction checkArtifactFilePath(path) {\n    if (!path) {\n        throw new Error(`Artifact path: ${path}, is incorrectly provided`);\n    }\n    for (const invalidChar of invalidArtifactFilePathCharacters) {\n        if (path.includes(invalidChar)) {\n            throw new Error(`Artifact path is not valid: ${path}. Contains character: \"${invalidChar}\". Invalid characters include: ${invalidArtifactFilePathCharacters.toString()}.`);\n        }\n    }\n}\nexports.checkArtifactFilePath = checkArtifactFilePath;\nfunction createDirectoriesForArtifact(directories) {\n    return __awaiter(this, void 0, void 0, function* () {\n        for (const directory of directories) {\n            yield fs_1.promises.mkdir(directory, {\n                recursive: true\n            });\n        }\n    });\n}\nexports.createDirectoriesForArtifact = createDirectoriesForArtifact;\nfunction createEmptyFilesForArtifact(emptyFilesToCreate) {\n    return __awaiter(this, void 0, void 0, function* () {\n        for (const filePath of emptyFilesToCreate) {\n            yield (yield fs_1.promises.open(filePath, 'w')).close();\n        }\n    });\n}\nexports.createEmptyFilesForArtifact = createEmptyFilesForArtifact;\nfunction getProperRetention(retentionInput, retentionSetting) {\n    if (retentionInput < 0) {\n        throw new Error('Invalid retention, minimum value is 1.');\n    }\n    let retention = retentionInput;\n    if (retentionSetting) {\n        const maxRetention = parseInt(retentionSetting);\n        if (!isNaN(maxRetention) && maxRetention < retention) {\n            core_1.warning(`Retention days is greater than the max value allowed by the repository setting, reduce retention to ${maxRetention} days`);\n            retention = maxRetention;\n        }\n    }\n    return retention;\n}\nexports.getProperRetention = getProperRetention;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nfunction issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message) {\n        if (!command) {\n            command = 'missing.command';\n        }\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for (const key in this.properties) {\n                if (this.properties.hasOwnProperty(key)) {\n                    const val = this.properties[key];\n                    if (val) {\n                        if (first) {\n                            first = false;\n                        }\n                        else {\n                            cmdStr += ',';\n                        }\n                        cmdStr += `${key}=${escapeProperty(val)}`;\n                    }\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A')\n        .replace(/:/g, '%3A')\n        .replace(/,/g, '%2C');\n}\n//# sourceMappingURL=command.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst command_1 = require(\"./command\");\nconst file_command_1 = require(\"./file-command\");\nconst utils_1 = require(\"./utils\");\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\n/**\n * The code to exit an action\n */\nvar ExitCode;\n(function (ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */\n    ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */\n    ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        const delimiter = '_GitHubActionsFileCommandDelimeter_';\n        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;\n        file_command_1.issueCommand('ENV', commandValue);\n    }\n    else {\n        command_1.issueCommand('set-env', { name }, convertedVal);\n    }\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nfunction setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nfunction addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) {\n        file_command_1.issueCommand('PATH', inputPath);\n    }\n    else {\n        command_1.issueCommand('add-path', {}, inputPath);\n    }\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.  The value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nfunction getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) {\n        throw new Error(`Input required and not supplied: ${name}`);\n    }\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    command_1.issueCommand('set-output', { name }, value);\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nfunction setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nfunction setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */\nfunction isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nfunction debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n */\nfunction error(message) {\n    command_1.issue('error', message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds an warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n */\nfunction warning(message) {\n    command_1.issue('warning', message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nfunction info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nfunction startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */\nfunction endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nfunction group(name, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        }\n        finally {\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    command_1.issueCommand('save-state', { name }, value);\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nfunction getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\n//# sourceMappingURL=core.js.map","\"use strict\";\n// For internal use, subject to change.\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fs = __importStar(require(\"fs\"));\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\nfunction issueCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) {\n        throw new Error(`Unable to find environment variable for file command ${command}`);\n    }\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`Missing file at path: ${filePath}`);\n    }\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueCommand = issueCommand;\n//# sourceMappingURL=file-command.js.map","\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nfunction toCommandValue(input) {\n    if (input === null || input === undefined) {\n        return '';\n    }\n    else if (typeof input === 'string' || input instanceof String) {\n        return input;\n    }\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass BasicCredentialHandler {\n    constructor(username, password) {\n        this.username = username;\n        this.password = password;\n    }\n    prepareRequest(options) {\n        options.headers['Authorization'] =\n            'Basic ' +\n                Buffer.from(this.username + ':' + this.password).toString('base64');\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.BasicCredentialHandler = BasicCredentialHandler;\nclass BearerCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        options.headers['Authorization'] = 'Bearer ' + this.token;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.BearerCredentialHandler = BearerCredentialHandler;\nclass PersonalAccessTokenCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        options.headers['Authorization'] =\n            'Basic ' + Buffer.from('PAT:' + this.token).toString('base64');\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst pm = require(\"./proxy\");\nlet tunnel;\nvar HttpCodes;\n(function (HttpCodes) {\n    HttpCodes[HttpCodes[\"OK\"] = 200] = \"OK\";\n    HttpCodes[HttpCodes[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n    HttpCodes[HttpCodes[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n    HttpCodes[HttpCodes[\"ResourceMoved\"] = 302] = \"ResourceMoved\";\n    HttpCodes[HttpCodes[\"SeeOther\"] = 303] = \"SeeOther\";\n    HttpCodes[HttpCodes[\"NotModified\"] = 304] = \"NotModified\";\n    HttpCodes[HttpCodes[\"UseProxy\"] = 305] = \"UseProxy\";\n    HttpCodes[HttpCodes[\"SwitchProxy\"] = 306] = \"SwitchProxy\";\n    HttpCodes[HttpCodes[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    HttpCodes[HttpCodes[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    HttpCodes[HttpCodes[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpCodes[HttpCodes[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpCodes[HttpCodes[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n    HttpCodes[HttpCodes[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpCodes[HttpCodes[\"NotFound\"] = 404] = \"NotFound\";\n    HttpCodes[HttpCodes[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n    HttpCodes[HttpCodes[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n    HttpCodes[HttpCodes[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n    HttpCodes[HttpCodes[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpCodes[HttpCodes[\"Conflict\"] = 409] = \"Conflict\";\n    HttpCodes[HttpCodes[\"Gone\"] = 410] = \"Gone\";\n    HttpCodes[HttpCodes[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n    HttpCodes[HttpCodes[\"InternalServerError\"] = 500] = \"InternalServerError\";\n    HttpCodes[HttpCodes[\"NotImplemented\"] = 501] = \"NotImplemented\";\n    HttpCodes[HttpCodes[\"BadGateway\"] = 502] = \"BadGateway\";\n    HttpCodes[HttpCodes[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n    HttpCodes[HttpCodes[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));\nvar Headers;\n(function (Headers) {\n    Headers[\"Accept\"] = \"accept\";\n    Headers[\"ContentType\"] = \"content-type\";\n})(Headers = exports.Headers || (exports.Headers = {}));\nvar MediaTypes;\n(function (MediaTypes) {\n    MediaTypes[\"ApplicationJson\"] = \"application/json\";\n})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));\n/**\n * Returns the proxy URL, depending upon the supplied url and proxy environment variables.\n * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n */\nfunction getProxyUrl(serverUrl) {\n    let proxyUrl = pm.getProxyUrl(new URL(serverUrl));\n    return proxyUrl ? proxyUrl.href : '';\n}\nexports.getProxyUrl = getProxyUrl;\nconst HttpRedirectCodes = [\n    HttpCodes.MovedPermanently,\n    HttpCodes.ResourceMoved,\n    HttpCodes.SeeOther,\n    HttpCodes.TemporaryRedirect,\n    HttpCodes.PermanentRedirect\n];\nconst HttpResponseRetryCodes = [\n    HttpCodes.BadGateway,\n    HttpCodes.ServiceUnavailable,\n    HttpCodes.GatewayTimeout\n];\nconst RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];\nconst ExponentialBackoffCeiling = 10;\nconst ExponentialBackoffTimeSlice = 5;\nclass HttpClientError extends Error {\n    constructor(message, statusCode) {\n        super(message);\n        this.name = 'HttpClientError';\n        this.statusCode = statusCode;\n        Object.setPrototypeOf(this, HttpClientError.prototype);\n    }\n}\nexports.HttpClientError = HttpClientError;\nclass HttpClientResponse {\n    constructor(message) {\n        this.message = message;\n    }\n    readBody() {\n        return new Promise(async (resolve, reject) => {\n            let output = Buffer.alloc(0);\n            this.message.on('data', (chunk) => {\n                output = Buffer.concat([output, chunk]);\n            });\n            this.message.on('end', () => {\n                resolve(output.toString());\n            });\n        });\n    }\n}\nexports.HttpClientResponse = HttpClientResponse;\nfunction isHttps(requestUrl) {\n    let parsedUrl = new URL(requestUrl);\n    return parsedUrl.protocol === 'https:';\n}\nexports.isHttps = isHttps;\nclass HttpClient {\n    constructor(userAgent, handlers, requestOptions) {\n        this._ignoreSslError = false;\n        this._allowRedirects = true;\n        this._allowRedirectDowngrade = false;\n        this._maxRedirects = 50;\n        this._allowRetries = false;\n        this._maxRetries = 1;\n        this._keepAlive = false;\n        this._disposed = false;\n        this.userAgent = userAgent;\n        this.handlers = handlers || [];\n        this.requestOptions = requestOptions;\n        if (requestOptions) {\n            if (requestOptions.ignoreSslError != null) {\n                this._ignoreSslError = requestOptions.ignoreSslError;\n            }\n            this._socketTimeout = requestOptions.socketTimeout;\n            if (requestOptions.allowRedirects != null) {\n                this._allowRedirects = requestOptions.allowRedirects;\n            }\n            if (requestOptions.allowRedirectDowngrade != null) {\n                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;\n            }\n            if (requestOptions.maxRedirects != null) {\n                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);\n            }\n            if (requestOptions.keepAlive != null) {\n                this._keepAlive = requestOptions.keepAlive;\n            }\n            if (requestOptions.allowRetries != null) {\n                this._allowRetries = requestOptions.allowRetries;\n            }\n            if (requestOptions.maxRetries != null) {\n                this._maxRetries = requestOptions.maxRetries;\n            }\n        }\n    }\n    options(requestUrl, additionalHeaders) {\n        return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});\n    }\n    get(requestUrl, additionalHeaders) {\n        return this.request('GET', requestUrl, null, additionalHeaders || {});\n    }\n    del(requestUrl, additionalHeaders) {\n        return this.request('DELETE', requestUrl, null, additionalHeaders || {});\n    }\n    post(requestUrl, data, additionalHeaders) {\n        return this.request('POST', requestUrl, data, additionalHeaders || {});\n    }\n    patch(requestUrl, data, additionalHeaders) {\n        return this.request('PATCH', requestUrl, data, additionalHeaders || {});\n    }\n    put(requestUrl, data, additionalHeaders) {\n        return this.request('PUT', requestUrl, data, additionalHeaders || {});\n    }\n    head(requestUrl, additionalHeaders) {\n        return this.request('HEAD', requestUrl, null, additionalHeaders || {});\n    }\n    sendStream(verb, requestUrl, stream, additionalHeaders) {\n        return this.request(verb, requestUrl, stream, additionalHeaders);\n    }\n    /**\n     * Gets a typed object from an endpoint\n     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise\n     */\n    async getJson(requestUrl, additionalHeaders = {}) {\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        let res = await this.get(requestUrl, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async postJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.post(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async putJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.put(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async patchJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.patch(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    /**\n     * Makes a raw http request.\n     * All other methods such as get, post, patch, and request ultimately call this.\n     * Prefer get, del, post and patch\n     */\n    async request(verb, requestUrl, data, headers) {\n        if (this._disposed) {\n            throw new Error('Client has already been disposed.');\n        }\n        let parsedUrl = new URL(requestUrl);\n        let info = this._prepareRequest(verb, parsedUrl, headers);\n        // Only perform retries on reads since writes may not be idempotent.\n        let maxTries = this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1\n            ? this._maxRetries + 1\n            : 1;\n        let numTries = 0;\n        let response;\n        while (numTries < maxTries) {\n            response = await this.requestRaw(info, data);\n            // Check if it's an authentication challenge\n            if (response &&\n                response.message &&\n                response.message.statusCode === HttpCodes.Unauthorized) {\n                let authenticationHandler;\n                for (let i = 0; i < this.handlers.length; i++) {\n                    if (this.handlers[i].canHandleAuthentication(response)) {\n                        authenticationHandler = this.handlers[i];\n                        break;\n                    }\n                }\n                if (authenticationHandler) {\n                    return authenticationHandler.handleAuthentication(this, info, data);\n                }\n                else {\n                    // We have received an unauthorized response but have no handlers to handle it.\n                    // Let the response return to the caller.\n                    return response;\n                }\n            }\n            let redirectsRemaining = this._maxRedirects;\n            while (HttpRedirectCodes.indexOf(response.message.statusCode) != -1 &&\n                this._allowRedirects &&\n                redirectsRemaining > 0) {\n                const redirectUrl = response.message.headers['location'];\n                if (!redirectUrl) {\n                    // if there's no location to redirect to, we won't\n                    break;\n                }\n                let parsedRedirectUrl = new URL(redirectUrl);\n                if (parsedUrl.protocol == 'https:' &&\n                    parsedUrl.protocol != parsedRedirectUrl.protocol &&\n                    !this._allowRedirectDowngrade) {\n                    throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');\n                }\n                // we need to finish reading the response before reassigning response\n                // which will leak the open socket.\n                await response.readBody();\n                // strip authorization header if redirected to a different hostname\n                if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {\n                    for (let header in headers) {\n                        // header names are case insensitive\n                        if (header.toLowerCase() === 'authorization') {\n                            delete headers[header];\n                        }\n                    }\n                }\n                // let's make the request with the new redirectUrl\n                info = this._prepareRequest(verb, parsedRedirectUrl, headers);\n                response = await this.requestRaw(info, data);\n                redirectsRemaining--;\n            }\n            if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) {\n                // If not a retry code, return immediately instead of retrying\n                return response;\n            }\n            numTries += 1;\n            if (numTries < maxTries) {\n                await response.readBody();\n                await this._performExponentialBackoff(numTries);\n            }\n        }\n        return response;\n    }\n    /**\n     * Needs to be called if keepAlive is set to true in request options.\n     */\n    dispose() {\n        if (this._agent) {\n            this._agent.destroy();\n        }\n        this._disposed = true;\n    }\n    /**\n     * Raw request.\n     * @param info\n     * @param data\n     */\n    requestRaw(info, data) {\n        return new Promise((resolve, reject) => {\n            let callbackForResult = function (err, res) {\n                if (err) {\n                    reject(err);\n                }\n                resolve(res);\n            };\n            this.requestRawWithCallback(info, data, callbackForResult);\n        });\n    }\n    /**\n     * Raw request with callback.\n     * @param info\n     * @param data\n     * @param onResult\n     */\n    requestRawWithCallback(info, data, onResult) {\n        let socket;\n        if (typeof data === 'string') {\n            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n        }\n        let callbackCalled = false;\n        let handleResult = (err, res) => {\n            if (!callbackCalled) {\n                callbackCalled = true;\n                onResult(err, res);\n            }\n        };\n        let req = info.httpModule.request(info.options, (msg) => {\n            let res = new HttpClientResponse(msg);\n            handleResult(null, res);\n        });\n        req.on('socket', sock => {\n            socket = sock;\n        });\n        // If we ever get disconnected, we want the socket to timeout eventually\n        req.setTimeout(this._socketTimeout || 3 * 60000, () => {\n            if (socket) {\n                socket.end();\n            }\n            handleResult(new Error('Request timeout: ' + info.options.path), null);\n        });\n        req.on('error', function (err) {\n            // err has statusCode property\n            // res should have headers\n            handleResult(err, null);\n        });\n        if (data && typeof data === 'string') {\n            req.write(data, 'utf8');\n        }\n        if (data && typeof data !== 'string') {\n            data.on('close', function () {\n                req.end();\n            });\n            data.pipe(req);\n        }\n        else {\n            req.end();\n        }\n    }\n    /**\n     * Gets an http agent. This function is useful when you need an http agent that handles\n     * routing through a proxy server - depending upon the url and proxy environment variables.\n     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n     */\n    getAgent(serverUrl) {\n        let parsedUrl = new URL(serverUrl);\n        return this._getAgent(parsedUrl);\n    }\n    _prepareRequest(method, requestUrl, headers) {\n        const info = {};\n        info.parsedUrl = requestUrl;\n        const usingSsl = info.parsedUrl.protocol === 'https:';\n        info.httpModule = usingSsl ? https : http;\n        const defaultPort = usingSsl ? 443 : 80;\n        info.options = {};\n        info.options.host = info.parsedUrl.hostname;\n        info.options.port = info.parsedUrl.port\n            ? parseInt(info.parsedUrl.port)\n            : defaultPort;\n        info.options.path =\n            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');\n        info.options.method = method;\n        info.options.headers = this._mergeHeaders(headers);\n        if (this.userAgent != null) {\n            info.options.headers['user-agent'] = this.userAgent;\n        }\n        info.options.agent = this._getAgent(info.parsedUrl);\n        // gives handlers an opportunity to participate\n        if (this.handlers) {\n            this.handlers.forEach(handler => {\n                handler.prepareRequest(info.options);\n            });\n        }\n        return info;\n    }\n    _mergeHeaders(headers) {\n        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n        if (this.requestOptions && this.requestOptions.headers) {\n            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers));\n        }\n        return lowercaseKeys(headers || {});\n    }\n    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {\n        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n        let clientHeader;\n        if (this.requestOptions && this.requestOptions.headers) {\n            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];\n        }\n        return additionalHeaders[header] || clientHeader || _default;\n    }\n    _getAgent(parsedUrl) {\n        let agent;\n        let proxyUrl = pm.getProxyUrl(parsedUrl);\n        let useProxy = proxyUrl && proxyUrl.hostname;\n        if (this._keepAlive && useProxy) {\n            agent = this._proxyAgent;\n        }\n        if (this._keepAlive && !useProxy) {\n            agent = this._agent;\n        }\n        // if agent is already assigned use that agent.\n        if (!!agent) {\n            return agent;\n        }\n        const usingSsl = parsedUrl.protocol === 'https:';\n        let maxSockets = 100;\n        if (!!this.requestOptions) {\n            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;\n        }\n        if (useProxy) {\n            // If using proxy, need tunnel\n            if (!tunnel) {\n                tunnel = require('tunnel');\n            }\n            const agentOptions = {\n                maxSockets: maxSockets,\n                keepAlive: this._keepAlive,\n                proxy: {\n                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`,\n                    host: proxyUrl.hostname,\n                    port: proxyUrl.port\n                }\n            };\n            let tunnelAgent;\n            const overHttps = proxyUrl.protocol === 'https:';\n            if (usingSsl) {\n                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;\n            }\n            else {\n                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;\n            }\n            agent = tunnelAgent(agentOptions);\n            this._proxyAgent = agent;\n        }\n        // if reusing agent across request and tunneling agent isn't assigned create a new agent\n        if (this._keepAlive && !agent) {\n            const options = { keepAlive: this._keepAlive, maxSockets: maxSockets };\n            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);\n            this._agent = agent;\n        }\n        // if not using private agent and tunnel agent isn't setup then use global agent\n        if (!agent) {\n            agent = usingSsl ? https.globalAgent : http.globalAgent;\n        }\n        if (usingSsl && this._ignoreSslError) {\n            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options\n            // we have to cast it to any and change it directly\n            agent.options = Object.assign(agent.options || {}, {\n                rejectUnauthorized: false\n            });\n        }\n        return agent;\n    }\n    _performExponentialBackoff(retryNumber) {\n        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);\n        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);\n        return new Promise(resolve => setTimeout(() => resolve(), ms));\n    }\n    static dateTimeDeserializer(key, value) {\n        if (typeof value === 'string') {\n            let a = new Date(value);\n            if (!isNaN(a.valueOf())) {\n                return a;\n            }\n        }\n        return value;\n    }\n    async _processResponse(res, options) {\n        return new Promise(async (resolve, reject) => {\n            const statusCode = res.message.statusCode;\n            const response = {\n                statusCode: statusCode,\n                result: null,\n                headers: {}\n            };\n            // not found leads to null obj returned\n            if (statusCode == HttpCodes.NotFound) {\n                resolve(response);\n            }\n            let obj;\n            let contents;\n            // get the result from the body\n            try {\n                contents = await res.readBody();\n                if (contents && contents.length > 0) {\n                    if (options && options.deserializeDates) {\n                        obj = JSON.parse(contents, HttpClient.dateTimeDeserializer);\n                    }\n                    else {\n                        obj = JSON.parse(contents);\n                    }\n                    response.result = obj;\n                }\n                response.headers = res.message.headers;\n            }\n            catch (err) {\n                // Invalid resource (contents not json);  leaving result obj null\n            }\n            // note that 3xx redirects are handled by the http layer.\n            if (statusCode > 299) {\n                let msg;\n                // if exception/error in body, attempt to get better error\n                if (obj && obj.message) {\n                    msg = obj.message;\n                }\n                else if (contents && contents.length > 0) {\n                    // it may be the case that the exception is in the body message as string\n                    msg = contents;\n                }\n                else {\n                    msg = 'Failed request: (' + statusCode + ')';\n                }\n                let err = new HttpClientError(msg, statusCode);\n                err.result = response.result;\n                reject(err);\n            }\n            else {\n                resolve(response);\n            }\n        });\n    }\n}\nexports.HttpClient = HttpClient;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getProxyUrl(reqUrl) {\n    let usingSsl = reqUrl.protocol === 'https:';\n    let proxyUrl;\n    if (checkBypass(reqUrl)) {\n        return proxyUrl;\n    }\n    let proxyVar;\n    if (usingSsl) {\n        proxyVar = process.env['https_proxy'] || process.env['HTTPS_PROXY'];\n    }\n    else {\n        proxyVar = process.env['http_proxy'] || process.env['HTTP_PROXY'];\n    }\n    if (proxyVar) {\n        proxyUrl = new URL(proxyVar);\n    }\n    return proxyUrl;\n}\nexports.getProxyUrl = getProxyUrl;\nfunction checkBypass(reqUrl) {\n    if (!reqUrl.hostname) {\n        return false;\n    }\n    let noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';\n    if (!noProxy) {\n        return false;\n    }\n    // Determine the request port\n    let reqPort;\n    if (reqUrl.port) {\n        reqPort = Number(reqUrl.port);\n    }\n    else if (reqUrl.protocol === 'http:') {\n        reqPort = 80;\n    }\n    else if (reqUrl.protocol === 'https:') {\n        reqPort = 443;\n    }\n    // Format the request hostname and hostname with port\n    let upperReqHosts = [reqUrl.hostname.toUpperCase()];\n    if (typeof reqPort === 'number') {\n        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);\n    }\n    // Compare request host against noproxy\n    for (let upperNoProxyItem of noProxy\n        .split(',')\n        .map(x => x.trim().toUpperCase())\n        .filter(x => x)) {\n        if (upperReqHosts.some(x => x === upperNoProxyItem)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.checkBypass = checkBypass;\n","'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n","var concatMap = require('concat-map');\nvar balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n","module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","/* @flow */\n/*::\n\ntype DotenvParseOptions = {\n  debug?: boolean\n}\n\n// keys and values from src\ntype DotenvParseOutput = { [string]: string }\n\ntype DotenvConfigOptions = {\n  path?: string, // path to .env file\n  encoding?: string, // encoding of .env file\n  debug?: string // turn on logging for debugging purposes\n}\n\ntype DotenvConfigOutput = {\n  parsed?: DotenvParseOutput,\n  error?: Error\n}\n\n*/\n\nconst fs = require('fs')\nconst path = require('path')\n\nfunction log (message /*: string */) {\n  console.log(`[dotenv][DEBUG] ${message}`)\n}\n\nconst NEWLINE = '\\n'\nconst RE_INI_KEY_VAL = /^\\s*([\\w.-]+)\\s*=\\s*(.*)?\\s*$/\nconst RE_NEWLINES = /\\\\n/g\nconst NEWLINES_MATCH = /\\n|\\r|\\r\\n/\n\n// Parses src into an Object\nfunction parse (src /*: string | Buffer */, options /*: ?DotenvParseOptions */) /*: DotenvParseOutput */ {\n  const debug = Boolean(options && options.debug)\n  const obj = {}\n\n  // convert Buffers before splitting into lines and processing\n  src.toString().split(NEWLINES_MATCH).forEach(function (line, idx) {\n    // matching \"KEY' and 'VAL' in 'KEY=VAL'\n    const keyValueArr = line.match(RE_INI_KEY_VAL)\n    // matched?\n    if (keyValueArr != null) {\n      const key = keyValueArr[1]\n      // default undefined or missing values to empty string\n      let val = (keyValueArr[2] || '')\n      const end = val.length - 1\n      const isDoubleQuoted = val[0] === '\"' && val[end] === '\"'\n      const isSingleQuoted = val[0] === \"'\" && val[end] === \"'\"\n\n      // if single or double quoted, remove quotes\n      if (isSingleQuoted || isDoubleQuoted) {\n        val = val.substring(1, end)\n\n        // if double quoted, expand newlines\n        if (isDoubleQuoted) {\n          val = val.replace(RE_NEWLINES, NEWLINE)\n        }\n      } else {\n        // remove surrounding whitespace\n        val = val.trim()\n      }\n\n      obj[key] = val\n    } else if (debug) {\n      log(`did not match key and value when parsing line ${idx + 1}: ${line}`)\n    }\n  })\n\n  return obj\n}\n\n// Populates process.env from .env file\nfunction config (options /*: ?DotenvConfigOptions */) /*: DotenvConfigOutput */ {\n  let dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding /*: string */ = 'utf8'\n  let debug = false\n\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = options.path\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding\n    }\n    if (options.debug != null) {\n      debug = true\n    }\n  }\n\n  try {\n    // specifying an encoding returns a string instead of a buffer\n    const parsed = parse(fs.readFileSync(dotenvPath, { encoding }), { debug })\n\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n        process.env[key] = parsed[key]\n      } else if (debug) {\n        log(`\"${key}\" is already defined in \\`process.env\\` and will not be overwritten`)\n      }\n    })\n\n    return { parsed }\n  } catch (e) {\n    return { error: e }\n  }\n}\n\nmodule.exports.config = config\nmodule.exports.parse = parse\n","module.exports = realpath\nrealpath.realpath = realpath\nrealpath.sync = realpathSync\nrealpath.realpathSync = realpathSync\nrealpath.monkeypatch = monkeypatch\nrealpath.unmonkeypatch = unmonkeypatch\n\nvar fs = require('fs')\nvar origRealpath = fs.realpath\nvar origRealpathSync = fs.realpathSync\n\nvar version = process.version\nvar ok = /^v[0-5]\\./.test(version)\nvar old = require('./old.js')\n\nfunction newError (er) {\n  return er && er.syscall === 'realpath' && (\n    er.code === 'ELOOP' ||\n    er.code === 'ENOMEM' ||\n    er.code === 'ENAMETOOLONG'\n  )\n}\n\nfunction realpath (p, cache, cb) {\n  if (ok) {\n    return origRealpath(p, cache, cb)\n  }\n\n  if (typeof cache === 'function') {\n    cb = cache\n    cache = null\n  }\n  origRealpath(p, cache, function (er, result) {\n    if (newError(er)) {\n      old.realpath(p, cache, cb)\n    } else {\n      cb(er, result)\n    }\n  })\n}\n\nfunction realpathSync (p, cache) {\n  if (ok) {\n    return origRealpathSync(p, cache)\n  }\n\n  try {\n    return origRealpathSync(p, cache)\n  } catch (er) {\n    if (newError(er)) {\n      return old.realpathSync(p, cache)\n    } else {\n      throw er\n    }\n  }\n}\n\nfunction monkeypatch () {\n  fs.realpath = realpath\n  fs.realpathSync = realpathSync\n}\n\nfunction unmonkeypatch () {\n  fs.realpath = origRealpath\n  fs.realpathSync = origRealpathSync\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar pathModule = require('path');\nvar isWindows = process.platform === 'win32';\nvar fs = require('fs');\n\n// JavaScript implementation of realpath, ported from node pre-v6\n\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\n\nfunction rethrow() {\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  var callback;\n  if (DEBUG) {\n    var backtrace = new Error;\n    callback = debugCallback;\n  } else\n    callback = missingCallback;\n\n  return callback;\n\n  function debugCallback(err) {\n    if (err) {\n      backtrace.message = err.message;\n      err = backtrace;\n      missingCallback(err);\n    }\n  }\n\n  function missingCallback(err) {\n    if (err) {\n      if (process.throwDeprecation)\n        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n      else if (!process.noDeprecation) {\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\n        if (process.traceDeprecation)\n          console.trace(msg);\n        else\n          console.error(msg);\n      }\n    }\n  }\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\nvar normalize = pathModule.normalize;\n\n// Regexp that finds the next partion of a (partial) path\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\nif (isWindows) {\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n} else {\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n}\n\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\nif (isWindows) {\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n} else {\n  var splitRootRe = /^[\\/]*/;\n}\n\nexports.realpathSync = function realpathSync(p, cache) {\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstatSync(base);\n      knownHard[base] = true;\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      continue;\n    }\n\n    var resolvedLink;\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs.lstatSync(base);\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        fs.statSync(base);\n        linkTarget = fs.readlinkSync(base);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n      // track this, if given a cache.\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n\n  if (cache) cache[original] = p;\n\n  return p;\n};\n\n\nexports.realpath = function realpath(p, cache, cb) {\n  if (typeof cb !== 'function') {\n    cb = maybeCallback(cache);\n    cache = null;\n  }\n\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function(err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    }\n\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      return process.nextTick(LOOP);\n    }\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err, stat) {\n    if (err) return cb(err);\n\n    // if not a symlink, skip to the next path part\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function(err) {\n      if (err) return cb(err);\n\n      fs.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n\n    var resolvedLink = pathModule.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n};\n","exports.alphasort = alphasort\nexports.alphasorti = alphasorti\nexports.setopts = setopts\nexports.ownProp = ownProp\nexports.makeAbs = makeAbs\nexports.finish = finish\nexports.mark = mark\nexports.isIgnored = isIgnored\nexports.childrenIgnored = childrenIgnored\n\nfunction ownProp (obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field)\n}\n\nvar path = require(\"path\")\nvar minimatch = require(\"minimatch\")\nvar isAbsolute = require(\"path-is-absolute\")\nvar Minimatch = minimatch.Minimatch\n\nfunction alphasorti (a, b) {\n  return a.toLowerCase().localeCompare(b.toLowerCase())\n}\n\nfunction alphasort (a, b) {\n  return a.localeCompare(b)\n}\n\nfunction setupIgnores (self, options) {\n  self.ignore = options.ignore || []\n\n  if (!Array.isArray(self.ignore))\n    self.ignore = [self.ignore]\n\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap)\n  }\n}\n\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap (pattern) {\n  var gmatcher = null\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '')\n    gmatcher = new Minimatch(gpattern, { dot: true })\n  }\n\n  return {\n    matcher: new Minimatch(pattern, { dot: true }),\n    gmatcher: gmatcher\n  }\n}\n\nfunction setopts (self, pattern, options) {\n  if (!options)\n    options = {}\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern\n  }\n\n  self.silent = !!options.silent\n  self.pattern = pattern\n  self.strict = options.strict !== false\n  self.realpath = !!options.realpath\n  self.realpathCache = options.realpathCache || Object.create(null)\n  self.follow = !!options.follow\n  self.dot = !!options.dot\n  self.mark = !!options.mark\n  self.nodir = !!options.nodir\n  if (self.nodir)\n    self.mark = true\n  self.sync = !!options.sync\n  self.nounique = !!options.nounique\n  self.nonull = !!options.nonull\n  self.nosort = !!options.nosort\n  self.nocase = !!options.nocase\n  self.stat = !!options.stat\n  self.noprocess = !!options.noprocess\n  self.absolute = !!options.absolute\n\n  self.maxLength = options.maxLength || Infinity\n  self.cache = options.cache || Object.create(null)\n  self.statCache = options.statCache || Object.create(null)\n  self.symlinks = options.symlinks || Object.create(null)\n\n  setupIgnores(self, options)\n\n  self.changedCwd = false\n  var cwd = process.cwd()\n  if (!ownProp(options, \"cwd\"))\n    self.cwd = cwd\n  else {\n    self.cwd = path.resolve(options.cwd)\n    self.changedCwd = self.cwd !== cwd\n  }\n\n  self.root = options.root || path.resolve(self.cwd, \"/\")\n  self.root = path.resolve(self.root)\n  if (process.platform === \"win32\")\n    self.root = self.root.replace(/\\\\/g, \"/\")\n\n  // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)\n  if (process.platform === \"win32\")\n    self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\")\n  self.nomount = !!options.nomount\n\n  // disable comments and negation in Minimatch.\n  // Note that they are not supported in Glob itself anyway.\n  options.nonegate = true\n  options.nocomment = true\n\n  self.minimatch = new Minimatch(pattern, options)\n  self.options = self.minimatch.options\n}\n\nfunction finish (self) {\n  var nou = self.nounique\n  var all = nou ? [] : Object.create(null)\n\n  for (var i = 0, l = self.matches.length; i < l; i ++) {\n    var matches = self.matches[i]\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i]\n        if (nou)\n          all.push(literal)\n        else\n          all[literal] = true\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches)\n      if (nou)\n        all.push.apply(all, m)\n      else\n        m.forEach(function (m) {\n          all[m] = true\n        })\n    }\n  }\n\n  if (!nou)\n    all = Object.keys(all)\n\n  if (!self.nosort)\n    all = all.sort(self.nocase ? alphasorti : alphasort)\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i])\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        var notDir = !(/\\/$/.test(e))\n        var c = self.cache[e] || self.cache[makeAbs(self, e)]\n        if (notDir && c)\n          notDir = c !== 'DIR' && !Array.isArray(c)\n        return notDir\n      })\n    }\n  }\n\n  if (self.ignore.length)\n    all = all.filter(function(m) {\n      return !isIgnored(self, m)\n    })\n\n  self.found = all\n}\n\nfunction mark (self, p) {\n  var abs = makeAbs(self, p)\n  var c = self.cache[abs]\n  var m = p\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c)\n    var slash = p.slice(-1) === '/'\n\n    if (isDir && !slash)\n      m += '/'\n    else if (!isDir && slash)\n      m = m.slice(0, -1)\n\n    if (m !== p) {\n      var mabs = makeAbs(self, m)\n      self.statCache[mabs] = self.statCache[abs]\n      self.cache[mabs] = self.cache[abs]\n    }\n  }\n\n  return m\n}\n\n// lotta situps...\nfunction makeAbs (self, f) {\n  var abs = f\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f)\n  } else if (isAbsolute(f) || f === '') {\n    abs = f\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f)\n  } else {\n    abs = path.resolve(f)\n  }\n\n  if (process.platform === 'win32')\n    abs = abs.replace(/\\\\/g, '/')\n\n  return abs\n}\n\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\nfunction childrenIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n","// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nmodule.exports = glob\n\nvar fs = require('fs')\nvar rp = require('fs.realpath')\nvar minimatch = require('minimatch')\nvar Minimatch = minimatch.Minimatch\nvar inherits = require('inherits')\nvar EE = require('events').EventEmitter\nvar path = require('path')\nvar assert = require('assert')\nvar isAbsolute = require('path-is-absolute')\nvar globSync = require('./sync.js')\nvar common = require('./common.js')\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar inflight = require('inflight')\nvar util = require('util')\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nvar once = require('once')\n\nfunction glob (pattern, options, cb) {\n  if (typeof options === 'function') cb = options, options = {}\n  if (!options) options = {}\n\n  if (options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return globSync(pattern, options)\n  }\n\n  return new Glob(pattern, options, cb)\n}\n\nglob.sync = globSync\nvar GlobSync = glob.GlobSync = globSync.GlobSync\n\n// old api surface\nglob.glob = glob\n\nfunction extend (origin, add) {\n  if (add === null || typeof add !== 'object') {\n    return origin\n  }\n\n  var keys = Object.keys(add)\n  var i = keys.length\n  while (i--) {\n    origin[keys[i]] = add[keys[i]]\n  }\n  return origin\n}\n\nglob.hasMagic = function (pattern, options_) {\n  var options = extend({}, options_)\n  options.noprocess = true\n\n  var g = new Glob(pattern, options)\n  var set = g.minimatch.set\n\n  if (!pattern)\n    return false\n\n  if (set.length > 1)\n    return true\n\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string')\n      return true\n  }\n\n  return false\n}\n\nglob.Glob = Glob\ninherits(Glob, EE)\nfunction Glob (pattern, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = null\n  }\n\n  if (options && options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return new GlobSync(pattern, options)\n  }\n\n  if (!(this instanceof Glob))\n    return new Glob(pattern, options, cb)\n\n  setopts(this, pattern, options)\n  this._didRealPath = false\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n)\n\n  if (typeof cb === 'function') {\n    cb = once(cb)\n    this.on('error', cb)\n    this.on('end', function (matches) {\n      cb(null, matches)\n    })\n  }\n\n  var self = this\n  this._processing = 0\n\n  this._emitQueue = []\n  this._processQueue = []\n  this.paused = false\n\n  if (this.noprocess)\n    return this\n\n  if (n === 0)\n    return done()\n\n  var sync = true\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false, done)\n  }\n  sync = false\n\n  function done () {\n    --self._processing\n    if (self._processing <= 0) {\n      if (sync) {\n        process.nextTick(function () {\n          self._finish()\n        })\n      } else {\n        self._finish()\n      }\n    }\n  }\n}\n\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob)\n  if (this.aborted)\n    return\n\n  if (this.realpath && !this._didRealpath)\n    return this._realpath()\n\n  common.finish(this)\n  this.emit('end', this.found)\n}\n\nGlob.prototype._realpath = function () {\n  if (this._didRealpath)\n    return\n\n  this._didRealpath = true\n\n  var n = this.matches.length\n  if (n === 0)\n    return this._finish()\n\n  var self = this\n  for (var i = 0; i < this.matches.length; i++)\n    this._realpathSet(i, next)\n\n  function next () {\n    if (--n === 0)\n      self._finish()\n  }\n}\n\nGlob.prototype._realpathSet = function (index, cb) {\n  var matchset = this.matches[index]\n  if (!matchset)\n    return cb()\n\n  var found = Object.keys(matchset)\n  var self = this\n  var n = found.length\n\n  if (n === 0)\n    return cb()\n\n  var set = this.matches[index] = Object.create(null)\n  found.forEach(function (p, i) {\n    // If there's a problem with the stat, then it means that\n    // one or more of the links in the realpath couldn't be\n    // resolved.  just return the abs value in that case.\n    p = self._makeAbs(p)\n    rp.realpath(p, self.realpathCache, function (er, real) {\n      if (!er)\n        set[real] = true\n      else if (er.syscall === 'stat')\n        set[p] = true\n      else\n        self.emit('error', er) // srsly wtf right here\n\n      if (--n === 0) {\n        self.matches[index] = set\n        cb()\n      }\n    })\n  })\n}\n\nGlob.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlob.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\nGlob.prototype.abort = function () {\n  this.aborted = true\n  this.emit('abort')\n}\n\nGlob.prototype.pause = function () {\n  if (!this.paused) {\n    this.paused = true\n    this.emit('pause')\n  }\n}\n\nGlob.prototype.resume = function () {\n  if (this.paused) {\n    this.emit('resume')\n    this.paused = false\n    if (this._emitQueue.length) {\n      var eq = this._emitQueue.slice(0)\n      this._emitQueue.length = 0\n      for (var i = 0; i < eq.length; i ++) {\n        var e = eq[i]\n        this._emitMatch(e[0], e[1])\n      }\n    }\n    if (this._processQueue.length) {\n      var pq = this._processQueue.slice(0)\n      this._processQueue.length = 0\n      for (var i = 0; i < pq.length; i ++) {\n        var p = pq[i]\n        this._processing--\n        this._process(p[0], p[1], p[2], p[3])\n      }\n    }\n  }\n}\n\nGlob.prototype._process = function (pattern, index, inGlobStar, cb) {\n  assert(this instanceof Glob)\n  assert(typeof cb === 'function')\n\n  if (this.aborted)\n    return\n\n  this._processing++\n  if (this.paused) {\n    this._processQueue.push([pattern, index, inGlobStar, cb])\n    return\n  }\n\n  //console.error('PROCESS %d', this._processing, pattern)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index, cb)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip _processing\n  if (childrenIgnored(this, read))\n    return cb()\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)\n}\n\nGlob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\nGlob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return cb()\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return cb()\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return cb()\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix) {\n      if (prefix !== '/')\n        e = prefix + '/' + e\n      else\n        e = prefix + e\n    }\n    this._process([e].concat(remain), index, inGlobStar, cb)\n  }\n  cb()\n}\n\nGlob.prototype._emitMatch = function (index, e) {\n  if (this.aborted)\n    return\n\n  if (isIgnored(this, e))\n    return\n\n  if (this.paused) {\n    this._emitQueue.push([index, e])\n    return\n  }\n\n  var abs = isAbsolute(e) ? e : this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute)\n    e = abs\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  var st = this.statCache[abs]\n  if (st)\n    this.emit('stat', e, st)\n\n  this.emit('match', e)\n}\n\nGlob.prototype._readdirInGlobStar = function (abs, cb) {\n  if (this.aborted)\n    return\n\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false, cb)\n\n  var lstatkey = 'lstat\\0' + abs\n  var self = this\n  var lstatcb = inflight(lstatkey, lstatcb_)\n\n  if (lstatcb)\n    fs.lstat(abs, lstatcb)\n\n  function lstatcb_ (er, lstat) {\n    if (er && er.code === 'ENOENT')\n      return cb()\n\n    var isSym = lstat && lstat.isSymbolicLink()\n    self.symlinks[abs] = isSym\n\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && lstat && !lstat.isDirectory()) {\n      self.cache[abs] = 'FILE'\n      cb()\n    } else\n      self._readdir(abs, false, cb)\n  }\n}\n\nGlob.prototype._readdir = function (abs, inGlobStar, cb) {\n  if (this.aborted)\n    return\n\n  cb = inflight('readdir\\0'+abs+'\\0'+inGlobStar, cb)\n  if (!cb)\n    return\n\n  //console.error('RD %j %j', +inGlobStar, abs)\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs, cb)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return cb()\n\n    if (Array.isArray(c))\n      return cb(null, c)\n  }\n\n  var self = this\n  fs.readdir(abs, readdirCb(this, abs, cb))\n}\n\nfunction readdirCb (self, abs, cb) {\n  return function (er, entries) {\n    if (er)\n      self._readdirError(abs, er, cb)\n    else\n      self._readdirEntries(abs, entries, cb)\n  }\n}\n\nGlob.prototype._readdirEntries = function (abs, entries, cb) {\n  if (this.aborted)\n    return\n\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n  return cb(null, entries)\n}\n\nGlob.prototype._readdirError = function (f, er, cb) {\n  if (this.aborted)\n    return\n\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        this.emit('error', error)\n        this.abort()\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict) {\n        this.emit('error', er)\n        // If the error is handled, then we abort\n        // if not, we threw out of here\n        this.abort()\n      }\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n\n  return cb()\n}\n\nGlob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\n\nGlob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  //console.error('pgs2', prefix, remain[0], entries)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return cb()\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false, cb)\n\n  var isSym = this.symlinks[abs]\n  var len = entries.length\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return cb()\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true, cb)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true, cb)\n  }\n\n  cb()\n}\n\nGlob.prototype._processSimple = function (prefix, index, cb) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var self = this\n  this._stat(prefix, function (er, exists) {\n    self._processSimple2(prefix, index, er, exists, cb)\n  })\n}\nGlob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n\n  //console.error('ps2', prefix, exists)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return cb()\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n  cb()\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlob.prototype._stat = function (f, cb) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return cb()\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return cb(null, c)\n\n    if (needDir && c === 'FILE')\n      return cb()\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (stat !== undefined) {\n    if (stat === false)\n      return cb(null, stat)\n    else {\n      var type = stat.isDirectory() ? 'DIR' : 'FILE'\n      if (needDir && type === 'FILE')\n        return cb()\n      else\n        return cb(null, type, stat)\n    }\n  }\n\n  var self = this\n  var statcb = inflight('stat\\0' + abs, lstatcb_)\n  if (statcb)\n    fs.lstat(abs, statcb)\n\n  function lstatcb_ (er, lstat) {\n    if (lstat && lstat.isSymbolicLink()) {\n      // If it's a symlink, then treat it as the target, unless\n      // the target does not exist, then treat it as a file.\n      return fs.stat(abs, function (er, stat) {\n        if (er)\n          self._stat2(f, abs, null, lstat, cb)\n        else\n          self._stat2(f, abs, er, stat, cb)\n      })\n    } else {\n      self._stat2(f, abs, er, lstat, cb)\n    }\n  }\n}\n\nGlob.prototype._stat2 = function (f, abs, er, stat, cb) {\n  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n    this.statCache[abs] = false\n    return cb()\n  }\n\n  var needDir = f.slice(-1) === '/'\n  this.statCache[abs] = stat\n\n  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())\n    return cb(null, false, stat)\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return cb()\n\n  return cb(null, c, stat)\n}\n","module.exports = globSync\nglobSync.GlobSync = GlobSync\n\nvar fs = require('fs')\nvar rp = require('fs.realpath')\nvar minimatch = require('minimatch')\nvar Minimatch = minimatch.Minimatch\nvar Glob = require('./glob.js').Glob\nvar util = require('util')\nvar path = require('path')\nvar assert = require('assert')\nvar isAbsolute = require('path-is-absolute')\nvar common = require('./common.js')\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nfunction globSync (pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  return new GlobSync(pattern, options).found\n}\n\nfunction GlobSync (pattern, options) {\n  if (!pattern)\n    throw new Error('must provide pattern')\n\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  if (!(this instanceof GlobSync))\n    return new GlobSync(pattern, options)\n\n  setopts(this, pattern, options)\n\n  if (this.noprocess)\n    return this\n\n  var n = this.minimatch.set.length\n  this.matches = new Array(n)\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false)\n  }\n  this._finish()\n}\n\nGlobSync.prototype._finish = function () {\n  assert(this instanceof GlobSync)\n  if (this.realpath) {\n    var self = this\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null)\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p)\n          var real = rp.realpathSync(p, self.realpathCache)\n          set[real] = true\n        } catch (er) {\n          if (er.syscall === 'stat')\n            set[self._makeAbs(p)] = true\n          else\n            throw er\n        }\n      }\n    })\n  }\n  common.finish(this)\n}\n\n\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert(this instanceof GlobSync)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // See if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip processing\n  if (childrenIgnored(this, read))\n    return\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)\n}\n\n\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar)\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix.slice(-1) !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix)\n      newPattern = [prefix, e]\n    else\n      newPattern = [e]\n    this._process(newPattern.concat(remain), index, inGlobStar)\n  }\n}\n\n\nGlobSync.prototype._emitMatch = function (index, e) {\n  if (isIgnored(this, e))\n    return\n\n  var abs = this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute) {\n    e = abs\n  }\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  if (this.stat)\n    this._stat(e)\n}\n\n\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false)\n\n  var entries\n  var lstat\n  var stat\n  try {\n    lstat = fs.lstatSync(abs)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      // lstat failed, doesn't exist\n      return null\n    }\n  }\n\n  var isSym = lstat && lstat.isSymbolicLink()\n  this.symlinks[abs] = isSym\n\n  // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n  if (!isSym && lstat && !lstat.isDirectory())\n    this.cache[abs] = 'FILE'\n  else\n    entries = this._readdir(abs, false)\n\n  return entries\n}\n\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n  var entries\n\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return null\n\n    if (Array.isArray(c))\n      return c\n  }\n\n  try {\n    return this._readdirEntries(abs, fs.readdirSync(abs))\n  } catch (er) {\n    this._readdirError(abs, er)\n    return null\n  }\n}\n\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n\n  // mark and cache dir-ness\n  return entries\n}\n\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        throw error\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict)\n        throw er\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n}\n\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n\n  var entries = this._readdir(abs, inGlobStar)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false)\n\n  var len = entries.length\n  var isSym = this.symlinks[abs]\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true)\n  }\n}\n\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return false\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return c\n\n    if (needDir && c === 'FILE')\n      return false\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (!stat) {\n    var lstat\n    try {\n      lstat = fs.lstatSync(abs)\n    } catch (er) {\n      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n        this.statCache[abs] = false\n        return false\n      }\n    }\n\n    if (lstat && lstat.isSymbolicLink()) {\n      try {\n        stat = fs.statSync(abs)\n      } catch (er) {\n        stat = lstat\n      }\n    } else {\n      stat = lstat\n    }\n  }\n\n  this.statCache[abs] = stat\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return false\n\n  return c\n}\n\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n","var wrappy = require('wrappy')\nvar reqs = Object.create(null)\nvar once = require('once')\n\nmodule.exports = wrappy(inflight)\n\nfunction inflight (key, cb) {\n  if (reqs[key]) {\n    reqs[key].push(cb)\n    return null\n  } else {\n    reqs[key] = [cb]\n    return makeres(key)\n  }\n}\n\nfunction makeres (key) {\n  return once(function RES () {\n    var cbs = reqs[key]\n    var len = cbs.length\n    var args = slice(arguments)\n\n    // XXX It's somewhat ambiguous whether a new callback added in this\n    // pass should be queued for later execution if something in the\n    // list of callbacks throws, or if it should just be discarded.\n    // However, it's such an edge case that it hardly matters, and either\n    // choice is likely as surprising as the other.\n    // As it happens, we do go ahead and schedule it for later execution.\n    try {\n      for (var i = 0; i < len; i++) {\n        cbs[i].apply(null, args)\n      }\n    } finally {\n      if (cbs.length > len) {\n        // added more in the interim.\n        // de-zalgo, just in case, but don't call again.\n        cbs.splice(0, len)\n        process.nextTick(function () {\n          RES.apply(null, args)\n        })\n      } else {\n        delete reqs[key]\n      }\n    }\n  })\n}\n\nfunction slice (args) {\n  var length = args.length\n  var array = []\n\n  for (var i = 0; i < length; i++) array[i] = args[i]\n  return array\n}\n","try {\n  var util = require('util');\n  /* istanbul ignore next */\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  /* istanbul ignore next */\n  module.exports = require('./inherits_browser.js');\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = require('path')\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = require('brace-expansion')\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","'use strict';\n\nfunction posix(path) {\n\treturn path.charAt(0) === '/';\n}\n\nfunction win32(path) {\n\t// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56\n\tvar splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n\tvar result = splitDeviceRe.exec(path);\n\tvar device = result[1] || '';\n\tvar isUnc = Boolean(device && device.charAt(1) !== ':');\n\n\t// UNC paths are always absolute\n\treturn Boolean(result[2] || isUnc);\n}\n\nmodule.exports = process.platform === 'win32' ? win32 : posix;\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;\n","module.exports = rimraf\nrimraf.sync = rimrafSync\n\nvar assert = require(\"assert\")\nvar path = require(\"path\")\nvar fs = require(\"fs\")\nvar glob = require(\"glob\")\nvar _0666 = parseInt('666', 8)\n\nvar defaultGlobOpts = {\n  nosort: true,\n  silent: true\n}\n\n// for EMFILE handling\nvar timeout = 0\n\nvar isWindows = (process.platform === \"win32\")\n\nfunction defaults (options) {\n  var methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(function(m) {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n  options.emfileWait = options.emfileWait || 1000\n  if (options.glob === false) {\n    options.disableGlob = true\n  }\n  options.disableGlob = options.disableGlob || false\n  options.glob = options.glob || defaultGlobOpts\n}\n\nfunction rimraf (p, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert.equal(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  var busyTries = 0\n  var errState = null\n  var n = 0\n\n  if (options.disableGlob || !glob.hasMagic(p))\n    return afterGlob(null, [p])\n\n  options.lstat(p, function (er, stat) {\n    if (!er)\n      return afterGlob(null, [p])\n\n    glob(p, options.glob, afterGlob)\n  })\n\n  function next (er) {\n    errState = errState || er\n    if (--n === 0)\n      cb(errState)\n  }\n\n  function afterGlob (er, results) {\n    if (er)\n      return cb(er)\n\n    n = results.length\n    if (n === 0)\n      return cb()\n\n    results.forEach(function (p) {\n      rimraf_(p, options, function CB (er) {\n        if (er) {\n          if ((er.code === \"EBUSY\" || er.code === \"ENOTEMPTY\" || er.code === \"EPERM\") &&\n              busyTries < options.maxBusyTries) {\n            busyTries ++\n            var time = busyTries * 100\n            // try again, with the same exact callback as this one.\n            return setTimeout(function () {\n              rimraf_(p, options, CB)\n            }, time)\n          }\n\n          // this one won't happen if graceful-fs is used.\n          if (er.code === \"EMFILE\" && timeout < options.emfileWait) {\n            return setTimeout(function () {\n              rimraf_(p, options, CB)\n            }, timeout ++)\n          }\n\n          // already gone\n          if (er.code === \"ENOENT\") er = null\n        }\n\n        timeout = 0\n        next(er)\n      })\n    })\n  }\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, function (er, st) {\n    if (er && er.code === \"ENOENT\")\n      return cb(null)\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === \"EPERM\" && isWindows)\n      fixWinEPERM(p, options, er, cb)\n\n    if (st && st.isDirectory())\n      return rmdir(p, options, er, cb)\n\n    options.unlink(p, function (er) {\n      if (er) {\n        if (er.code === \"ENOENT\")\n          return cb(null)\n        if (er.code === \"EPERM\")\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        if (er.code === \"EISDIR\")\n          return rmdir(p, options, er, cb)\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n  if (er)\n    assert(er instanceof Error)\n\n  options.chmod(p, _0666, function (er2) {\n    if (er2)\n      cb(er2.code === \"ENOENT\" ? null : er)\n    else\n      options.stat(p, function(er3, stats) {\n        if (er3)\n          cb(er3.code === \"ENOENT\" ? null : er)\n        else if (stats.isDirectory())\n          rmdir(p, options, er, cb)\n        else\n          options.unlink(p, cb)\n      })\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  assert(p)\n  assert(options)\n  if (er)\n    assert(er instanceof Error)\n\n  try {\n    options.chmodSync(p, _0666)\n  } catch (er2) {\n    if (er2.code === \"ENOENT\")\n      return\n    else\n      throw er\n  }\n\n  try {\n    var stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === \"ENOENT\")\n      return\n    else\n      throw er\n  }\n\n  if (stats.isDirectory())\n    rmdirSync(p, options, er)\n  else\n    options.unlinkSync(p)\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  if (originalEr)\n    assert(originalEr instanceof Error)\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, function (er) {\n    if (er && (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\"))\n      rmkids(p, options, cb)\n    else if (er && er.code === \"ENOTDIR\")\n      cb(originalEr)\n    else\n      cb(er)\n  })\n}\n\nfunction rmkids(p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, function (er, files) {\n    if (er)\n      return cb(er)\n    var n = files.length\n    if (n === 0)\n      return options.rmdir(p, cb)\n    var errState\n    files.forEach(function (f) {\n      rimraf(path.join(p, f), options, function (er) {\n        if (errState)\n          return\n        if (er)\n          return cb(errState = er)\n        if (--n === 0)\n          options.rmdir(p, cb)\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n\n  var results\n\n  if (options.disableGlob || !glob.hasMagic(p)) {\n    results = [p]\n  } else {\n    try {\n      options.lstatSync(p)\n      results = [p]\n    } catch (er) {\n      results = glob.sync(p, options.glob)\n    }\n  }\n\n  if (!results.length)\n    return\n\n  for (var i = 0; i < results.length; i++) {\n    var p = results[i]\n\n    try {\n      var st = options.lstatSync(p)\n    } catch (er) {\n      if (er.code === \"ENOENT\")\n        return\n\n      // Windows can EPERM on stat.  Life is suffering.\n      if (er.code === \"EPERM\" && isWindows)\n        fixWinEPERMSync(p, options, er)\n    }\n\n    try {\n      // sunos lets the root user unlink directories, which is... weird.\n      if (st && st.isDirectory())\n        rmdirSync(p, options, null)\n      else\n        options.unlinkSync(p)\n    } catch (er) {\n      if (er.code === \"ENOENT\")\n        return\n      if (er.code === \"EPERM\")\n        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n      if (er.code !== \"EISDIR\")\n        throw er\n\n      rmdirSync(p, options, er)\n    }\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n  if (originalEr)\n    assert(originalEr instanceof Error)\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === \"ENOENT\")\n      return\n    if (er.code === \"ENOTDIR\")\n      throw originalEr\n    if (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\")\n      rmkidsSync(p, options)\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(function (f) {\n    rimrafSync(path.join(p, f), options)\n  })\n\n  // We only end up here once we got ENOTEMPTY at least once, and\n  // at this point, we are guaranteed to have removed all the kids.\n  // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n  // try really hard to delete stuff on windows, because it has a\n  // PROFOUNDLY annoying habit of not closing handles promptly when\n  // files are deleted, resulting in spurious ENOTEMPTY errors.\n  var retries = isWindows ? 100 : 1\n  var i = 0\n  do {\n    var threw = true\n    try {\n      var ret = options.rmdirSync(p, options)\n      threw = false\n      return ret\n    } finally {\n      if (++i < retries && threw)\n        continue\n    }\n  } while (true)\n}\n","const {promisify} = require(\"util\");\r\nconst tmp = require(\"tmp\");\r\n\r\n// file\r\nmodule.exports.fileSync = tmp.fileSync;\r\nconst fileWithOptions = promisify((options, cb) =>\r\n  tmp.file(options, (err, path, fd, cleanup) =>\r\n    err ? cb(err) : cb(undefined, { path, fd, cleanup: promisify(cleanup) })\r\n  )\r\n);\r\nmodule.exports.file = async (options) => fileWithOptions(options);\r\n\r\nmodule.exports.withFile = async function withFile(fn, options) {\r\n  const { path, fd, cleanup } = await module.exports.file(options);\r\n  try {\r\n    return await fn({ path, fd });\r\n  } finally {\r\n    await cleanup();\r\n  }\r\n};\r\n\r\n\r\n// directory\r\nmodule.exports.dirSync = tmp.dirSync;\r\nconst dirWithOptions = promisify((options, cb) =>\r\n  tmp.dir(options, (err, path, cleanup) =>\r\n    err ? cb(err) : cb(undefined, { path, cleanup: promisify(cleanup) })\r\n  )\r\n);\r\nmodule.exports.dir = async (options) => dirWithOptions(options);\r\n\r\nmodule.exports.withDir = async function withDir(fn, options) {\r\n  const { path, cleanup } = await module.exports.dir(options);\r\n  try {\r\n    return await fn({ path });\r\n  } finally {\r\n    await cleanup();\r\n  }\r\n};\r\n\r\n\r\n// name generation\r\nmodule.exports.tmpNameSync = tmp.tmpNameSync;\r\nmodule.exports.tmpName = promisify(tmp.tmpName);\r\n\r\nmodule.exports.tmpdir = tmp.tmpdir;\r\n\r\nmodule.exports.setGracefulCleanup = tmp.setGracefulCleanup;\r\n","/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/*\n * Module dependencies.\n */\nconst fs = require('fs');\nconst os = require('os');\nconst path = require('path');\nconst crypto = require('crypto');\nconst _c = fs.constants && os.constants ?\n  { fs: fs.constants, os: os.constants } :\n  process.binding('constants');\nconst rimraf = require('rimraf');\n\n/*\n * The working inner variables.\n */\nconst\n  // the random characters to choose from\n  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n\n  TEMPLATE_PATTERN = /XXXXXX/,\n\n  DEFAULT_TRIES = 3,\n\n  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),\n\n  EBADF = _c.EBADF || _c.os.errno.EBADF,\n  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,\n\n  DIR_MODE = 448 /* 0o700 */,\n  FILE_MODE = 384 /* 0o600 */,\n\n  EXIT = 'exit',\n\n  SIGINT = 'SIGINT',\n\n  // this will hold the objects need to be removed on exit\n  _removeObjects = [];\n\nvar\n  _gracefulCleanup = false;\n\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */\nfunction _randomChars(howMany) {\n  var\n    value = [],\n    rnd = null;\n\n  // make sure that we do not fail because we ran out of entropy\n  try {\n    rnd = crypto.randomBytes(howMany);\n  } catch (e) {\n    rnd = crypto.pseudoRandomBytes(howMany);\n  }\n\n  for (var i = 0; i < howMany; i++) {\n    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n  }\n\n  return value.join('');\n}\n\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|Function)} options\n * @param {Function} callback\n * @returns {Array} parsed arguments\n * @private\n */\nfunction _parseArguments(options, callback) {\n  /* istanbul ignore else */\n  if (typeof options === 'function') {\n    return [{}, options];\n  }\n\n  /* istanbul ignore else */\n  if (_isUndefined(options)) {\n    return [{}, callback];\n  }\n\n  return [options, callback];\n}\n\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */\nfunction _generateTmpName(opts) {\n\n  const tmpDir = _getTmpDir();\n\n  // fail early on missing tmp dir\n  if (isBlank(opts.dir) && isBlank(tmpDir)) {\n    throw new Error('No tmp dir specified');\n  }\n\n  /* istanbul ignore else */\n  if (!isBlank(opts.name)) {\n    return path.join(opts.dir || tmpDir, opts.name);\n  }\n\n  // mkstemps like template\n  // opts.template has already been guarded in tmpName() below\n  /* istanbul ignore else */\n  if (opts.template) {\n    var template = opts.template;\n    // make sure that we prepend the tmp path if none was given\n    /* istanbul ignore else */\n    if (path.basename(template) === template)\n      template = path.join(opts.dir || tmpDir, template);\n    return template.replace(TEMPLATE_PATTERN, _randomChars(6));\n  }\n\n  // prefix and postfix\n  const name = [\n    (isBlank(opts.prefix) ? 'tmp-' : opts.prefix),\n    process.pid,\n    _randomChars(12),\n    (opts.postfix ? opts.postfix : '')\n  ].join('');\n\n  return path.join(opts.dir || tmpDir, name);\n}\n\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */\nfunction tmpName(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1],\n    tries = !isBlank(opts.name) ? 1 : opts.tries || DEFAULT_TRIES;\n\n  /* istanbul ignore else */\n  if (isNaN(tries) || tries < 0)\n    return cb(new Error('Invalid tries'));\n\n  /* istanbul ignore else */\n  if (opts.template && !opts.template.match(TEMPLATE_PATTERN))\n    return cb(new Error('Invalid template provided'));\n\n  (function _getUniqueName() {\n    try {\n      const name = _generateTmpName(opts);\n\n      // check whether the path exists then retry if needed\n      fs.stat(name, function (err) {\n        /* istanbul ignore else */\n        if (!err) {\n          /* istanbul ignore else */\n          if (tries-- > 0) return _getUniqueName();\n\n          return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));\n        }\n\n        cb(null, name);\n      });\n    } catch (err) {\n      cb(err);\n    }\n  }());\n}\n\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */\nfunction tmpNameSync(options) {\n  var\n    args = _parseArguments(options),\n    opts = args[0],\n    tries = !isBlank(opts.name) ? 1 : opts.tries || DEFAULT_TRIES;\n\n  /* istanbul ignore else */\n  if (isNaN(tries) || tries < 0)\n    throw new Error('Invalid tries');\n\n  /* istanbul ignore else */\n  if (opts.template && !opts.template.match(TEMPLATE_PATTERN))\n    throw new Error('Invalid template provided');\n\n  do {\n    const name = _generateTmpName(opts);\n    try {\n      fs.statSync(name);\n    } catch (e) {\n      return name;\n    }\n  } while (tries-- > 0);\n\n  throw new Error('Could not get a unique tmp filename, max tries reached');\n}\n\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|fileCallback)} options the config options or the callback function\n * @param {?fileCallback} callback\n */\nfunction file(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create and open the file\n    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n      /* istanbul ignore else */\n      if (err) return cb(err);\n\n      if (opts.discardDescriptor) {\n        return fs.close(fd, function _discardCallback(err) {\n          /* istanbul ignore else */\n          if (err) {\n            // Low probability, and the file exists, so this could be\n            // ignored.  If it isn't we certainly need to unlink the\n            // file, and if that fails too its error is more\n            // important.\n            try {\n              fs.unlinkSync(name);\n            } catch (e) {\n              if (!isENOENT(e)) {\n                err = e;\n              }\n            }\n            return cb(err);\n          }\n          cb(null, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts));\n        });\n      }\n      /* istanbul ignore else */\n      if (opts.detachDescriptor) {\n        return cb(null, name, fd, _prepareTmpFileRemoveCallback(name, -1, opts));\n      }\n      cb(null, name, fd, _prepareTmpFileRemoveCallback(name, fd, opts));\n    });\n  });\n}\n\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */\nfunction fileSync(options) {\n  var\n    args = _parseArguments(options),\n    opts = args[0];\n\n  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n  const name = tmpNameSync(opts);\n  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n  /* istanbul ignore else */\n  if (opts.discardDescriptor) {\n    fs.closeSync(fd);\n    fd = undefined;\n  }\n\n  return {\n    name: name,\n    fd: fd,\n    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts)\n  };\n}\n\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */\nfunction dir(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create the directory\n    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n      /* istanbul ignore else */\n      if (err) return cb(err);\n\n      cb(null, name, _prepareTmpDirRemoveCallback(name, opts));\n    });\n  });\n}\n\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */\nfunction dirSync(options) {\n  var\n    args = _parseArguments(options),\n    opts = args[0];\n\n  const name = tmpNameSync(opts);\n  fs.mkdirSync(name, opts.mode || DIR_MODE);\n\n  return {\n    name: name,\n    removeCallback: _prepareTmpDirRemoveCallback(name, opts)\n  };\n}\n\n/**\n * Removes files asynchronously.\n *\n * @param {Object} fdPath\n * @param {Function} next\n * @private\n */\nfunction _removeFileAsync(fdPath, next) {\n  const _handler = function (err) {\n    if (err && !isENOENT(err)) {\n      // reraise any unanticipated error\n      return next(err);\n    }\n    next();\n  }\n\n  if (0 <= fdPath[0])\n    fs.close(fdPath[0], function (err) {\n      fs.unlink(fdPath[1], _handler);\n    });\n  else fs.unlink(fdPath[1], _handler);\n}\n\n/**\n * Removes files synchronously.\n *\n * @param {Object} fdPath\n * @private\n */\nfunction _removeFileSync(fdPath) {\n  try {\n    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);\n  } catch (e) {\n    // reraise any unanticipated error\n    if (!isEBADF(e) && !isENOENT(e)) throw e;\n  } finally {\n    try {\n      fs.unlinkSync(fdPath[1]);\n    }\n    catch (e) {\n      // reraise any unanticipated error\n      if (!isENOENT(e)) throw e;\n    }\n  }\n}\n\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @returns {fileCallback}\n * @private\n */\nfunction _prepareTmpFileRemoveCallback(name, fd, opts) {\n  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name]);\n  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], removeCallbackSync);\n\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return removeCallback;\n}\n\n/**\n * Simple wrapper for rimraf.\n *\n * @param {string} dirPath\n * @param {Function} next\n * @private\n */\nfunction _rimrafRemoveDirWrapper(dirPath, next) {\n  rimraf(dirPath, next);\n}\n\n/**\n * Simple wrapper for rimraf.sync.\n *\n * @param {string} dirPath\n * @private\n */\nfunction _rimrafRemoveDirSyncWrapper(dirPath, next) {\n  try {\n    return next(null, rimraf.sync(dirPath));\n  } catch (err) {\n    return next(err);\n  }\n}\n\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * @param {string} name\n * @param {Object} opts\n * @returns {Function} the callback\n * @private\n */\nfunction _prepareTmpDirRemoveCallback(name, opts) {\n  const removeFunction = opts.unsafeCleanup ? _rimrafRemoveDirWrapper : fs.rmdir.bind(fs);\n  const removeFunctionSync = opts.unsafeCleanup ? _rimrafRemoveDirSyncWrapper : fs.rmdirSync.bind(fs);\n  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name);\n  const removeCallback = _prepareRemoveCallback(removeFunction, name, removeCallbackSync);\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return removeCallback;\n}\n\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * @param {Function} removeFunction\n * @param {Object} arg\n * @returns {Function}\n * @private\n */\nfunction _prepareRemoveCallback(removeFunction, arg, cleanupCallbackSync) {\n  var called = false;\n\n  return function _cleanupCallback(next) {\n    next = next || function () {};\n    if (!called) {\n      const toRemove = cleanupCallbackSync || _cleanupCallback;\n      const index = _removeObjects.indexOf(toRemove);\n      /* istanbul ignore else */\n      if (index >= 0) _removeObjects.splice(index, 1);\n\n      called = true;\n      // sync?\n      if (removeFunction.length === 1) {\n        try {\n          removeFunction(arg);\n          return next(null);\n        }\n        catch (err) {\n          // if no next is provided and since we are\n          // in silent cleanup mode on process exit,\n          // we will ignore the error\n          return next(err);\n        }\n      } else return removeFunction(arg, next);\n    } else return next(new Error('cleanup callback has already been called'));\n  };\n}\n\n/**\n * The garbage collector.\n *\n * @private\n */\nfunction _garbageCollector() {\n  /* istanbul ignore else */\n  if (!_gracefulCleanup) return;\n\n  // the function being called removes itself from _removeObjects,\n  // loop until _removeObjects is empty\n  while (_removeObjects.length) {\n    try {\n      _removeObjects[0]();\n    } catch (e) {\n      // already removed?\n    }\n  }\n}\n\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n */\nfunction isEBADF(error) {\n  return isExpectedError(error, -EBADF, 'EBADF');\n}\n\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n */\nfunction isENOENT(error) {\n  return isExpectedError(error, -ENOENT, 'ENOENT');\n}\n\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {string}\n *   error.errno {string|number} any numerical value will be negated\n *\n * - Node >= 6.0 < 7.0:\n *   error.code {string}\n *   error.errno {number} negated\n *\n * - Node >= 4.0 < 6.0: introduces SystemError\n *   error.code {string}\n *   error.errno {number} negated\n *\n * - Node >= 0.10 < 4.0:\n *   error.code {number} negated\n *   error.errno n/a\n */\nfunction isExpectedError(error, code, errno) {\n  return error.code === code || error.code === errno;\n}\n\n/**\n * Helper which determines whether a string s is blank, that is undefined, or empty or null.\n *\n * @private\n * @param {string} s\n * @returns {Boolean} true whether the string s is blank, false otherwise\n */\nfunction isBlank(s) {\n  return s === null || s === undefined || !s.trim();\n}\n\n/**\n * Sets the graceful cleanup.\n */\nfunction setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\n\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n * @returns {string} the currently configured tmp dir\n */\nfunction _getTmpDir() {\n  return os.tmpdir();\n}\n\n/**\n * If there are multiple different versions of tmp in place, make sure that\n * we recognize the old listeners.\n *\n * @param {Function} listener\n * @private\n * @returns {Boolean} true whether listener is a legacy listener\n */\nfunction _is_legacy_listener(listener) {\n  return (listener.name === '_exit' || listener.name === '_uncaughtExceptionThrown')\n    && listener.toString().indexOf('_garbageCollector();') > -1;\n}\n\n/**\n * Safely install SIGINT listener.\n *\n * NOTE: this will only work on OSX and Linux.\n *\n * @private\n */\nfunction _safely_install_sigint_listener() {\n\n  const listeners = process.listeners(SIGINT);\n  const existingListeners = [];\n  for (let i = 0, length = listeners.length; i < length; i++) {\n    const lstnr = listeners[i];\n    /* istanbul ignore else */\n    if (lstnr.name === '_tmp$sigint_listener') {\n      existingListeners.push(lstnr);\n      process.removeListener(SIGINT, lstnr);\n    }\n  }\n  process.on(SIGINT, function _tmp$sigint_listener(doExit) {\n    for (let i = 0, length = existingListeners.length; i < length; i++) {\n      // let the existing listener do the garbage collection (e.g. jest sandbox)\n      try {\n        existingListeners[i](false);\n      } catch (err) {\n        // ignore\n      }\n    }\n    try {\n      // force the garbage collector even it is called again in the exit listener\n      _garbageCollector();\n    } finally {\n      if (!!doExit) {\n        process.exit(0);\n      }\n    }\n  });\n}\n\n/**\n * Safely install process exit listener.\n *\n * @private\n */\nfunction _safely_install_exit_listener() {\n  const listeners = process.listeners(EXIT);\n\n  // collect any existing listeners\n  const existingListeners = [];\n  for (let i = 0, length = listeners.length; i < length; i++) {\n    const lstnr = listeners[i];\n    /* istanbul ignore else */\n    // TODO: remove support for legacy listeners once release 1.0.0 is out\n    if (lstnr.name === '_tmp$safe_listener' || _is_legacy_listener(lstnr)) {\n      // we must forget about the uncaughtException listener, hopefully it is ours\n      if (lstnr.name !== '_uncaughtExceptionThrown') {\n        existingListeners.push(lstnr);\n      }\n      process.removeListener(EXIT, lstnr);\n    }\n  }\n  // TODO: what was the data parameter good for?\n  process.addListener(EXIT, function _tmp$safe_listener(data) {\n    for (let i = 0, length = existingListeners.length; i < length; i++) {\n      // let the existing listener do the garbage collection (e.g. jest sandbox)\n      try {\n        existingListeners[i](data);\n      } catch (err) {\n        // ignore\n      }\n    }\n    _garbageCollector();\n  });\n}\n\n_safely_install_exit_listener();\n_safely_install_sigint_listener();\n\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?number} tries the number of tries before give up the name generation\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fix name\n * @property {?string} dir the tmp directory to use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty\n */\n\n/**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor\n * @property {fileCallback} removeCallback the callback function to remove the file\n */\n\n/**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */\n\n/**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */\n\n/**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call after entry was removed\n */\n\n/**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */\n\n// exporting all the needed methods\n\n// evaluate os.tmpdir() lazily, mainly for simplifying testing but it also will\n// allow users to reconfigure the temporary directory\nObject.defineProperty(module.exports, 'tmpdir', {\n  enumerable: true,\n  configurable: false,\n  get: function () {\n    return _getTmpDir();\n  }\n});\n\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\n\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\n\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\n\nmodule.exports.setGracefulCleanup = setGracefulCleanup;\n","/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/*\n * Module dependencies.\n */\nconst fs = require('fs');\nconst os = require('os');\nconst path = require('path');\nconst crypto = require('crypto');\nconst _c = { fs: fs.constants, os: os.constants };\nconst rimraf = require('rimraf');\n\n/*\n * The working inner variables.\n */\nconst\n  // the random characters to choose from\n  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n\n  TEMPLATE_PATTERN = /XXXXXX/,\n\n  DEFAULT_TRIES = 3,\n\n  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),\n\n  // constants are off on the windows platform and will not match the actual errno codes\n  IS_WIN32 = os.platform() === 'win32',\n  EBADF = _c.EBADF || _c.os.errno.EBADF,\n  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,\n\n  DIR_MODE = 0o700 /* 448 */,\n  FILE_MODE = 0o600 /* 384 */,\n\n  EXIT = 'exit',\n\n  // this will hold the objects need to be removed on exit\n  _removeObjects = [],\n\n  // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback\n  FN_RMDIR_SYNC = fs.rmdirSync.bind(fs),\n  FN_RIMRAF_SYNC = rimraf.sync;\n\nlet\n  _gracefulCleanup = false;\n\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */\nfunction tmpName(options, callback) {\n  const\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  try {\n    _assertAndSanitizeOptions(opts);\n  } catch (err) {\n    return cb(err);\n  }\n\n  let tries = opts.tries;\n  (function _getUniqueName() {\n    try {\n      const name = _generateTmpName(opts);\n\n      // check whether the path exists then retry if needed\n      fs.stat(name, function (err) {\n        /* istanbul ignore else */\n        if (!err) {\n          /* istanbul ignore else */\n          if (tries-- > 0) return _getUniqueName();\n\n          return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));\n        }\n\n        cb(null, name);\n      });\n    } catch (err) {\n      cb(err);\n    }\n  }());\n}\n\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */\nfunction tmpNameSync(options) {\n  const\n    args = _parseArguments(options),\n    opts = args[0];\n\n  _assertAndSanitizeOptions(opts);\n\n  let tries = opts.tries;\n  do {\n    const name = _generateTmpName(opts);\n    try {\n      fs.statSync(name);\n    } catch (e) {\n      return name;\n    }\n  } while (tries-- > 0);\n\n  throw new Error('Could not get a unique tmp filename, max tries reached');\n}\n\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined\n * @param {?fileCallback} callback\n */\nfunction file(options, callback) {\n  const\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create and open the file\n    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n      /* istanbu ignore else */\n      if (err) return cb(err);\n\n      if (opts.discardDescriptor) {\n        return fs.close(fd, function _discardCallback(possibleErr) {\n          // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only\n          return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));\n        });\n      } else {\n        // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care\n        // about the descriptor\n        const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));\n      }\n    });\n  });\n}\n\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */\nfunction fileSync(options) {\n  const\n    args = _parseArguments(options),\n    opts = args[0];\n\n  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n  const name = tmpNameSync(opts);\n  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n  /* istanbul ignore else */\n  if (opts.discardDescriptor) {\n    fs.closeSync(fd);\n    fd = undefined;\n  }\n\n  return {\n    name: name,\n    fd: fd,\n    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)\n  };\n}\n\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */\nfunction dir(options, callback) {\n  const\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create the directory\n    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n      /* istanbul ignore else */\n      if (err) return cb(err);\n\n      cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));\n    });\n  });\n}\n\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */\nfunction dirSync(options) {\n  const\n    args = _parseArguments(options),\n    opts = args[0];\n\n  const name = tmpNameSync(opts);\n  fs.mkdirSync(name, opts.mode || DIR_MODE);\n\n  return {\n    name: name,\n    removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)\n  };\n}\n\n/**\n * Removes files asynchronously.\n *\n * @param {Object} fdPath\n * @param {Function} next\n * @private\n */\nfunction _removeFileAsync(fdPath, next) {\n  const _handler = function (err) {\n    if (err && !_isENOENT(err)) {\n      // reraise any unanticipated error\n      return next(err);\n    }\n    next();\n  };\n\n  if (0 <= fdPath[0])\n    fs.close(fdPath[0], function () {\n      fs.unlink(fdPath[1], _handler);\n    });\n  else fs.unlink(fdPath[1], _handler);\n}\n\n/**\n * Removes files synchronously.\n *\n * @param {Object} fdPath\n * @private\n */\nfunction _removeFileSync(fdPath) {\n  let rethrownException = null;\n  try {\n    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);\n  } catch (e) {\n    // reraise any unanticipated error\n    if (!_isEBADF(e) && !_isENOENT(e)) throw e;\n  } finally {\n    try {\n      fs.unlinkSync(fdPath[1]);\n    }\n    catch (e) {\n      // reraise any unanticipated error\n      if (!_isENOENT(e)) rethrownException = e;\n    }\n  }\n  if (rethrownException !== null) {\n    throw rethrownException;\n  }\n}\n\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * Returns either a sync callback or a async callback depending on whether\n * fileSync or file was called, which is expressed by the sync parameter.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {fileCallback | fileCallbackSync}\n * @private\n */\nfunction _prepareTmpFileRemoveCallback(name, fd, opts, sync) {\n  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);\n  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);\n\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return sync ? removeCallbackSync : removeCallback;\n}\n\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * Returns either a sync callback or a async callback depending on whether\n * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.\n *\n * @param {string} name\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {Function} the callback\n * @private\n */\nfunction _prepareTmpDirRemoveCallback(name, opts, sync) {\n  const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);\n  const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;\n  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);\n  const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return sync ? removeCallbackSync : removeCallback;\n}\n\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * The cleanup callback is save to be called multiple times.\n * Subsequent invocations will be ignored.\n *\n * @param {Function} removeFunction\n * @param {string} fileOrDirName\n * @param {boolean} sync\n * @param {cleanupCallbackSync?} cleanupCallbackSync\n * @returns {cleanupCallback | cleanupCallbackSync}\n * @private\n */\nfunction _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {\n  let called = false;\n\n  // if sync is true, the next parameter will be ignored\n  return function _cleanupCallback(next) {\n\n    /* istanbul ignore else */\n    if (!called) {\n      // remove cleanupCallback from cache\n      const toRemove = cleanupCallbackSync || _cleanupCallback;\n      const index = _removeObjects.indexOf(toRemove);\n      /* istanbul ignore else */\n      if (index >= 0) _removeObjects.splice(index, 1);\n\n      called = true;\n      if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {\n        return removeFunction(fileOrDirName);\n      } else {\n        return removeFunction(fileOrDirName, next || function() {});\n      }\n    }\n  };\n}\n\n/**\n * The garbage collector.\n *\n * @private\n */\nfunction _garbageCollector() {\n  /* istanbul ignore else */\n  if (!_gracefulCleanup) return;\n\n  // the function being called removes itself from _removeObjects,\n  // loop until _removeObjects is empty\n  while (_removeObjects.length) {\n    try {\n      _removeObjects[0]();\n    } catch (e) {\n      // already removed?\n    }\n  }\n}\n\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */\nfunction _randomChars(howMany) {\n  let\n    value = [],\n    rnd = null;\n\n  // make sure that we do not fail because we ran out of entropy\n  try {\n    rnd = crypto.randomBytes(howMany);\n  } catch (e) {\n    rnd = crypto.pseudoRandomBytes(howMany);\n  }\n\n  for (var i = 0; i < howMany; i++) {\n    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n  }\n\n  return value.join('');\n}\n\n/**\n * Helper which determines whether a string s is blank, that is undefined, or empty or null.\n *\n * @private\n * @param {string} s\n * @returns {Boolean} true whether the string s is blank, false otherwise\n */\nfunction _isBlank(s) {\n  return s === null || _isUndefined(s) || !s.trim();\n}\n\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|null|undefined|Function)} options\n * @param {?Function} callback\n * @returns {Array} parsed arguments\n * @private\n */\nfunction _parseArguments(options, callback) {\n  /* istanbul ignore else */\n  if (typeof options === 'function') {\n    return [{}, options];\n  }\n\n  /* istanbul ignore else */\n  if (_isUndefined(options)) {\n    return [{}, callback];\n  }\n\n  // copy options so we do not leak the changes we make internally\n  const actualOptions = {};\n  for (const key of Object.getOwnPropertyNames(options)) {\n    actualOptions[key] = options[key];\n  }\n\n  return [actualOptions, callback];\n}\n\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */\nfunction _generateTmpName(opts) {\n\n  const tmpDir = opts.tmpdir;\n\n  /* istanbul ignore else */\n  if (!_isUndefined(opts.name))\n    return path.join(tmpDir, opts.dir, opts.name);\n\n  /* istanbul ignore else */\n  if (!_isUndefined(opts.template))\n    return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));\n\n  // prefix and postfix\n  const name = [\n    opts.prefix ? opts.prefix : 'tmp',\n    '-',\n    process.pid,\n    '-',\n    _randomChars(12),\n    opts.postfix ? '-' + opts.postfix : ''\n  ].join('');\n\n  return path.join(tmpDir, opts.dir, name);\n}\n\n/**\n * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing\n * options.\n *\n * @param {Options} options\n * @private\n */\nfunction _assertAndSanitizeOptions(options) {\n\n  options.tmpdir = _getTmpDir(options);\n\n  const tmpDir = options.tmpdir;\n\n  /* istanbul ignore else */\n  if (!_isUndefined(options.name))\n    _assertIsRelative(options.name, 'name', tmpDir);\n  /* istanbul ignore else */\n  if (!_isUndefined(options.dir))\n    _assertIsRelative(options.dir, 'dir', tmpDir);\n  /* istanbul ignore else */\n  if (!_isUndefined(options.template)) {\n    _assertIsRelative(options.template, 'template', tmpDir);\n    if (!options.template.match(TEMPLATE_PATTERN))\n      throw new Error(`Invalid template, found \"${options.template}\".`);\n  }\n  /* istanbul ignore else */\n  if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0)\n    throw new Error(`Invalid tries, found \"${options.tries}\".`);\n\n  // if a name was specified we will try once\n  options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;\n  options.keep = !!options.keep;\n  options.detachDescriptor = !!options.detachDescriptor;\n  options.discardDescriptor = !!options.discardDescriptor;\n  options.unsafeCleanup = !!options.unsafeCleanup;\n\n  // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to\n  options.dir = _isUndefined(options.dir) ? '' : path.relative(tmpDir, _resolvePath(options.dir, tmpDir));\n  options.template = _isUndefined(options.template) ? undefined : path.relative(tmpDir, _resolvePath(options.template, tmpDir));\n  // sanitize further if template is relative to options.dir\n  options.template = _isBlank(options.template) ? undefined : path.relative(options.dir, options.template);\n\n  // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to\n  options.name = _isUndefined(options.name) ? undefined : _sanitizeName(options.name);\n  options.prefix = _isUndefined(options.prefix) ? '' : options.prefix;\n  options.postfix = _isUndefined(options.postfix) ? '' : options.postfix;\n}\n\n/**\n * Resolve the specified path name in respect to tmpDir.\n *\n * The specified name might include relative path components, e.g. ../\n * so we need to resolve in order to be sure that is is located inside tmpDir\n *\n * @param name\n * @param tmpDir\n * @returns {string}\n * @private\n */\nfunction _resolvePath(name, tmpDir) {\n  const sanitizedName = _sanitizeName(name);\n  if (sanitizedName.startsWith(tmpDir)) {\n    return path.resolve(sanitizedName);\n  } else {\n    return path.resolve(path.join(tmpDir, sanitizedName));\n  }\n}\n\n/**\n * Sanitize the specified path name by removing all quote characters.\n *\n * @param name\n * @returns {string}\n * @private\n */\nfunction _sanitizeName(name) {\n  if (_isBlank(name)) {\n    return name;\n  }\n  return name.replace(/[\"']/g, '');\n}\n\n/**\n * Asserts whether specified name is relative to the specified tmpDir.\n *\n * @param {string} name\n * @param {string} option\n * @param {string} tmpDir\n * @throws {Error}\n * @private\n */\nfunction _assertIsRelative(name, option, tmpDir) {\n  if (option === 'name') {\n    // assert that name is not absolute and does not contain a path\n    if (path.isAbsolute(name))\n      throw new Error(`${option} option must not contain an absolute path, found \"${name}\".`);\n    // must not fail on valid .<name> or ..<name> or similar such constructs\n    let basename = path.basename(name);\n    if (basename === '..' || basename === '.' || basename !== name)\n      throw new Error(`${option} option must not contain a path, found \"${name}\".`);\n  }\n  else { // if (option === 'dir' || option === 'template') {\n    // assert that dir or template are relative to tmpDir\n    if (path.isAbsolute(name) && !name.startsWith(tmpDir)) {\n      throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${name}\".`);\n    }\n    let resolvedPath = _resolvePath(name, tmpDir);\n    if (!resolvedPath.startsWith(tmpDir))\n      throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${resolvedPath}\".`);\n  }\n}\n\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\nfunction _isEBADF(error) {\n  return _isExpectedError(error, -EBADF, 'EBADF');\n}\n\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\nfunction _isENOENT(error) {\n  return _isExpectedError(error, -ENOENT, 'ENOENT');\n}\n\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {string}\n *   error.errno {number} any numerical value will be negated\n *\n * CAVEAT\n *\n * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT\n * is no different here.\n *\n * @param {SystemError} error\n * @param {number} errno\n * @param {string} code\n * @private\n */\nfunction _isExpectedError(error, errno, code) {\n  return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;\n}\n\n/**\n * Sets the graceful cleanup.\n *\n * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the\n * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary\n * object removals.\n */\nfunction setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\n\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n * @param {?Options} options\n * @returns {string} the currently configured tmp dir\n */\nfunction _getTmpDir(options) {\n  return path.resolve(_sanitizeName(options && options.tmpdir || os.tmpdir()));\n}\n\n// Install process exit listener\nprocess.addListener(EXIT, _garbageCollector);\n\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected\n * @property {?number} tries the number of tries before give up the name generation\n * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fixed name relative to tmpdir or the specified dir option\n * @property {?string} dir tmp directory relative to the root tmp directory in use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir\n * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty\n * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection\n * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection\n */\n\n/**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor or -1 if the fd has been discarded\n * @property {fileCallback} removeCallback the callback function to remove the file\n */\n\n/**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */\n\n/**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */\n\n/**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback fileCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallbackSync\n */\n\n/**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */\n\n// exporting all the needed methods\n\n// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will\n// allow users to reconfigure the temporary directory\nObject.defineProperty(module.exports, 'tmpdir', {\n  enumerable: true,\n  configurable: false,\n  get: function () {\n    return _getTmpDir();\n  }\n});\n\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\n\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\n\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\n\nmodule.exports.setGracefulCleanup = setGracefulCleanup;\n","const assert = require(\"assert\")\nconst path = require(\"path\")\nconst fs = require(\"fs\")\nlet glob = undefined\ntry {\n  glob = require(\"glob\")\n} catch (_err) {\n  // treat glob as optional.\n}\n\nconst defaultGlobOpts = {\n  nosort: true,\n  silent: true\n}\n\n// for EMFILE handling\nlet timeout = 0\n\nconst isWindows = (process.platform === \"win32\")\n\nconst defaults = options => {\n  const methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(m => {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n  options.emfileWait = options.emfileWait || 1000\n  if (options.glob === false) {\n    options.disableGlob = true\n  }\n  if (options.disableGlob !== true && glob === undefined) {\n    throw Error('glob dependency not found, set `options.disableGlob = true` if intentional')\n  }\n  options.disableGlob = options.disableGlob || false\n  options.glob = options.glob || defaultGlobOpts\n}\n\nconst rimraf = (p, options, cb) => {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert.equal(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  let busyTries = 0\n  let errState = null\n  let n = 0\n\n  const next = (er) => {\n    errState = errState || er\n    if (--n === 0)\n      cb(errState)\n  }\n\n  const afterGlob = (er, results) => {\n    if (er)\n      return cb(er)\n\n    n = results.length\n    if (n === 0)\n      return cb()\n\n    results.forEach(p => {\n      const CB = (er) => {\n        if (er) {\n          if ((er.code === \"EBUSY\" || er.code === \"ENOTEMPTY\" || er.code === \"EPERM\") &&\n              busyTries < options.maxBusyTries) {\n            busyTries ++\n            // try again, with the same exact callback as this one.\n            return setTimeout(() => rimraf_(p, options, CB), busyTries * 100)\n          }\n\n          // this one won't happen if graceful-fs is used.\n          if (er.code === \"EMFILE\" && timeout < options.emfileWait) {\n            return setTimeout(() => rimraf_(p, options, CB), timeout ++)\n          }\n\n          // already gone\n          if (er.code === \"ENOENT\") er = null\n        }\n\n        timeout = 0\n        next(er)\n      }\n      rimraf_(p, options, CB)\n    })\n  }\n\n  if (options.disableGlob || !glob.hasMagic(p))\n    return afterGlob(null, [p])\n\n  options.lstat(p, (er, stat) => {\n    if (!er)\n      return afterGlob(null, [p])\n\n    glob(p, options.glob, afterGlob)\n  })\n\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nconst rimraf_ = (p, options, cb) => {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, (er, st) => {\n    if (er && er.code === \"ENOENT\")\n      return cb(null)\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === \"EPERM\" && isWindows)\n      fixWinEPERM(p, options, er, cb)\n\n    if (st && st.isDirectory())\n      return rmdir(p, options, er, cb)\n\n    options.unlink(p, er => {\n      if (er) {\n        if (er.code === \"ENOENT\")\n          return cb(null)\n        if (er.code === \"EPERM\")\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        if (er.code === \"EISDIR\")\n          return rmdir(p, options, er, cb)\n      }\n      return cb(er)\n    })\n  })\n}\n\nconst fixWinEPERM = (p, options, er, cb) => {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.chmod(p, 0o666, er2 => {\n    if (er2)\n      cb(er2.code === \"ENOENT\" ? null : er)\n    else\n      options.stat(p, (er3, stats) => {\n        if (er3)\n          cb(er3.code === \"ENOENT\" ? null : er)\n        else if (stats.isDirectory())\n          rmdir(p, options, er, cb)\n        else\n          options.unlink(p, cb)\n      })\n  })\n}\n\nconst fixWinEPERMSync = (p, options, er) => {\n  assert(p)\n  assert(options)\n\n  try {\n    options.chmodSync(p, 0o666)\n  } catch (er2) {\n    if (er2.code === \"ENOENT\")\n      return\n    else\n      throw er\n  }\n\n  let stats\n  try {\n    stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === \"ENOENT\")\n      return\n    else\n      throw er\n  }\n\n  if (stats.isDirectory())\n    rmdirSync(p, options, er)\n  else\n    options.unlinkSync(p)\n}\n\nconst rmdir = (p, options, originalEr, cb) => {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, er => {\n    if (er && (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\"))\n      rmkids(p, options, cb)\n    else if (er && er.code === \"ENOTDIR\")\n      cb(originalEr)\n    else\n      cb(er)\n  })\n}\n\nconst rmkids = (p, options, cb) => {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, (er, files) => {\n    if (er)\n      return cb(er)\n    let n = files.length\n    if (n === 0)\n      return options.rmdir(p, cb)\n    let errState\n    files.forEach(f => {\n      rimraf(path.join(p, f), options, er => {\n        if (errState)\n          return\n        if (er)\n          return cb(errState = er)\n        if (--n === 0)\n          options.rmdir(p, cb)\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nconst rimrafSync = (p, options) => {\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n\n  let results\n\n  if (options.disableGlob || !glob.hasMagic(p)) {\n    results = [p]\n  } else {\n    try {\n      options.lstatSync(p)\n      results = [p]\n    } catch (er) {\n      results = glob.sync(p, options.glob)\n    }\n  }\n\n  if (!results.length)\n    return\n\n  for (let i = 0; i < results.length; i++) {\n    const p = results[i]\n\n    let st\n    try {\n      st = options.lstatSync(p)\n    } catch (er) {\n      if (er.code === \"ENOENT\")\n        return\n\n      // Windows can EPERM on stat.  Life is suffering.\n      if (er.code === \"EPERM\" && isWindows)\n        fixWinEPERMSync(p, options, er)\n    }\n\n    try {\n      // sunos lets the root user unlink directories, which is... weird.\n      if (st && st.isDirectory())\n        rmdirSync(p, options, null)\n      else\n        options.unlinkSync(p)\n    } catch (er) {\n      if (er.code === \"ENOENT\")\n        return\n      if (er.code === \"EPERM\")\n        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n      if (er.code !== \"EISDIR\")\n        throw er\n\n      rmdirSync(p, options, er)\n    }\n  }\n}\n\nconst rmdirSync = (p, options, originalEr) => {\n  assert(p)\n  assert(options)\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === \"ENOENT\")\n      return\n    if (er.code === \"ENOTDIR\")\n      throw originalEr\n    if (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\")\n      rmkidsSync(p, options)\n  }\n}\n\nconst rmkidsSync = (p, options) => {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))\n\n  // We only end up here once we got ENOTEMPTY at least once, and\n  // at this point, we are guaranteed to have removed all the kids.\n  // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n  // try really hard to delete stuff on windows, because it has a\n  // PROFOUNDLY annoying habit of not closing handles promptly when\n  // files are deleted, resulting in spurious ENOTEMPTY errors.\n  const retries = isWindows ? 100 : 1\n  let i = 0\n  do {\n    let threw = true\n    try {\n      const ret = options.rmdirSync(p, options)\n      threw = false\n      return ret\n    } finally {\n      if (++i < retries && threw)\n        continue\n    }\n  } while (true)\n}\n\nmodule.exports = rimraf\nrimraf.sync = rimrafSync\n","module.exports = require('./lib/tunnel');\n","'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar http = require('http');\nvar https = require('https');\nvar events = require('events');\nvar assert = require('assert');\nvar util = require('util');\n\n\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  return agent;\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  return agent;\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.proxyOptions = self.options.proxy || {};\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n  self.requests = [];\n  self.sockets = [];\n\n  self.on('free', function onFree(socket, host, port, localAddress) {\n    var options = toOptions(host, port, localAddress);\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i];\n      if (pending.host === options.host && pending.port === options.port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1);\n        pending.request.onSocket(socket);\n        return;\n      }\n    }\n    socket.destroy();\n    self.removeSocket(socket);\n  });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n  var self = this;\n  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push(options);\n    return;\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createSocket(options, function(socket) {\n    socket.on('free', onFree);\n    socket.on('close', onCloseOrRemove);\n    socket.on('agentRemove', onCloseOrRemove);\n    req.onSocket(socket);\n\n    function onFree() {\n      self.emit('free', socket, options);\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket);\n      socket.removeListener('free', onFree);\n      socket.removeListener('close', onCloseOrRemove);\n      socket.removeListener('agentRemove', onCloseOrRemove);\n    }\n  });\n};\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this;\n  var placeholder = {};\n  self.sockets.push(placeholder);\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, {\n    method: 'CONNECT',\n    path: options.host + ':' + options.port,\n    agent: false,\n    headers: {\n      host: options.host + ':' + options.port\n    }\n  });\n  if (options.localAddress) {\n    connectOptions.localAddress = options.localAddress;\n  }\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {};\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64');\n  }\n\n  debug('making CONNECT request');\n  var connectReq = self.request(connectOptions);\n  connectReq.useChunkedEncodingByDefault = false; // for v0.6\n  connectReq.once('response', onResponse); // for v0.6\n  connectReq.once('upgrade', onUpgrade);   // for v0.6\n  connectReq.once('connect', onConnect);   // for v0.7 or later\n  connectReq.once('error', onError);\n  connectReq.end();\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true;\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head);\n    });\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners();\n    socket.removeAllListeners();\n\n    if (res.statusCode !== 200) {\n      debug('tunneling socket could not be established, statusCode=%d',\n        res.statusCode);\n      socket.destroy();\n      var error = new Error('tunneling socket could not be established, ' +\n        'statusCode=' + res.statusCode);\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    if (head.length > 0) {\n      debug('got illegal response body from proxy');\n      socket.destroy();\n      var error = new Error('got illegal response body from proxy');\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    debug('tunneling connection has established');\n    self.sockets[self.sockets.indexOf(placeholder)] = socket;\n    return cb(socket);\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners();\n\n    debug('tunneling socket could not be established, cause=%s\\n',\n          cause.message, cause.stack);\n    var error = new Error('tunneling socket could not be established, ' +\n                          'cause=' + cause.message);\n    error.code = 'ECONNRESET';\n    options.request.emit('error', error);\n    self.removeSocket(placeholder);\n  }\n};\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) {\n    return;\n  }\n  this.sockets.splice(pos, 1);\n\n  var pending = this.requests.shift();\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n      pending.request.onSocket(socket);\n    });\n  }\n};\n\nfunction createSecureSocket(options, cb) {\n  var self = this;\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    var hostHeader = options.request.getHeader('host');\n    var tlsOptions = mergeOptions({}, self.options, {\n      socket: socket,\n      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n    });\n\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, tlsOptions);\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n    cb(secureSocket);\n  });\n}\n\n\nfunction toOptions(host, port, localAddress) {\n  if (typeof host === 'string') { // since v0.10\n    return {\n      host: host,\n      port: port,\n      localAddress: localAddress\n    };\n  }\n  return host; // for v0.11 or later\n}\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i];\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides);\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j];\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0];\n    } else {\n      args.unshift('TUNNEL:');\n    }\n    console.error.apply(console, args);\n  }\n} else {\n  debug = function() {};\n}\nexports.debug = debug; // for test\n","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-4a68b39b.js');\nvar Schema = require('./Schema-42e9705c.js');\n\nconst defaultOptions = {\n  anchorPrefix: 'a',\n  customTags: null,\n  indent: 2,\n  indentSeq: true,\n  keepCstNodes: false,\n  keepNodeTypes: true,\n  keepBlobsInJSON: true,\n  mapAsMap: false,\n  maxAliasCount: 100,\n  prettyErrors: false,\n  // TODO Set true in v2\n  simpleKeys: false,\n  version: '1.2'\n};\nconst scalarOptions = {\n  get binary() {\n    return resolveSeq.binaryOptions;\n  },\n\n  set binary(opt) {\n    Object.assign(resolveSeq.binaryOptions, opt);\n  },\n\n  get bool() {\n    return resolveSeq.boolOptions;\n  },\n\n  set bool(opt) {\n    Object.assign(resolveSeq.boolOptions, opt);\n  },\n\n  get int() {\n    return resolveSeq.intOptions;\n  },\n\n  set int(opt) {\n    Object.assign(resolveSeq.intOptions, opt);\n  },\n\n  get null() {\n    return resolveSeq.nullOptions;\n  },\n\n  set null(opt) {\n    Object.assign(resolveSeq.nullOptions, opt);\n  },\n\n  get str() {\n    return resolveSeq.strOptions;\n  },\n\n  set str(opt) {\n    Object.assign(resolveSeq.strOptions, opt);\n  }\n\n};\nconst documentOptions = {\n  '1.0': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: PlainValue.defaultTagPrefix\n    }, {\n      handle: '!!',\n      prefix: 'tag:private.yaml.org,2002:'\n    }]\n  },\n  '1.1': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  },\n  '1.2': {\n    schema: 'core',\n    merge: false,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  }\n};\n\nfunction stringifyTag(doc, tag) {\n  if ((doc.version || doc.options.version) === '1.0') {\n    const priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n    if (priv) return '!' + priv[1];\n    const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n    return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, '')}`;\n  }\n\n  let p = doc.tagPrefixes.find(p => tag.indexOf(p.prefix) === 0);\n\n  if (!p) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    p = dtp && dtp.find(p => tag.indexOf(p.prefix) === 0);\n  }\n\n  if (!p) return tag[0] === '!' ? tag : `!<${tag}>`;\n  const suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, ch => ({\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n  })[ch]);\n  return p.handle + suffix;\n}\n\nfunction getTagObject(tags, item) {\n  if (item instanceof resolveSeq.Alias) return resolveSeq.Alias;\n\n  if (item.tag) {\n    const match = tags.filter(t => t.tag === item.tag);\n    if (match.length > 0) return match.find(t => t.format === item.format) || match[0];\n  }\n\n  let tagObj, obj;\n\n  if (item instanceof resolveSeq.Scalar) {\n    obj = item.value; // TODO: deprecate/remove class check\n\n    const match = tags.filter(t => t.identify && t.identify(obj) || t.class && obj instanceof t.class);\n    tagObj = match.find(t => t.format === item.format) || match.find(t => !t.format);\n  } else {\n    obj = item;\n    tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);\n  }\n\n  if (!tagObj) {\n    const name = obj && obj.constructor ? obj.constructor.name : typeof obj;\n    throw new Error(`Tag not resolved for ${name} value`);\n  }\n\n  return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\n\n\nfunction stringifyProps(node, tagObj, {\n  anchors,\n  doc\n}) {\n  const props = [];\n  const anchor = doc.anchors.getName(node);\n\n  if (anchor) {\n    anchors[anchor] = node;\n    props.push(`&${anchor}`);\n  }\n\n  if (node.tag) {\n    props.push(stringifyTag(doc, node.tag));\n  } else if (!tagObj.default) {\n    props.push(stringifyTag(doc, tagObj.tag));\n  }\n\n  return props.join(' ');\n}\n\nfunction stringify(item, ctx, onComment, onChompKeep) {\n  const {\n    anchors,\n    schema\n  } = ctx.doc;\n  let tagObj;\n\n  if (!(item instanceof resolveSeq.Node)) {\n    const createCtx = {\n      aliasNodes: [],\n      onTagObj: o => tagObj = o,\n      prevObjects: new Map()\n    };\n    item = schema.createNode(item, true, null, createCtx);\n\n    for (const alias of createCtx.aliasNodes) {\n      alias.source = alias.source.node;\n      let name = anchors.getName(alias.source);\n\n      if (!name) {\n        name = anchors.newName();\n        anchors.map[name] = alias.source;\n      }\n    }\n  }\n\n  if (item instanceof resolveSeq.Pair) return item.toString(ctx, onComment, onChompKeep);\n  if (!tagObj) tagObj = getTagObject(schema.tags, item);\n  const props = stringifyProps(item, tagObj, ctx);\n  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n  const str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n  if (!props) return str;\n  return item instanceof resolveSeq.Scalar || str[0] === '{' || str[0] === '[' ? `${props} ${str}` : `${props}\\n${ctx.indent}${str}`;\n}\n\nclass Anchors {\n  static validAnchorNode(node) {\n    return node instanceof resolveSeq.Scalar || node instanceof resolveSeq.YAMLSeq || node instanceof resolveSeq.YAMLMap;\n  }\n\n  constructor(prefix) {\n    PlainValue._defineProperty(this, \"map\", {});\n\n    this.prefix = prefix;\n  }\n\n  createAlias(node, name) {\n    this.setAnchor(node, name);\n    return new resolveSeq.Alias(node);\n  }\n\n  createMergePair(...sources) {\n    const merge = new resolveSeq.Merge();\n    merge.value.items = sources.map(s => {\n      if (s instanceof resolveSeq.Alias) {\n        if (s.source instanceof resolveSeq.YAMLMap) return s;\n      } else if (s instanceof resolveSeq.YAMLMap) {\n        return this.createAlias(s);\n      }\n\n      throw new Error('Merge sources must be Map nodes or their Aliases');\n    });\n    return merge;\n  }\n\n  getName(node) {\n    const {\n      map\n    } = this;\n    return Object.keys(map).find(a => map[a] === node);\n  }\n\n  getNames() {\n    return Object.keys(this.map);\n  }\n\n  getNode(name) {\n    return this.map[name];\n  }\n\n  newName(prefix) {\n    if (!prefix) prefix = this.prefix;\n    const names = Object.keys(this.map);\n\n    for (let i = 1; true; ++i) {\n      const name = `${prefix}${i}`;\n      if (!names.includes(name)) return name;\n    }\n  } // During parsing, map & aliases contain CST nodes\n\n\n  resolveNodes() {\n    const {\n      map,\n      _cstAliases\n    } = this;\n    Object.keys(map).forEach(a => {\n      map[a] = map[a].resolved;\n    });\n\n    _cstAliases.forEach(a => {\n      a.source = a.source.resolved;\n    });\n\n    delete this._cstAliases;\n  }\n\n  setAnchor(node, name) {\n    if (node != null && !Anchors.validAnchorNode(node)) {\n      throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');\n    }\n\n    if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n      throw new Error('Anchor names must not contain whitespace or control characters');\n    }\n\n    const {\n      map\n    } = this;\n    const prev = node && Object.keys(map).find(a => map[a] === node);\n\n    if (prev) {\n      if (!name) {\n        return prev;\n      } else if (prev !== name) {\n        delete map[prev];\n        map[name] = node;\n      }\n    } else {\n      if (!name) {\n        if (!node) return null;\n        name = this.newName();\n      }\n\n      map[name] = node;\n    }\n\n    return name;\n  }\n\n}\n\nconst visit = (node, tags) => {\n  if (node && typeof node === 'object') {\n    const {\n      tag\n    } = node;\n\n    if (node instanceof resolveSeq.Collection) {\n      if (tag) tags[tag] = true;\n      node.items.forEach(n => visit(n, tags));\n    } else if (node instanceof resolveSeq.Pair) {\n      visit(node.key, tags);\n      visit(node.value, tags);\n    } else if (node instanceof resolveSeq.Scalar) {\n      if (tag) tags[tag] = true;\n    }\n  }\n\n  return tags;\n};\n\nconst listTagNames = node => Object.keys(visit(node, {}));\n\nfunction parseContents(doc, contents) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let body = undefined;\n  let spaceBefore = false;\n\n  for (const node of contents) {\n    if (node.valueRange) {\n      if (body !== undefined) {\n        const msg = 'Document contains trailing content not separated by a ... or --- line';\n        doc.errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n        break;\n      }\n\n      const res = resolveSeq.resolveNode(doc, node);\n\n      if (spaceBefore) {\n        res.spaceBefore = true;\n        spaceBefore = false;\n      }\n\n      body = res;\n    } else if (node.comment !== null) {\n      const cc = body === undefined ? comments.before : comments.after;\n      cc.push(node.comment);\n    } else if (node.type === PlainValue.Type.BLANK_LINE) {\n      spaceBefore = true;\n\n      if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n        // space-separated comments at start are parsed as document comments\n        doc.commentBefore = comments.before.join('\\n');\n        comments.before = [];\n      }\n    }\n  }\n\n  doc.contents = body || null;\n\n  if (!body) {\n    doc.comment = comments.before.concat(comments.after).join('\\n') || null;\n  } else {\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;\n      cbNode.commentBefore = cbNode.commentBefore ? `${cb}\\n${cbNode.commentBefore}` : cb;\n    }\n\n    doc.comment = comments.after.join('\\n') || null;\n  }\n}\n\nfunction resolveTagDirective({\n  tagPrefixes\n}, directive) {\n  const [handle, prefix] = directive.parameters;\n\n  if (!handle || !prefix) {\n    const msg = 'Insufficient parameters given for %TAG directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (tagPrefixes.some(p => p.handle === handle)) {\n    const msg = 'The %TAG directive must only be given at most once per handle in the same document.';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  return {\n    handle,\n    prefix\n  };\n}\n\nfunction resolveYamlDirective(doc, directive) {\n  let [version] = directive.parameters;\n  if (directive.name === 'YAML:1.0') version = '1.0';\n\n  if (!version) {\n    const msg = 'Insufficient parameters given for %YAML directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (!documentOptions[version]) {\n    const v0 = doc.version || doc.options.version;\n    const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n  }\n\n  return version;\n}\n\nfunction parseDirectives(doc, directives, prevDoc) {\n  const directiveComments = [];\n  let hasDirectives = false;\n\n  for (const directive of directives) {\n    const {\n      comment,\n      name\n    } = directive;\n\n    switch (name) {\n      case 'TAG':\n        try {\n          doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      case 'YAML':\n      case 'YAML:1.0':\n        if (doc.version) {\n          const msg = 'The %YAML directive must only be given at most once per document.';\n          doc.errors.push(new PlainValue.YAMLSemanticError(directive, msg));\n        }\n\n        try {\n          doc.version = resolveYamlDirective(doc, directive);\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      default:\n        if (name) {\n          const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;\n          doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n        }\n\n    }\n\n    if (comment) directiveComments.push(comment);\n  }\n\n  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {\n    const copyTagPrefix = ({\n      handle,\n      prefix\n    }) => ({\n      handle,\n      prefix\n    });\n\n    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n    doc.version = prevDoc.version;\n  }\n\n  doc.commentBefore = directiveComments.join('\\n') || null;\n}\n\nfunction assertCollection(contents) {\n  if (contents instanceof resolveSeq.Collection) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\n\nclass Document {\n  constructor(options) {\n    this.anchors = new Anchors(options.anchorPrefix);\n    this.commentBefore = null;\n    this.comment = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.errors = [];\n    this.options = options;\n    this.schema = null;\n    this.tagPrefixes = [];\n    this.version = null;\n    this.warnings = [];\n  }\n\n  add(value) {\n    assertCollection(this.contents);\n    return this.contents.add(value);\n  }\n\n  addIn(path, value) {\n    assertCollection(this.contents);\n    this.contents.addIn(path, value);\n  }\n\n  delete(key) {\n    assertCollection(this.contents);\n    return this.contents.delete(key);\n  }\n\n  deleteIn(path) {\n    if (resolveSeq.isEmptyPath(path)) {\n      if (this.contents == null) return false;\n      this.contents = null;\n      return true;\n    }\n\n    assertCollection(this.contents);\n    return this.contents.deleteIn(path);\n  }\n\n  getDefaults() {\n    return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n  }\n\n  get(key, keepScalar) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.get(key, keepScalar) : undefined;\n  }\n\n  getIn(path, keepScalar) {\n    if (resolveSeq.isEmptyPath(path)) return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path, keepScalar) : undefined;\n  }\n\n  has(key) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.has(key) : false;\n  }\n\n  hasIn(path) {\n    if (resolveSeq.isEmptyPath(path)) return this.contents !== undefined;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path) : false;\n  }\n\n  set(key, value) {\n    assertCollection(this.contents);\n    this.contents.set(key, value);\n  }\n\n  setIn(path, value) {\n    if (resolveSeq.isEmptyPath(path)) this.contents = value;else {\n      assertCollection(this.contents);\n      this.contents.setIn(path, value);\n    }\n  }\n\n  setSchema(id, customTags) {\n    if (!id && !customTags && this.schema) return;\n    if (typeof id === 'number') id = id.toFixed(1);\n\n    if (id === '1.0' || id === '1.1' || id === '1.2') {\n      if (this.version) this.version = id;else this.options.version = id;\n      delete this.options.schema;\n    } else if (id && typeof id === 'string') {\n      this.options.schema = id;\n    }\n\n    if (Array.isArray(customTags)) this.options.customTags = customTags;\n    const opt = Object.assign({}, this.getDefaults(), this.options);\n    this.schema = new Schema.Schema(opt);\n  }\n\n  parse(node, prevDoc) {\n    if (this.options.keepCstNodes) this.cstNode = node;\n    if (this.options.keepNodeTypes) this.type = 'DOCUMENT';\n    const {\n      directives = [],\n      contents = [],\n      directivesEndMarker,\n      error,\n      valueRange\n    } = node;\n\n    if (error) {\n      if (!error.source) error.source = this;\n      this.errors.push(error);\n    }\n\n    parseDirectives(this, directives, prevDoc);\n    if (directivesEndMarker) this.directivesEndMarker = true;\n    this.range = valueRange ? [valueRange.start, valueRange.end] : null;\n    this.setSchema();\n    this.anchors._cstAliases = [];\n    parseContents(this, contents);\n    this.anchors.resolveNodes();\n\n    if (this.options.prettyErrors) {\n      for (const error of this.errors) if (error instanceof PlainValue.YAMLError) error.makePretty();\n\n      for (const warn of this.warnings) if (warn instanceof PlainValue.YAMLError) warn.makePretty();\n    }\n\n    return this;\n  }\n\n  listNonDefaultTags() {\n    return listTagNames(this.contents).filter(t => t.indexOf(Schema.Schema.defaultPrefix) !== 0);\n  }\n\n  setTagPrefix(handle, prefix) {\n    if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');\n\n    if (prefix) {\n      const prev = this.tagPrefixes.find(p => p.handle === handle);\n      if (prev) prev.prefix = prefix;else this.tagPrefixes.push({\n        handle,\n        prefix\n      });\n    } else {\n      this.tagPrefixes = this.tagPrefixes.filter(p => p.handle !== handle);\n    }\n  }\n\n  toJSON(arg, onAnchor) {\n    const {\n      keepBlobsInJSON,\n      mapAsMap,\n      maxAliasCount\n    } = this.options;\n    const keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof resolveSeq.Scalar));\n    const ctx = {\n      doc: this,\n      indentStep: '  ',\n      keep,\n      mapAsMap: keep && !!mapAsMap,\n      maxAliasCount,\n      stringify // Requiring directly in Pair would create circular dependencies\n\n    };\n    const anchorNames = Object.keys(this.anchors.map);\n    if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(name => [this.anchors.map[name], {\n      alias: [],\n      aliasCount: 0,\n      count: 1\n    }]));\n    const res = resolveSeq.toJSON(this.contents, arg, ctx);\n    if (typeof onAnchor === 'function' && ctx.anchors) for (const {\n      count,\n      res\n    } of ctx.anchors.values()) onAnchor(res, count);\n    return res;\n  }\n\n  toString() {\n    if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n    const indentSize = this.options.indent;\n\n    if (!Number.isInteger(indentSize) || indentSize <= 0) {\n      const s = JSON.stringify(indentSize);\n      throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n    }\n\n    this.setSchema();\n    const lines = [];\n    let hasDirectives = false;\n\n    if (this.version) {\n      let vd = '%YAML 1.2';\n\n      if (this.schema.name === 'yaml-1.1') {\n        if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';\n      }\n\n      lines.push(vd);\n      hasDirectives = true;\n    }\n\n    const tagNames = this.listNonDefaultTags();\n    this.tagPrefixes.forEach(({\n      handle,\n      prefix\n    }) => {\n      if (tagNames.some(t => t.indexOf(prefix) === 0)) {\n        lines.push(`%TAG ${handle} ${prefix}`);\n        hasDirectives = true;\n      }\n    });\n    if (hasDirectives || this.directivesEndMarker) lines.push('---');\n\n    if (this.commentBefore) {\n      if (hasDirectives || !this.directivesEndMarker) lines.unshift('');\n      lines.unshift(this.commentBefore.replace(/^/gm, '#'));\n    }\n\n    const ctx = {\n      anchors: {},\n      doc: this,\n      indent: '',\n      indentStep: ' '.repeat(indentSize),\n      stringify // Requiring directly in nodes would create circular dependencies\n\n    };\n    let chompKeep = false;\n    let contentComment = null;\n\n    if (this.contents) {\n      if (this.contents instanceof resolveSeq.Node) {\n        if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');\n        if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment\n\n        ctx.forceBlockIndent = !!this.comment;\n        contentComment = this.contents.comment;\n      }\n\n      const onChompKeep = contentComment ? null : () => chompKeep = true;\n      const body = stringify(this.contents, ctx, () => contentComment = null, onChompKeep);\n      lines.push(resolveSeq.addComment(body, '', contentComment));\n    } else if (this.contents !== undefined) {\n      lines.push(stringify(this.contents, ctx));\n    }\n\n    if (this.comment) {\n      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');\n      lines.push(this.comment.replace(/^/gm, '#'));\n    }\n\n    return lines.join('\\n') + '\\n';\n  }\n\n}\n\nPlainValue._defineProperty(Document, \"defaults\", documentOptions);\n\nexports.Document = Document;\nexports.defaultOptions = defaultOptions;\nexports.scalarOptions = scalarOptions;\n","'use strict';\n\nconst Char = {\n  ANCHOR: '&',\n  COMMENT: '#',\n  TAG: '!',\n  DIRECTIVES_END: '-',\n  DOCUMENT_END: '.'\n};\nconst Type = {\n  ALIAS: 'ALIAS',\n  BLANK_LINE: 'BLANK_LINE',\n  BLOCK_FOLDED: 'BLOCK_FOLDED',\n  BLOCK_LITERAL: 'BLOCK_LITERAL',\n  COMMENT: 'COMMENT',\n  DIRECTIVE: 'DIRECTIVE',\n  DOCUMENT: 'DOCUMENT',\n  FLOW_MAP: 'FLOW_MAP',\n  FLOW_SEQ: 'FLOW_SEQ',\n  MAP: 'MAP',\n  MAP_KEY: 'MAP_KEY',\n  MAP_VALUE: 'MAP_VALUE',\n  PLAIN: 'PLAIN',\n  QUOTE_DOUBLE: 'QUOTE_DOUBLE',\n  QUOTE_SINGLE: 'QUOTE_SINGLE',\n  SEQ: 'SEQ',\n  SEQ_ITEM: 'SEQ_ITEM'\n};\nconst defaultTagPrefix = 'tag:yaml.org,2002:';\nconst defaultTags = {\n  MAP: 'tag:yaml.org,2002:map',\n  SEQ: 'tag:yaml.org,2002:seq',\n  STR: 'tag:yaml.org,2002:str'\n};\n\nfunction findLineStarts(src) {\n  const ls = [0];\n  let offset = src.indexOf('\\n');\n\n  while (offset !== -1) {\n    offset += 1;\n    ls.push(offset);\n    offset = src.indexOf('\\n', offset);\n  }\n\n  return ls;\n}\n\nfunction getSrcInfo(cst) {\n  let lineStarts, src;\n\n  if (typeof cst === 'string') {\n    lineStarts = findLineStarts(cst);\n    src = cst;\n  } else {\n    if (Array.isArray(cst)) cst = cst[0];\n\n    if (cst && cst.context) {\n      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n      lineStarts = cst.lineStarts;\n      src = cst.context.src;\n    }\n  }\n\n  return {\n    lineStarts,\n    src\n  };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */\n\n/**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */\n\n\nfunction getLinePos(offset, cst) {\n  if (typeof offset !== 'number' || offset < 0) return null;\n  const {\n    lineStarts,\n    src\n  } = getSrcInfo(cst);\n  if (!lineStarts || !src || offset > src.length) return null;\n\n  for (let i = 0; i < lineStarts.length; ++i) {\n    const start = lineStarts[i];\n\n    if (offset < start) {\n      return {\n        line: i,\n        col: offset - lineStarts[i - 1] + 1\n      };\n    }\n\n    if (offset === start) return {\n      line: i + 1,\n      col: 1\n    };\n  }\n\n  const line = lineStarts.length;\n  return {\n    line,\n    col: offset - lineStarts[line - 1] + 1\n  };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */\n\nfunction getLine(line, cst) {\n  const {\n    lineStarts,\n    src\n  } = getSrcInfo(cst);\n  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n  const start = lineStarts[line - 1];\n  let end = lineStarts[line]; // undefined for last line; that's ok for slice()\n\n  while (end && end > start && src[end - 1] === '\\n') --end;\n\n  return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `…` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */\n\nfunction getPrettyContext({\n  start,\n  end\n}, cst, maxWidth = 80) {\n  let src = getLine(start.line, cst);\n  if (!src) return null;\n  let {\n    col\n  } = start;\n\n  if (src.length > maxWidth) {\n    if (col <= maxWidth - 10) {\n      src = src.substr(0, maxWidth - 1) + '…';\n    } else {\n      const halfWidth = Math.round(maxWidth / 2);\n      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '…';\n      col -= src.length - maxWidth;\n      src = '…' + src.substr(1 - maxWidth);\n    }\n  }\n\n  let errLen = 1;\n  let errEnd = '';\n\n  if (end) {\n    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n      errLen = end.col - start.col;\n    } else {\n      errLen = Math.min(src.length + 1, maxWidth) - col;\n      errEnd = '…';\n    }\n  }\n\n  const offset = col > 1 ? ' '.repeat(col - 1) : '';\n  const err = '^'.repeat(errLen);\n  return `${src}\\n${offset}${err}${errEnd}`;\n}\n\nclass Range {\n  static copy(orig) {\n    return new Range(orig.start, orig.end);\n  }\n\n  constructor(start, end) {\n    this.start = start;\n    this.end = end || start;\n  }\n\n  isEmpty() {\n    return typeof this.start !== 'number' || !this.end || this.end <= this.start;\n  }\n  /**\n   * Set `origStart` and `origEnd` to point to the original source range for\n   * this node, which may differ due to dropped CR characters.\n   *\n   * @param {number[]} cr - Positions of dropped CR characters\n   * @param {number} offset - Starting index of `cr` from the last call\n   * @returns {number} - The next offset, matching the one found for `origStart`\n   */\n\n\n  setOrigRange(cr, offset) {\n    const {\n      start,\n      end\n    } = this;\n\n    if (cr.length === 0 || end <= cr[0]) {\n      this.origStart = start;\n      this.origEnd = end;\n      return offset;\n    }\n\n    let i = offset;\n\n    while (i < cr.length) {\n      if (cr[i] > start) break;else ++i;\n    }\n\n    this.origStart = start + i;\n    const nextOffset = i;\n\n    while (i < cr.length) {\n      // if end was at \\n, it should now be at \\r\n      if (cr[i] >= end) break;else ++i;\n    }\n\n    this.origEnd = end + i;\n    return nextOffset;\n  }\n\n}\n\n/** Root class of all nodes */\n\nclass Node {\n  static addStringTerminator(src, offset, str) {\n    if (str[str.length - 1] === '\\n') return str;\n    const next = Node.endOfWhiteSpace(src, offset);\n    return next >= src.length || src[next] === '\\n' ? str + '\\n' : str;\n  } // ^(---|...)\n\n\n  static atDocumentBoundary(src, offset, sep) {\n    const ch0 = src[offset];\n    if (!ch0) return true;\n    const prev = src[offset - 1];\n    if (prev && prev !== '\\n') return false;\n\n    if (sep) {\n      if (ch0 !== sep) return false;\n    } else {\n      if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n    }\n\n    const ch1 = src[offset + 1];\n    const ch2 = src[offset + 2];\n    if (ch1 !== ch0 || ch2 !== ch0) return false;\n    const ch3 = src[offset + 3];\n    return !ch3 || ch3 === '\\n' || ch3 === '\\t' || ch3 === ' ';\n  }\n\n  static endOfIdentifier(src, offset) {\n    let ch = src[offset];\n    const isVerbatim = ch === '<';\n    const notOk = isVerbatim ? ['\\n', '\\t', ' ', '>'] : ['\\n', '\\t', ' ', '[', ']', '{', '}', ','];\n\n    while (ch && notOk.indexOf(ch) === -1) ch = src[offset += 1];\n\n    if (isVerbatim && ch === '>') offset += 1;\n    return offset;\n  }\n\n  static endOfIndent(src, offset) {\n    let ch = src[offset];\n\n    while (ch === ' ') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static endOfLine(src, offset) {\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static endOfWhiteSpace(src, offset) {\n    let ch = src[offset];\n\n    while (ch === '\\t' || ch === ' ') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static startOfLine(src, offset) {\n    let ch = src[offset - 1];\n    if (ch === '\\n') return offset;\n\n    while (ch && ch !== '\\n') ch = src[offset -= 1];\n\n    return offset + 1;\n  }\n  /**\n   * End of indentation, or null if the line's indent level is not more\n   * than `indent`\n   *\n   * @param {string} src\n   * @param {number} indent\n   * @param {number} lineStart\n   * @returns {?number}\n   */\n\n\n  static endOfBlockIndent(src, indent, lineStart) {\n    const inEnd = Node.endOfIndent(src, lineStart);\n\n    if (inEnd > lineStart + indent) {\n      return inEnd;\n    } else {\n      const wsEnd = Node.endOfWhiteSpace(src, inEnd);\n      const ch = src[wsEnd];\n      if (!ch || ch === '\\n') return wsEnd;\n    }\n\n    return null;\n  }\n\n  static atBlank(src, offset, endAsBlank) {\n    const ch = src[offset];\n    return ch === '\\n' || ch === '\\t' || ch === ' ' || endAsBlank && !ch;\n  }\n\n  static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n    if (!ch || indentDiff < 0) return false;\n    if (indentDiff > 0) return true;\n    return indicatorAsIndent && ch === '-';\n  } // should be at line or string end, or at next non-whitespace char\n\n\n  static normalizeOffset(src, offset) {\n    const ch = src[offset];\n    return !ch ? offset : ch !== '\\n' && src[offset - 1] === '\\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n  } // fold single newline into space, multiple newlines to N - 1 newlines\n  // presumes src[offset] === '\\n'\n\n\n  static foldNewline(src, offset, indent) {\n    let inCount = 0;\n    let error = false;\n    let fold = '';\n    let ch = src[offset + 1];\n\n    while (ch === ' ' || ch === '\\t' || ch === '\\n') {\n      switch (ch) {\n        case '\\n':\n          inCount = 0;\n          offset += 1;\n          fold += '\\n';\n          break;\n\n        case '\\t':\n          if (inCount <= indent) error = true;\n          offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n          break;\n\n        case ' ':\n          inCount += 1;\n          offset += 1;\n          break;\n      }\n\n      ch = src[offset + 1];\n    }\n\n    if (!fold) fold = ' ';\n    if (ch && inCount <= indent) error = true;\n    return {\n      fold,\n      offset,\n      error\n    };\n  }\n\n  constructor(type, props, context) {\n    Object.defineProperty(this, 'context', {\n      value: context || null,\n      writable: true\n    });\n    this.error = null;\n    this.range = null;\n    this.valueRange = null;\n    this.props = props || [];\n    this.type = type;\n    this.value = null;\n  }\n\n  getPropValue(idx, key, skipKey) {\n    if (!this.context) return null;\n    const {\n      src\n    } = this.context;\n    const prop = this.props[idx];\n    return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n  }\n\n  get anchor() {\n    for (let i = 0; i < this.props.length; ++i) {\n      const anchor = this.getPropValue(i, Char.ANCHOR, true);\n      if (anchor != null) return anchor;\n    }\n\n    return null;\n  }\n\n  get comment() {\n    const comments = [];\n\n    for (let i = 0; i < this.props.length; ++i) {\n      const comment = this.getPropValue(i, Char.COMMENT, true);\n      if (comment != null) comments.push(comment);\n    }\n\n    return comments.length > 0 ? comments.join('\\n') : null;\n  }\n\n  commentHasRequiredWhitespace(start) {\n    const {\n      src\n    } = this.context;\n    if (this.header && start === this.header.end) return false;\n    if (!this.valueRange) return false;\n    const {\n      end\n    } = this.valueRange;\n    return start !== end || Node.atBlank(src, end - 1);\n  }\n\n  get hasComment() {\n    if (this.context) {\n      const {\n        src\n      } = this.context;\n\n      for (let i = 0; i < this.props.length; ++i) {\n        if (src[this.props[i].start] === Char.COMMENT) return true;\n      }\n    }\n\n    return false;\n  }\n\n  get hasProps() {\n    if (this.context) {\n      const {\n        src\n      } = this.context;\n\n      for (let i = 0; i < this.props.length; ++i) {\n        if (src[this.props[i].start] !== Char.COMMENT) return true;\n      }\n    }\n\n    return false;\n  }\n\n  get includesTrailingLines() {\n    return false;\n  }\n\n  get jsonLike() {\n    const jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];\n    return jsonLikeTypes.indexOf(this.type) !== -1;\n  }\n\n  get rangeAsLinePos() {\n    if (!this.range || !this.context) return undefined;\n    const start = getLinePos(this.range.start, this.context.root);\n    if (!start) return undefined;\n    const end = getLinePos(this.range.end, this.context.root);\n    return {\n      start,\n      end\n    };\n  }\n\n  get rawValue() {\n    if (!this.valueRange || !this.context) return null;\n    const {\n      start,\n      end\n    } = this.valueRange;\n    return this.context.src.slice(start, end);\n  }\n\n  get tag() {\n    for (let i = 0; i < this.props.length; ++i) {\n      const tag = this.getPropValue(i, Char.TAG, false);\n\n      if (tag != null) {\n        if (tag[1] === '<') {\n          return {\n            verbatim: tag.slice(2, -1)\n          };\n        } else {\n          // eslint-disable-next-line no-unused-vars\n          const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);\n          return {\n            handle,\n            suffix\n          };\n        }\n      }\n    }\n\n    return null;\n  }\n\n  get valueRangeContainsNewline() {\n    if (!this.valueRange || !this.context) return false;\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      src\n    } = this.context;\n\n    for (let i = start; i < end; ++i) {\n      if (src[i] === '\\n') return true;\n    }\n\n    return false;\n  }\n\n  parseComment(start) {\n    const {\n      src\n    } = this.context;\n\n    if (src[start] === Char.COMMENT) {\n      const end = Node.endOfLine(src, start + 1);\n      const commentRange = new Range(start, end);\n      this.props.push(commentRange);\n      return end;\n    }\n\n    return start;\n  }\n  /**\n   * Populates the `origStart` and `origEnd` values of all ranges for this\n   * node. Extended by child classes to handle descendant nodes.\n   *\n   * @param {number[]} cr - Positions of dropped CR characters\n   * @param {number} offset - Starting index of `cr` from the last call\n   * @returns {number} - The next offset, matching the one found for `origStart`\n   */\n\n\n  setOrigRanges(cr, offset) {\n    if (this.range) offset = this.range.setOrigRange(cr, offset);\n    if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n    this.props.forEach(prop => prop.setOrigRange(cr, offset));\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const str = src.slice(range.start, range.end);\n    return Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass YAMLError extends Error {\n  constructor(name, source, message) {\n    if (!message || !(source instanceof Node)) throw new Error(`Invalid arguments for new ${name}`);\n    super();\n    this.name = name;\n    this.message = message;\n    this.source = source;\n  }\n\n  makePretty() {\n    if (!this.source) return;\n    this.nodeType = this.source.type;\n    const cst = this.source.context && this.source.context.root;\n\n    if (typeof this.offset === 'number') {\n      this.range = new Range(this.offset, this.offset + 1);\n      const start = cst && getLinePos(this.offset, cst);\n\n      if (start) {\n        const end = {\n          line: start.line,\n          col: start.col + 1\n        };\n        this.linePos = {\n          start,\n          end\n        };\n      }\n\n      delete this.offset;\n    } else {\n      this.range = this.source.range;\n      this.linePos = this.source.rangeAsLinePos;\n    }\n\n    if (this.linePos) {\n      const {\n        line,\n        col\n      } = this.linePos.start;\n      this.message += ` at line ${line}, column ${col}`;\n      const ctx = cst && getPrettyContext(this.linePos, cst);\n      if (ctx) this.message += `:\\n\\n${ctx}\\n`;\n    }\n\n    delete this.source;\n  }\n\n}\nclass YAMLReferenceError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLReferenceError', source, message);\n  }\n\n}\nclass YAMLSemanticError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLSemanticError', source, message);\n  }\n\n}\nclass YAMLSyntaxError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLSyntaxError', source, message);\n  }\n\n}\nclass YAMLWarning extends YAMLError {\n  constructor(source, message) {\n    super('YAMLWarning', source, message);\n  }\n\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass PlainValue extends Node {\n  static endOfLine(src, start, inFlow) {\n    let ch = src[start];\n    let offset = start;\n\n    while (ch && ch !== '\\n') {\n      if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;\n      const next = src[offset + 1];\n      if (ch === ':' && (!next || next === '\\n' || next === '\\t' || next === ' ' || inFlow && next === ',')) break;\n      if ((ch === ' ' || ch === '\\t') && next === '#') break;\n      offset += 1;\n      ch = next;\n    }\n\n    return offset;\n  }\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    let {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      src\n    } = this.context;\n    let ch = src[end - 1];\n\n    while (start < end && (ch === '\\n' || ch === '\\t' || ch === ' ')) ch = src[--end - 1];\n\n    let str = '';\n\n    for (let i = start; i < end; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        const {\n          fold,\n          offset\n        } = Node.foldNewline(src, i, -1);\n        str += fold;\n        i = offset;\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (i < end && (next === ' ' || next === '\\t')) {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    const ch0 = src[start];\n\n    switch (ch0) {\n      case '\\t':\n        {\n          const msg = 'Plain value cannot start with a tab character';\n          const errors = [new YAMLSemanticError(this, msg)];\n          return {\n            errors,\n            str\n          };\n        }\n\n      case '@':\n      case '`':\n        {\n          const msg = `Plain value cannot start with reserved character ${ch0}`;\n          const errors = [new YAMLSemanticError(this, msg)];\n          return {\n            errors,\n            str\n          };\n        }\n\n      default:\n        return str;\n    }\n  }\n\n  parseBlockValue(start) {\n    const {\n      indent,\n      inFlow,\n      src\n    } = this.context;\n    let offset = start;\n    let valueEnd = start;\n\n    for (let ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n      if (Node.atDocumentBoundary(src, offset + 1)) break;\n      const end = Node.endOfBlockIndent(src, indent, offset + 1);\n      if (end === null || src[end] === '#') break;\n\n      if (src[end] === '\\n') {\n        offset = end;\n      } else {\n        valueEnd = PlainValue.endOfLine(src, end, inFlow);\n        offset = valueEnd;\n      }\n    }\n\n    if (this.valueRange.isEmpty()) this.valueRange.start = start;\n    this.valueRange.end = valueEnd;\n    return valueEnd;\n  }\n  /**\n   * Parses a plain value from the source\n   *\n   * Accepted forms are:\n   * ```\n   * #comment\n   *\n   * first line\n   *\n   * first line #comment\n   *\n   * first line\n   * block\n   * lines\n   *\n   * #comment\n   * block\n   * lines\n   * ```\n   * where block lines are empty or have an indent level greater than `indent`.\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar, may be `\\n`\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      inFlow,\n      src\n    } = context;\n    let offset = start;\n    const ch = src[offset];\n\n    if (ch && ch !== '#' && ch !== '\\n') {\n      offset = PlainValue.endOfLine(src, start, inFlow);\n    }\n\n    this.valueRange = new Range(start, offset);\n    offset = Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n\n    if (!this.hasComment || this.valueRange.isEmpty()) {\n      offset = this.parseBlockValue(offset);\n    }\n\n    return offset;\n  }\n\n}\n\nexports.Char = Char;\nexports.Node = Node;\nexports.PlainValue = PlainValue;\nexports.Range = Range;\nexports.Type = Type;\nexports.YAMLError = YAMLError;\nexports.YAMLReferenceError = YAMLReferenceError;\nexports.YAMLSemanticError = YAMLSemanticError;\nexports.YAMLSyntaxError = YAMLSyntaxError;\nexports.YAMLWarning = YAMLWarning;\nexports._defineProperty = _defineProperty;\nexports.defaultTagPrefix = defaultTagPrefix;\nexports.defaultTags = defaultTags;\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-4a68b39b.js');\nvar warnings = require('./warnings-39684f17.js');\n\nfunction createMap(schema, obj, ctx) {\n  const map = new resolveSeq.YAMLMap(schema);\n\n  if (obj instanceof Map) {\n    for (const [key, value] of obj) map.items.push(schema.createPair(key, value, ctx));\n  } else if (obj && typeof obj === 'object') {\n    for (const key of Object.keys(obj)) map.items.push(schema.createPair(key, obj[key], ctx));\n  }\n\n  if (typeof schema.sortMapEntries === 'function') {\n    map.items.sort(schema.sortMapEntries);\n  }\n\n  return map;\n}\n\nconst map = {\n  createNode: createMap,\n  default: true,\n  nodeClass: resolveSeq.YAMLMap,\n  tag: 'tag:yaml.org,2002:map',\n  resolve: resolveSeq.resolveMap\n};\n\nfunction createSeq(schema, obj, ctx) {\n  const seq = new resolveSeq.YAMLSeq(schema);\n\n  if (obj && obj[Symbol.iterator]) {\n    for (const it of obj) {\n      const v = schema.createNode(it, ctx.wrapScalars, null, ctx);\n      seq.items.push(v);\n    }\n  }\n\n  return seq;\n}\n\nconst seq = {\n  createNode: createSeq,\n  default: true,\n  nodeClass: resolveSeq.YAMLSeq,\n  tag: 'tag:yaml.org,2002:seq',\n  resolve: resolveSeq.resolveSeq\n};\n\nconst string = {\n  identify: value => typeof value === 'string',\n  default: true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: resolveSeq.resolveString,\n\n  stringify(item, ctx, onComment, onChompKeep) {\n    ctx = Object.assign({\n      actualString: true\n    }, ctx);\n    return resolveSeq.stringifyString(item, ctx, onComment, onChompKeep);\n  },\n\n  options: resolveSeq.strOptions\n};\n\nconst failsafe = [map, seq, string];\n\n/* global BigInt */\n\nconst intIdentify = value => typeof value === 'bigint' || Number.isInteger(value);\n\nconst intResolve = (src, part, radix) => resolveSeq.intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);\n\nfunction intStringify(node, radix, prefix) {\n  const {\n    value\n  } = node;\n  if (intIdentify(value) && value >= 0) return prefix + value.toString(radix);\n  return resolveSeq.stringifyNumber(node);\n}\n\nconst nullObj = {\n  identify: value => value == null,\n  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: () => null,\n  options: resolveSeq.nullOptions,\n  stringify: () => resolveSeq.nullOptions.nullStr\n};\nconst boolObj = {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n  resolve: str => str[0] === 't' || str[0] === 'T',\n  options: resolveSeq.boolOptions,\n  stringify: ({\n    value\n  }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr\n};\nconst octObj = {\n  identify: value => intIdentify(value) && value >= 0,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^0o([0-7]+)$/,\n  resolve: (str, oct) => intResolve(str, oct, 8),\n  options: resolveSeq.intOptions,\n  stringify: node => intStringify(node, 8, '0o')\n};\nconst intObj = {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^[-+]?[0-9]+$/,\n  resolve: str => intResolve(str, str, 10),\n  options: resolveSeq.intOptions,\n  stringify: resolveSeq.stringifyNumber\n};\nconst hexObj = {\n  identify: value => intIdentify(value) && value >= 0,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^0x([0-9a-fA-F]+)$/,\n  resolve: (str, hex) => intResolve(str, hex, 16),\n  options: resolveSeq.intOptions,\n  stringify: node => intStringify(node, 16, '0x')\n};\nconst nanObj = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,\n  stringify: resolveSeq.stringifyNumber\n};\nconst expObj = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n  resolve: str => parseFloat(str),\n  stringify: ({\n    value\n  }) => Number(value).toExponential()\n};\nconst floatObj = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:\\.([0-9]+)|[0-9]+\\.([0-9]*))$/,\n\n  resolve(str, frac1, frac2) {\n    const frac = frac1 || frac2;\n    const node = new resolveSeq.Scalar(parseFloat(str));\n    if (frac && frac[frac.length - 1] === '0') node.minFractionDigits = frac.length;\n    return node;\n  },\n\n  stringify: resolveSeq.stringifyNumber\n};\nconst core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);\n\n/* global BigInt */\n\nconst intIdentify$1 = value => typeof value === 'bigint' || Number.isInteger(value);\n\nconst stringifyJSON = ({\n  value\n}) => JSON.stringify(value);\n\nconst json = [map, seq, {\n  identify: value => typeof value === 'string',\n  default: true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: resolveSeq.resolveString,\n  stringify: stringifyJSON\n}, {\n  identify: value => value == null,\n  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^null$/,\n  resolve: () => null,\n  stringify: stringifyJSON\n}, {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^true|false$/,\n  resolve: str => str === 'true',\n  stringify: stringifyJSON\n}, {\n  identify: intIdentify$1,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^-?(?:0|[1-9][0-9]*)$/,\n  resolve: str => resolveSeq.intOptions.asBigInt ? BigInt(str) : parseInt(str, 10),\n  stringify: ({\n    value\n  }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n  resolve: str => parseFloat(str),\n  stringify: stringifyJSON\n}];\n\njson.scalarFallback = str => {\n  throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str)}`);\n};\n\n/* global BigInt */\n\nconst boolStringify = ({\n  value\n}) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr;\n\nconst intIdentify$2 = value => typeof value === 'bigint' || Number.isInteger(value);\n\nfunction intResolve$1(sign, src, radix) {\n  let str = src.replace(/_/g, '');\n\n  if (resolveSeq.intOptions.asBigInt) {\n    switch (radix) {\n      case 2:\n        str = `0b${str}`;\n        break;\n\n      case 8:\n        str = `0o${str}`;\n        break;\n\n      case 16:\n        str = `0x${str}`;\n        break;\n    }\n\n    const n = BigInt(str);\n    return sign === '-' ? BigInt(-1) * n : n;\n  }\n\n  const n = parseInt(str, radix);\n  return sign === '-' ? -1 * n : n;\n}\n\nfunction intStringify$1(node, radix, prefix) {\n  const {\n    value\n  } = node;\n\n  if (intIdentify$2(value)) {\n    const str = value.toString(radix);\n    return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n  }\n\n  return resolveSeq.stringifyNumber(node);\n}\n\nconst yaml11 = failsafe.concat([{\n  identify: value => value == null,\n  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: () => null,\n  options: resolveSeq.nullOptions,\n  stringify: () => resolveSeq.nullOptions.nullStr\n}, {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n  resolve: () => true,\n  options: resolveSeq.boolOptions,\n  stringify: boolStringify\n}, {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,\n  resolve: () => false,\n  options: resolveSeq.boolOptions,\n  stringify: boolStringify\n}, {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'BIN',\n  test: /^([-+]?)0b([0-1_]+)$/,\n  resolve: (str, sign, bin) => intResolve$1(sign, bin, 2),\n  stringify: node => intStringify$1(node, 2, '0b')\n}, {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^([-+]?)0([0-7_]+)$/,\n  resolve: (str, sign, oct) => intResolve$1(sign, oct, 8),\n  stringify: node => intStringify$1(node, 8, '0')\n}, {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^([-+]?)([0-9][0-9_]*)$/,\n  resolve: (str, sign, abs) => intResolve$1(sign, abs, 10),\n  stringify: resolveSeq.stringifyNumber\n}, {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^([-+]?)0x([0-9a-fA-F_]+)$/,\n  resolve: (str, sign, hex) => intResolve$1(sign, hex, 16),\n  stringify: node => intStringify$1(node, 16, '0x')\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,\n  stringify: resolveSeq.stringifyNumber\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?([0-9][0-9_]*)?(\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n  resolve: str => parseFloat(str.replace(/_/g, '')),\n  stringify: ({\n    value\n  }) => Number(value).toExponential()\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:[0-9][0-9_]*)?\\.([0-9_]*)$/,\n\n  resolve(str, frac) {\n    const node = new resolveSeq.Scalar(parseFloat(str.replace(/_/g, '')));\n\n    if (frac) {\n      const f = frac.replace(/_/g, '');\n      if (f[f.length - 1] === '0') node.minFractionDigits = f.length;\n    }\n\n    return node;\n  },\n\n  stringify: resolveSeq.stringifyNumber\n}], warnings.binary, warnings.omap, warnings.pairs, warnings.set, warnings.intTime, warnings.floatTime, warnings.timestamp);\n\nconst schemas = {\n  core,\n  failsafe,\n  json,\n  yaml11\n};\nconst tags = {\n  binary: warnings.binary,\n  bool: boolObj,\n  float: floatObj,\n  floatExp: expObj,\n  floatNaN: nanObj,\n  floatTime: warnings.floatTime,\n  int: intObj,\n  intHex: hexObj,\n  intOct: octObj,\n  intTime: warnings.intTime,\n  map,\n  null: nullObj,\n  omap: warnings.omap,\n  pairs: warnings.pairs,\n  seq,\n  set: warnings.set,\n  timestamp: warnings.timestamp\n};\n\nfunction findTagObject(value, tagName, tags) {\n  if (tagName) {\n    const match = tags.filter(t => t.tag === tagName);\n    const tagObj = match.find(t => !t.format) || match[0];\n    if (!tagObj) throw new Error(`Tag ${tagName} not found`);\n    return tagObj;\n  } // TODO: deprecate/remove class check\n\n\n  return tags.find(t => (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format);\n}\n\nfunction createNode(value, tagName, ctx) {\n  if (value instanceof resolveSeq.Node) return value;\n  const {\n    defaultPrefix,\n    onTagObj,\n    prevObjects,\n    schema,\n    wrapScalars\n  } = ctx;\n  if (tagName && tagName.startsWith('!!')) tagName = defaultPrefix + tagName.slice(2);\n  let tagObj = findTagObject(value, tagName, schema.tags);\n\n  if (!tagObj) {\n    if (typeof value.toJSON === 'function') value = value.toJSON();\n    if (typeof value !== 'object') return wrapScalars ? new resolveSeq.Scalar(value) : value;\n    tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;\n  }\n\n  if (onTagObj) {\n    onTagObj(tagObj);\n    delete ctx.onTagObj;\n  } // Detect duplicate references to the same object & use Alias nodes for all\n  // after first. The `obj` wrapper allows for circular references to resolve.\n\n\n  const obj = {};\n\n  if (value && typeof value === 'object' && prevObjects) {\n    const prev = prevObjects.get(value);\n\n    if (prev) {\n      const alias = new resolveSeq.Alias(prev); // leaves source dirty; must be cleaned by caller\n\n      ctx.aliasNodes.push(alias); // defined along with prevObjects\n\n      return alias;\n    }\n\n    obj.value = value;\n    prevObjects.set(value, obj);\n  }\n\n  obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new resolveSeq.Scalar(value) : value;\n  if (tagName && obj.node instanceof resolveSeq.Node) obj.node.tag = tagName;\n  return obj.node;\n}\n\nfunction getSchemaTags(schemas, knownTags, customTags, schemaId) {\n  let tags = schemas[schemaId.replace(/\\W/g, '')]; // 'yaml-1.1' -> 'yaml11'\n\n  if (!tags) {\n    const keys = Object.keys(schemas).map(key => JSON.stringify(key)).join(', ');\n    throw new Error(`Unknown schema \"${schemaId}\"; use one of ${keys}`);\n  }\n\n  if (Array.isArray(customTags)) {\n    for (const tag of customTags) tags = tags.concat(tag);\n  } else if (typeof customTags === 'function') {\n    tags = customTags(tags.slice());\n  }\n\n  for (let i = 0; i < tags.length; ++i) {\n    const tag = tags[i];\n\n    if (typeof tag === 'string') {\n      const tagObj = knownTags[tag];\n\n      if (!tagObj) {\n        const keys = Object.keys(knownTags).map(key => JSON.stringify(key)).join(', ');\n        throw new Error(`Unknown custom tag \"${tag}\"; use one of ${keys}`);\n      }\n\n      tags[i] = tagObj;\n    }\n  }\n\n  return tags;\n}\n\nconst sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\n\nclass Schema {\n  // TODO: remove in v2\n  // TODO: remove in v2\n  constructor({\n    customTags,\n    merge,\n    schema,\n    sortMapEntries,\n    tags: deprecatedCustomTags\n  }) {\n    this.merge = !!merge;\n    this.name = schema;\n    this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;\n    if (!customTags && deprecatedCustomTags) warnings.warnOptionDeprecation('tags', 'customTags');\n    this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);\n  }\n\n  createNode(value, wrapScalars, tagName, ctx) {\n    const baseCtx = {\n      defaultPrefix: Schema.defaultPrefix,\n      schema: this,\n      wrapScalars\n    };\n    const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;\n    return createNode(value, tagName, createCtx);\n  }\n\n  createPair(key, value, ctx) {\n    if (!ctx) ctx = {\n      wrapScalars: true\n    };\n    const k = this.createNode(key, ctx.wrapScalars, null, ctx);\n    const v = this.createNode(value, ctx.wrapScalars, null, ctx);\n    return new resolveSeq.Pair(k, v);\n  }\n\n}\n\nPlainValue._defineProperty(Schema, \"defaultPrefix\", PlainValue.defaultTagPrefix);\n\nPlainValue._defineProperty(Schema, \"defaultTags\", PlainValue.defaultTags);\n\nexports.Schema = Schema;\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar parseCst = require('./parse-cst.js');\nrequire('./resolveSeq-4a68b39b.js');\nvar Document$1 = require('./Document-2cf6b08c.js');\nvar Schema = require('./Schema-42e9705c.js');\nvar warnings = require('./warnings-39684f17.js');\n\nfunction createNode(value, wrapScalars = true, tag) {\n  if (tag === undefined && typeof wrapScalars === 'string') {\n    tag = wrapScalars;\n    wrapScalars = true;\n  }\n\n  const options = Object.assign({}, Document$1.Document.defaults[Document$1.defaultOptions.version], Document$1.defaultOptions);\n  const schema = new Schema.Schema(options);\n  return schema.createNode(value, wrapScalars, tag);\n}\n\nclass Document extends Document$1.Document {\n  constructor(options) {\n    super(Object.assign({}, Document$1.defaultOptions, options));\n  }\n\n}\n\nfunction parseAllDocuments(src, options) {\n  const stream = [];\n  let prev;\n\n  for (const cstDoc of parseCst.parse(src)) {\n    const doc = new Document(options);\n    doc.parse(cstDoc, prev);\n    stream.push(doc);\n    prev = doc;\n  }\n\n  return stream;\n}\n\nfunction parseDocument(src, options) {\n  const cst = parseCst.parse(src);\n  const doc = new Document(options).parse(cst[0]);\n\n  if (cst.length > 1) {\n    const errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';\n    doc.errors.unshift(new PlainValue.YAMLSemanticError(cst[1], errMsg));\n  }\n\n  return doc;\n}\n\nfunction parse(src, options) {\n  const doc = parseDocument(src, options);\n  doc.warnings.forEach(warning => warnings.warn(warning));\n  if (doc.errors.length > 0) throw doc.errors[0];\n  return doc.toJSON();\n}\n\nfunction stringify(value, options) {\n  const doc = new Document(options);\n  doc.contents = value;\n  return String(doc);\n}\n\nconst YAML = {\n  createNode,\n  defaultOptions: Document$1.defaultOptions,\n  Document,\n  parse,\n  parseAllDocuments,\n  parseCST: parseCst.parse,\n  parseDocument,\n  scalarOptions: Document$1.scalarOptions,\n  stringify\n};\n\nexports.YAML = YAML;\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nclass BlankLine extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.BLANK_LINE);\n  }\n  /* istanbul ignore next */\n\n\n  get includesTrailingLines() {\n    // This is never called from anywhere, but if it were,\n    // this is the value it should return.\n    return true;\n  }\n  /**\n   * Parses a blank line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first \\n character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    this.range = new PlainValue.Range(start, start + 1);\n    return start + 1;\n  }\n\n}\n\nclass CollectionItem extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.node = null;\n  }\n\n  get includesTrailingLines() {\n    return !!this.node && this.node.includesTrailingLines;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context;\n    let {\n      atLineStart,\n      lineStart\n    } = context;\n    if (!atLineStart && this.type === PlainValue.Type.SEQ_ITEM) this.error = new PlainValue.YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');\n    const indent = atLineStart ? start - lineStart : context.indent;\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);\n    let ch = src[offset];\n    const inlineComment = ch === '#';\n    const comments = [];\n    let blankLine = null;\n\n    while (ch === '\\n' || ch === '#') {\n      if (ch === '#') {\n        const end = PlainValue.Node.endOfLine(src, offset + 1);\n        comments.push(new PlainValue.Range(offset, end));\n        offset = end;\n      } else {\n        atLineStart = true;\n        lineStart = offset + 1;\n        const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n\n        if (src[wsEnd] === '\\n' && comments.length === 0) {\n          blankLine = new BlankLine();\n          lineStart = blankLine.parse({\n            src\n          }, lineStart);\n        }\n\n        offset = PlainValue.Node.endOfIndent(src, lineStart);\n      }\n\n      ch = src[offset];\n    }\n\n    if (PlainValue.Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== PlainValue.Type.SEQ_ITEM)) {\n      this.node = parseNode({\n        atLineStart,\n        inCollection: false,\n        indent,\n        lineStart,\n        parent: this\n      }, offset);\n    } else if (ch && lineStart > start + 1) {\n      offset = lineStart - 1;\n    }\n\n    if (this.node) {\n      if (blankLine) {\n        // Only blank lines preceding non-empty nodes are captured. Note that\n        // this means that collection item range start indices do not always\n        // increase monotonically. -- eemeli/yaml#126\n        const items = context.parent.items || context.parent.contents;\n        if (items) items.push(blankLine);\n      }\n\n      if (comments.length) Array.prototype.push.apply(this.props, comments);\n      offset = this.node.range.end;\n    } else {\n      if (inlineComment) {\n        const c = comments[0];\n        this.props.push(c);\n        offset = c.end;\n      } else {\n        offset = PlainValue.Node.endOfLine(src, start + 1);\n      }\n    }\n\n    const end = this.node ? this.node.valueRange.end : offset;\n    this.valueRange = new PlainValue.Range(start, end);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      node,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass Comment extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.COMMENT);\n  }\n  /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const offset = this.parseComment(start);\n    this.range = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n}\n\nfunction grabCollectionEndComments(node) {\n  let cnode = node;\n\n  while (cnode instanceof CollectionItem) cnode = cnode.node;\n\n  if (!(cnode instanceof Collection)) return null;\n  const len = cnode.items.length;\n  let ci = -1;\n\n  for (let i = len - 1; i >= 0; --i) {\n    const n = cnode.items[i];\n\n    if (n.type === PlainValue.Type.COMMENT) {\n      // Keep sufficiently indented comments with preceding node\n      const {\n        indent,\n        lineStart\n      } = n.context;\n      if (indent > 0 && n.range.start >= lineStart + indent) break;\n      ci = i;\n    } else if (n.type === PlainValue.Type.BLANK_LINE) ci = i;else break;\n  }\n\n  if (ci === -1) return null;\n  const ca = cnode.items.splice(ci, len - ci);\n  const prevEnd = ca[0].range.start;\n\n  while (true) {\n    cnode.range.end = prevEnd;\n    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n    if (cnode === node) break;\n    cnode = cnode.context.parent;\n  }\n\n  return ca;\n}\nclass Collection extends PlainValue.Node {\n  static nextContentHasIndent(src, offset, indent) {\n    const lineStart = PlainValue.Node.endOfLine(src, offset) + 1;\n    offset = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n    const ch = src[offset];\n    if (!ch) return false;\n    if (offset >= lineStart + indent) return true;\n    if (ch !== '#' && ch !== '\\n') return false;\n    return Collection.nextContentHasIndent(src, offset, indent);\n  }\n\n  constructor(firstItem) {\n    super(firstItem.type === PlainValue.Type.SEQ_ITEM ? PlainValue.Type.SEQ : PlainValue.Type.MAP);\n\n    for (let i = firstItem.props.length - 1; i >= 0; --i) {\n      if (firstItem.props[i].start < firstItem.context.lineStart) {\n        // props on previous line are assumed by the collection\n        this.props = firstItem.props.slice(0, i + 1);\n        firstItem.props = firstItem.props.slice(i + 1);\n        const itemRange = firstItem.props[0] || firstItem.valueRange;\n        firstItem.range.start = itemRange.start;\n        break;\n      }\n    }\n\n    this.items = [firstItem];\n    const ec = grabCollectionEndComments(firstItem);\n    if (ec) Array.prototype.push.apply(this.items, ec);\n  }\n\n  get includesTrailingLines() {\n    return this.items.length > 0;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context; // It's easier to recalculate lineStart here rather than tracking down the\n    // last context from which to read it -- eemeli/yaml#2\n\n    let lineStart = PlainValue.Node.startOfLine(src, start);\n    const firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n    // -- eemeli/yaml#17\n\n    firstItem.context.parent = this;\n    this.valueRange = PlainValue.Range.copy(firstItem.valueRange);\n    const indent = firstItem.range.start - firstItem.context.lineStart;\n    let offset = start;\n    offset = PlainValue.Node.normalizeOffset(src, offset);\n    let ch = src[offset];\n    let atLineStart = PlainValue.Node.endOfWhiteSpace(src, lineStart) === offset;\n    let prevIncludesTrailingLines = false;\n\n    while (ch) {\n      while (ch === '\\n' || ch === '#') {\n        if (atLineStart && ch === '\\n' && !prevIncludesTrailingLines) {\n          const blankLine = new BlankLine();\n          offset = blankLine.parse({\n            src\n          }, offset);\n          this.valueRange.end = offset;\n\n          if (offset >= src.length) {\n            ch = null;\n            break;\n          }\n\n          this.items.push(blankLine);\n          offset -= 1; // blankLine.parse() consumes terminal newline\n        } else if (ch === '#') {\n          if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n            return offset;\n          }\n\n          const comment = new Comment();\n          offset = comment.parse({\n            indent,\n            lineStart,\n            src\n          }, offset);\n          this.items.push(comment);\n          this.valueRange.end = offset;\n\n          if (offset >= src.length) {\n            ch = null;\n            break;\n          }\n        }\n\n        lineStart = offset + 1;\n        offset = PlainValue.Node.endOfIndent(src, lineStart);\n\n        if (PlainValue.Node.atBlank(src, offset)) {\n          const wsEnd = PlainValue.Node.endOfWhiteSpace(src, offset);\n          const next = src[wsEnd];\n\n          if (!next || next === '\\n' || next === '#') {\n            offset = wsEnd;\n          }\n        }\n\n        ch = src[offset];\n        atLineStart = true;\n      }\n\n      if (!ch) {\n        break;\n      }\n\n      if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {\n        if (offset < lineStart + indent) {\n          if (lineStart > start) offset = lineStart;\n          break;\n        } else if (!this.error) {\n          const msg = 'All collection items must start at the same column';\n          this.error = new PlainValue.YAMLSyntaxError(this, msg);\n        }\n      }\n\n      if (firstItem.type === PlainValue.Type.SEQ_ITEM) {\n        if (ch !== '-') {\n          if (lineStart > start) offset = lineStart;\n          break;\n        }\n      } else if (ch === '-' && !this.error) {\n        // map key may start with -, as long as it's followed by a non-whitespace char\n        const next = src[offset + 1];\n\n        if (!next || next === '\\n' || next === '\\t' || next === ' ') {\n          const msg = 'A collection cannot be both a mapping and a sequence';\n          this.error = new PlainValue.YAMLSyntaxError(this, msg);\n        }\n      }\n\n      const node = parseNode({\n        atLineStart,\n        inCollection: true,\n        indent,\n        lineStart,\n        parent: this\n      }, offset);\n      if (!node) return offset; // at next document start\n\n      this.items.push(node);\n      this.valueRange.end = node.valueRange.end;\n      offset = PlainValue.Node.normalizeOffset(src, node.range.end);\n      ch = src[offset];\n      atLineStart = false;\n      prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n      // has advanced to check the current line's indentation level\n      // -- eemeli/yaml#10 & eemeli/yaml#38\n\n      if (ch) {\n        let ls = offset - 1;\n        let prev = src[ls];\n\n        while (prev === ' ' || prev === '\\t') prev = src[--ls];\n\n        if (prev === '\\n') {\n          lineStart = ls + 1;\n          atLineStart = true;\n        }\n      }\n\n      const ec = grabCollectionEndComments(node);\n      if (ec) Array.prototype.push.apply(this.items, ec);\n    }\n\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.items.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      items,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    let str = src.slice(range.start, items[0].range.start) + String(items[0]);\n\n    for (let i = 1; i < items.length; ++i) {\n      const item = items[i];\n      const {\n        atLineStart,\n        indent\n      } = item.context;\n      if (atLineStart) for (let i = 0; i < indent; ++i) str += ' ';\n      str += String(item);\n    }\n\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass Directive extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.DIRECTIVE);\n    this.name = null;\n  }\n\n  get parameters() {\n    const raw = this.rawValue;\n    return raw ? raw.trim().split(/[ \\t]+/) : [];\n  }\n\n  parseName(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start;\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n' && ch !== '\\t' && ch !== ' ') ch = src[offset += 1];\n\n    this.name = src.slice(start, offset);\n    return offset;\n  }\n\n  parseParameters(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start;\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n' && ch !== '#') ch = src[offset += 1];\n\n    this.valueRange = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n  parse(context, start) {\n    this.context = context;\n    let offset = this.parseName(start + 1);\n    offset = this.parseParameters(offset);\n    offset = this.parseComment(offset);\n    this.range = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n}\n\nclass Document extends PlainValue.Node {\n  static startCommentOrEndBlankLine(src, start) {\n    const offset = PlainValue.Node.endOfWhiteSpace(src, start);\n    const ch = src[offset];\n    return ch === '#' || ch === '\\n' ? offset : start;\n  }\n\n  constructor() {\n    super(PlainValue.Type.DOCUMENT);\n    this.directives = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.documentEndMarker = null;\n  }\n\n  parseDirectives(start) {\n    const {\n      src\n    } = this.context;\n    this.directives = [];\n    let atLineStart = true;\n    let hasDirectives = false;\n    let offset = start;\n\n    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DIRECTIVES_END)) {\n      offset = Document.startCommentOrEndBlankLine(src, offset);\n\n      switch (src[offset]) {\n        case '\\n':\n          if (atLineStart) {\n            const blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src\n            }, offset);\n\n            if (offset < src.length) {\n              this.directives.push(blankLine);\n            }\n          } else {\n            offset += 1;\n            atLineStart = true;\n          }\n\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.directives.push(comment);\n            atLineStart = false;\n          }\n          break;\n\n        case '%':\n          {\n            const directive = new Directive();\n            offset = directive.parse({\n              parent: this,\n              src\n            }, offset);\n            this.directives.push(directive);\n            hasDirectives = true;\n            atLineStart = false;\n          }\n          break;\n\n        default:\n          if (hasDirectives) {\n            this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');\n          } else if (this.directives.length > 0) {\n            this.contents = this.directives;\n            this.directives = [];\n          }\n\n          return offset;\n      }\n    }\n\n    if (src[offset]) {\n      this.directivesEndMarker = new PlainValue.Range(offset, offset + 3);\n      return offset + 3;\n    }\n\n    if (hasDirectives) {\n      this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');\n    } else if (this.directives.length > 0) {\n      this.contents = this.directives;\n      this.directives = [];\n    }\n\n    return offset;\n  }\n\n  parseContents(start) {\n    const {\n      parseNode,\n      src\n    } = this.context;\n    if (!this.contents) this.contents = [];\n    let lineStart = start;\n\n    while (src[lineStart - 1] === '-') lineStart -= 1;\n\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start);\n    let atLineStart = lineStart === start;\n    this.valueRange = new PlainValue.Range(offset);\n\n    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DOCUMENT_END)) {\n      switch (src[offset]) {\n        case '\\n':\n          if (atLineStart) {\n            const blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src\n            }, offset);\n\n            if (offset < src.length) {\n              this.contents.push(blankLine);\n            }\n          } else {\n            offset += 1;\n            atLineStart = true;\n          }\n\n          lineStart = offset;\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.contents.push(comment);\n            atLineStart = false;\n          }\n          break;\n\n        default:\n          {\n            const iEnd = PlainValue.Node.endOfIndent(src, offset);\n            const context = {\n              atLineStart,\n              indent: -1,\n              inFlow: false,\n              inCollection: false,\n              lineStart,\n              parent: this\n            };\n            const node = parseNode(context, iEnd);\n            if (!node) return this.valueRange.end = iEnd; // at next document start\n\n            this.contents.push(node);\n            offset = node.range.end;\n            atLineStart = false;\n            const ec = grabCollectionEndComments(node);\n            if (ec) Array.prototype.push.apply(this.contents, ec);\n          }\n      }\n\n      offset = Document.startCommentOrEndBlankLine(src, offset);\n    }\n\n    this.valueRange.end = offset;\n\n    if (src[offset]) {\n      this.documentEndMarker = new PlainValue.Range(offset, offset + 3);\n      offset += 3;\n\n      if (src[offset]) {\n        offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n\n        if (src[offset] === '#') {\n          const comment = new Comment();\n          offset = comment.parse({\n            src\n          }, offset);\n          this.contents.push(comment);\n        }\n\n        switch (src[offset]) {\n          case '\\n':\n            offset += 1;\n            break;\n\n          case undefined:\n            break;\n\n          default:\n            this.error = new PlainValue.YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');\n        }\n      }\n    }\n\n    return offset;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    context.root = this;\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n\n    offset = this.parseDirectives(offset);\n    offset = this.parseContents(offset);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.directives.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n    this.contents.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n    return offset;\n  }\n\n  toString() {\n    const {\n      contents,\n      directives,\n      value\n    } = this;\n    if (value != null) return value;\n    let str = directives.join('');\n\n    if (contents.length > 0) {\n      if (directives.length > 0 || contents[0].type === PlainValue.Type.COMMENT) str += '---\\n';\n      str += contents.join('');\n    }\n\n    if (str[str.length - 1] !== '\\n') str += '\\n';\n    return str;\n  }\n\n}\n\nclass Alias extends PlainValue.Node {\n  /**\n   * Parses an *alias from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = PlainValue.Node.endOfIdentifier(src, start + 1);\n    this.valueRange = new PlainValue.Range(start + 1, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nconst Chomp = {\n  CLIP: 'CLIP',\n  KEEP: 'KEEP',\n  STRIP: 'STRIP'\n};\nclass BlockValue extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.blockIndent = null;\n    this.chomping = Chomp.CLIP;\n    this.header = null;\n  }\n\n  get includesTrailingLines() {\n    return this.chomping === Chomp.KEEP;\n  }\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    let {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (this.valueRange.isEmpty()) return '';\n    let lastNewLine = null;\n    let ch = src[end - 1];\n\n    while (ch === '\\n' || ch === '\\t' || ch === ' ') {\n      end -= 1;\n\n      if (end <= start) {\n        if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens\n      }\n\n      if (ch === '\\n') lastNewLine = end;\n      ch = src[end - 1];\n    }\n\n    let keepStart = end + 1;\n\n    if (lastNewLine) {\n      if (this.chomping === Chomp.KEEP) {\n        keepStart = lastNewLine;\n        end = this.valueRange.end;\n      } else {\n        end = lastNewLine;\n      }\n    }\n\n    const bi = indent + this.blockIndent;\n    const folded = this.type === PlainValue.Type.BLOCK_FOLDED;\n    let atStart = true;\n    let str = '';\n    let sep = '';\n    let prevMoreIndented = false;\n\n    for (let i = start; i < end; ++i) {\n      for (let j = 0; j < bi; ++j) {\n        if (src[i] !== ' ') break;\n        i += 1;\n      }\n\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (sep === '\\n') str += '\\n';else sep = '\\n';\n      } else {\n        const lineEnd = PlainValue.Node.endOfLine(src, i);\n        const line = src.slice(i, lineEnd);\n        i = lineEnd;\n\n        if (folded && (ch === ' ' || ch === '\\t') && i < keepStart) {\n          if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && !atStart && sep === '\\n') sep = '\\n\\n';\n          str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n\n          sep = lineEnd < end && src[lineEnd] || '';\n          prevMoreIndented = true;\n        } else {\n          str += sep + line;\n          sep = folded && i < keepStart ? ' ' : '\\n';\n          prevMoreIndented = false;\n        }\n\n        if (atStart && line !== '') atStart = false;\n      }\n    }\n\n    return this.chomping === Chomp.STRIP ? str : str + '\\n';\n  }\n\n  parseBlockHeader(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start + 1;\n    let bi = '';\n\n    while (true) {\n      const ch = src[offset];\n\n      switch (ch) {\n        case '-':\n          this.chomping = Chomp.STRIP;\n          break;\n\n        case '+':\n          this.chomping = Chomp.KEEP;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          bi += ch;\n          break;\n\n        default:\n          this.blockIndent = Number(bi) || null;\n          this.header = new PlainValue.Range(start, offset);\n          return offset;\n      }\n\n      offset += 1;\n    }\n  }\n\n  parseBlockValue(start) {\n    const {\n      indent,\n      src\n    } = this.context;\n    const explicit = !!this.blockIndent;\n    let offset = start;\n    let valueEnd = start;\n    let minBlockIndent = 1;\n\n    for (let ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n      offset += 1;\n      if (PlainValue.Node.atDocumentBoundary(src, offset)) break;\n      const end = PlainValue.Node.endOfBlockIndent(src, indent, offset); // should not include tab?\n\n      if (end === null) break;\n      const ch = src[end];\n      const lineIndent = end - (offset + indent);\n\n      if (!this.blockIndent) {\n        // no explicit block indent, none yet detected\n        if (src[end] !== '\\n') {\n          // first line with non-whitespace content\n          if (lineIndent < minBlockIndent) {\n            const msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n            this.error = new PlainValue.YAMLSemanticError(this, msg);\n          }\n\n          this.blockIndent = lineIndent;\n        } else if (lineIndent > minBlockIndent) {\n          // empty line with more whitespace\n          minBlockIndent = lineIndent;\n        }\n      } else if (ch && ch !== '\\n' && lineIndent < this.blockIndent) {\n        if (src[end] === '#') break;\n\n        if (!this.error) {\n          const src = explicit ? 'explicit indentation indicator' : 'first line';\n          const msg = `Block scalars must not be less indented than their ${src}`;\n          this.error = new PlainValue.YAMLSemanticError(this, msg);\n        }\n      }\n\n      if (src[end] === '\\n') {\n        offset = end;\n      } else {\n        offset = valueEnd = PlainValue.Node.endOfLine(src, end);\n      }\n    }\n\n    if (this.chomping !== Chomp.KEEP) {\n      offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n    }\n\n    this.valueRange = new PlainValue.Range(start + 1, offset);\n    return offset;\n  }\n  /**\n   * Parses a block value from the source\n   *\n   * Accepted forms are:\n   * ```\n   * BS\n   * block\n   * lines\n   *\n   * BS #comment\n   * block\n   * lines\n   * ```\n   * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n   * are empty or have an indent level greater than `indent`.\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this block\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = this.parseBlockHeader(start);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    offset = this.parseBlockValue(offset);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    return this.header ? this.header.setOrigRange(cr, offset) : offset;\n  }\n\n}\n\nclass FlowCollection extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.items = null;\n  }\n\n  prevNodeIsJsonLike(idx = this.items.length) {\n    const node = this.items[idx - 1];\n    return !!node && (node.jsonLike || node.type === PlainValue.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context;\n    let {\n      indent,\n      lineStart\n    } = context;\n    let char = src[start]; // { or [\n\n    this.items = [{\n      char,\n      offset: start\n    }];\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);\n    char = src[offset];\n\n    while (char && char !== ']' && char !== '}') {\n      switch (char) {\n        case '\\n':\n          {\n            lineStart = offset + 1;\n            const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n\n            if (src[wsEnd] === '\\n') {\n              const blankLine = new BlankLine();\n              lineStart = blankLine.parse({\n                src\n              }, lineStart);\n              this.items.push(blankLine);\n            }\n\n            offset = PlainValue.Node.endOfIndent(src, lineStart);\n\n            if (offset <= lineStart + indent) {\n              char = src[offset];\n\n              if (offset < lineStart + indent || char !== ']' && char !== '}') {\n                const msg = 'Insufficient indentation in flow collection';\n                this.error = new PlainValue.YAMLSemanticError(this, msg);\n              }\n            }\n          }\n          break;\n\n        case ',':\n          {\n            this.items.push({\n              char,\n              offset\n            });\n            offset += 1;\n          }\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.items.push(comment);\n          }\n          break;\n\n        case '?':\n        case ':':\n          {\n            const next = src[offset + 1];\n\n            if (next === '\\n' || next === '\\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace\n            char === ':' && this.prevNodeIsJsonLike()) {\n              this.items.push({\n                char,\n                offset\n              });\n              offset += 1;\n              break;\n            }\n          }\n        // fallthrough\n\n        default:\n          {\n            const node = parseNode({\n              atLineStart: false,\n              inCollection: false,\n              inFlow: true,\n              indent: -1,\n              lineStart,\n              parent: this\n            }, offset);\n\n            if (!node) {\n              // at next document start\n              this.valueRange = new PlainValue.Range(start, offset);\n              return offset;\n            }\n\n            this.items.push(node);\n            offset = PlainValue.Node.normalizeOffset(src, node.range.end);\n          }\n      }\n\n      offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n      char = src[offset];\n    }\n\n    this.valueRange = new PlainValue.Range(start, offset + 1);\n\n    if (char) {\n      this.items.push({\n        char,\n        offset\n      });\n      offset = PlainValue.Node.endOfWhiteSpace(src, offset + 1);\n      offset = this.parseComment(offset);\n    }\n\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.items.forEach(node => {\n      if (node instanceof PlainValue.Node) {\n        offset = node.setOrigRanges(cr, offset);\n      } else if (cr.length === 0) {\n        node.origOffset = node.offset;\n      } else {\n        let i = offset;\n\n        while (i < cr.length) {\n          if (cr[i] > node.offset) break;else ++i;\n        }\n\n        node.origOffset = node.offset + i;\n        offset = i;\n      }\n    });\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      items,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const nodes = items.filter(item => item instanceof PlainValue.Node);\n    let str = '';\n    let prevEnd = range.start;\n    nodes.forEach(node => {\n      const prefix = src.slice(prevEnd, node.range.start);\n      prevEnd = node.range.end;\n      str += prefix + String(node);\n\n      if (str[str.length - 1] === '\\n' && src[prevEnd - 1] !== '\\n' && src[prevEnd] === '\\n') {\n        // Comment range does not include the terminal newline, but its\n        // stringified value does. Without this fix, newlines at comment ends\n        // get duplicated.\n        prevEnd += 1;\n      }\n    });\n    str += src.slice(prevEnd, range.end);\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass QuoteDouble extends PlainValue.Node {\n  static endOfQuote(src, offset) {\n    let ch = src[offset];\n\n    while (ch && ch !== '\"') {\n      offset += ch === '\\\\' ? 2 : 1;\n      ch = src[offset];\n    }\n\n    return offset + 1;\n  }\n  /**\n   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n   */\n\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    const errors = [];\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (src[end - 1] !== '\"') errors.push(new PlainValue.YAMLSyntaxError(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n    // escaped backslashes; also, this should be faster.\n\n    let str = '';\n\n    for (let i = start + 1; i < end - 1; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n        const {\n          fold,\n          offset,\n          error\n        } = PlainValue.Node.foldNewline(src, i, indent);\n        str += fold;\n        i = offset;\n        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));\n      } else if (ch === '\\\\') {\n        i += 1;\n\n        switch (src[i]) {\n          case '0':\n            str += '\\0';\n            break;\n          // null character\n\n          case 'a':\n            str += '\\x07';\n            break;\n          // bell character\n\n          case 'b':\n            str += '\\b';\n            break;\n          // backspace\n\n          case 'e':\n            str += '\\x1b';\n            break;\n          // escape character\n\n          case 'f':\n            str += '\\f';\n            break;\n          // form feed\n\n          case 'n':\n            str += '\\n';\n            break;\n          // line feed\n\n          case 'r':\n            str += '\\r';\n            break;\n          // carriage return\n\n          case 't':\n            str += '\\t';\n            break;\n          // horizontal tab\n\n          case 'v':\n            str += '\\v';\n            break;\n          // vertical tab\n\n          case 'N':\n            str += '\\u0085';\n            break;\n          // Unicode next line\n\n          case '_':\n            str += '\\u00a0';\n            break;\n          // Unicode non-breaking space\n\n          case 'L':\n            str += '\\u2028';\n            break;\n          // Unicode line separator\n\n          case 'P':\n            str += '\\u2029';\n            break;\n          // Unicode paragraph separator\n\n          case ' ':\n            str += ' ';\n            break;\n\n          case '\"':\n            str += '\"';\n            break;\n\n          case '/':\n            str += '/';\n            break;\n\n          case '\\\\':\n            str += '\\\\';\n            break;\n\n          case '\\t':\n            str += '\\t';\n            break;\n\n          case 'x':\n            str += this.parseCharCode(i + 1, 2, errors);\n            i += 2;\n            break;\n\n          case 'u':\n            str += this.parseCharCode(i + 1, 4, errors);\n            i += 4;\n            break;\n\n          case 'U':\n            str += this.parseCharCode(i + 1, 8, errors);\n            i += 8;\n            break;\n\n          case '\\n':\n            // skip escaped newlines, but still trim the following line\n            while (src[i + 1] === ' ' || src[i + 1] === '\\t') i += 1;\n\n            break;\n\n          default:\n            errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(i - 1, 2)}`));\n            str += '\\\\' + src[i];\n        }\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (next === ' ' || next === '\\t') {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    return errors.length > 0 ? {\n      errors,\n      str\n    } : str;\n  }\n\n  parseCharCode(offset, length, errors) {\n    const {\n      src\n    } = this.context;\n    const cc = src.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n\n    if (isNaN(code)) {\n      errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(offset - 2, length + 2)}`));\n      return src.substr(offset - 2, length + 2);\n    }\n\n    return String.fromCodePoint(code);\n  }\n  /**\n   * Parses a \"double quoted\" value from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = QuoteDouble.endOfQuote(src, start + 1);\n    this.valueRange = new PlainValue.Range(start, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nclass QuoteSingle extends PlainValue.Node {\n  static endOfQuote(src, offset) {\n    let ch = src[offset];\n\n    while (ch) {\n      if (ch === \"'\") {\n        if (src[offset + 1] !== \"'\") break;\n        ch = src[offset += 2];\n      } else {\n        ch = src[offset += 1];\n      }\n    }\n\n    return offset + 1;\n  }\n  /**\n   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n   */\n\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    const errors = [];\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (src[end - 1] !== \"'\") errors.push(new PlainValue.YAMLSyntaxError(this, \"Missing closing 'quote\"));\n    let str = '';\n\n    for (let i = start + 1; i < end - 1; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n        const {\n          fold,\n          offset,\n          error\n        } = PlainValue.Node.foldNewline(src, i, indent);\n        str += fold;\n        i = offset;\n        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));\n      } else if (ch === \"'\") {\n        str += ch;\n        i += 1;\n        if (src[i] !== \"'\") errors.push(new PlainValue.YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (next === ' ' || next === '\\t') {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    return errors.length > 0 ? {\n      errors,\n      str\n    } : str;\n  }\n  /**\n   * Parses a 'single quoted' value from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = QuoteSingle.endOfQuote(src, start + 1);\n    this.valueRange = new PlainValue.Range(start, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nfunction createNewNode(type, props) {\n  switch (type) {\n    case PlainValue.Type.ALIAS:\n      return new Alias(type, props);\n\n    case PlainValue.Type.BLOCK_FOLDED:\n    case PlainValue.Type.BLOCK_LITERAL:\n      return new BlockValue(type, props);\n\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.FLOW_SEQ:\n      return new FlowCollection(type, props);\n\n    case PlainValue.Type.MAP_KEY:\n    case PlainValue.Type.MAP_VALUE:\n    case PlainValue.Type.SEQ_ITEM:\n      return new CollectionItem(type, props);\n\n    case PlainValue.Type.COMMENT:\n    case PlainValue.Type.PLAIN:\n      return new PlainValue.PlainValue(type, props);\n\n    case PlainValue.Type.QUOTE_DOUBLE:\n      return new QuoteDouble(type, props);\n\n    case PlainValue.Type.QUOTE_SINGLE:\n      return new QuoteSingle(type, props);\n\n    /* istanbul ignore next */\n\n    default:\n      return null;\n    // should never happen\n  }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */\n\n\nclass ParseContext {\n  static parseType(src, offset, inFlow) {\n    switch (src[offset]) {\n      case '*':\n        return PlainValue.Type.ALIAS;\n\n      case '>':\n        return PlainValue.Type.BLOCK_FOLDED;\n\n      case '|':\n        return PlainValue.Type.BLOCK_LITERAL;\n\n      case '{':\n        return PlainValue.Type.FLOW_MAP;\n\n      case '[':\n        return PlainValue.Type.FLOW_SEQ;\n\n      case '?':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_KEY : PlainValue.Type.PLAIN;\n\n      case ':':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_VALUE : PlainValue.Type.PLAIN;\n\n      case '-':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.SEQ_ITEM : PlainValue.Type.PLAIN;\n\n      case '\"':\n        return PlainValue.Type.QUOTE_DOUBLE;\n\n      case \"'\":\n        return PlainValue.Type.QUOTE_SINGLE;\n\n      default:\n        return PlainValue.Type.PLAIN;\n    }\n  }\n\n  constructor(orig = {}, {\n    atLineStart,\n    inCollection,\n    inFlow,\n    indent,\n    lineStart,\n    parent\n  } = {}) {\n    PlainValue._defineProperty(this, \"parseNode\", (overlay, start) => {\n      if (PlainValue.Node.atDocumentBoundary(this.src, start)) return null;\n      const context = new ParseContext(this, overlay);\n      const {\n        props,\n        type,\n        valueStart\n      } = context.parseProps(start);\n      const node = createNewNode(type, props);\n      let offset = node.parse(context, valueStart);\n      node.range = new PlainValue.Range(start, offset);\n      /* istanbul ignore if */\n\n      if (offset <= start) {\n        // This should never happen, but if it does, let's make sure to at least\n        // step one character forward to avoid a busy loop.\n        node.error = new Error(`Node#parse consumed no characters`);\n        node.error.parseEnd = offset;\n        node.error.source = node;\n        node.range.end = start + 1;\n      }\n\n      if (context.nodeStartsCollection(node)) {\n        if (!node.error && !context.atLineStart && context.parent.type === PlainValue.Type.DOCUMENT) {\n          node.error = new PlainValue.YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');\n        }\n\n        const collection = new Collection(node);\n        offset = collection.parse(new ParseContext(context), offset);\n        collection.range = new PlainValue.Range(start, offset);\n        return collection;\n      }\n\n      return node;\n    });\n\n    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n    this.indent = indent != null ? indent : orig.indent;\n    this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n    this.parent = parent != null ? parent : orig.parent || {};\n    this.root = orig.root;\n    this.src = orig.src;\n  }\n\n  nodeStartsCollection(node) {\n    const {\n      inCollection,\n      inFlow,\n      src\n    } = this;\n    if (inCollection || inFlow) return false;\n    if (node instanceof CollectionItem) return true; // check for implicit key\n\n    let offset = node.range.end;\n    if (src[offset] === '\\n' || src[offset - 1] === '\\n') return false;\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    return src[offset] === ':';\n  } // Anchor and tag are before type, which determines the node implementation\n  // class; hence this intermediate step.\n\n\n  parseProps(offset) {\n    const {\n      inFlow,\n      parent,\n      src\n    } = this;\n    const props = [];\n    let lineHasProps = false;\n    offset = this.atLineStart ? PlainValue.Node.endOfIndent(src, offset) : PlainValue.Node.endOfWhiteSpace(src, offset);\n    let ch = src[offset];\n\n    while (ch === PlainValue.Char.ANCHOR || ch === PlainValue.Char.COMMENT || ch === PlainValue.Char.TAG || ch === '\\n') {\n      if (ch === '\\n') {\n        const lineStart = offset + 1;\n        const inEnd = PlainValue.Node.endOfIndent(src, lineStart);\n        const indentDiff = inEnd - (lineStart + this.indent);\n        const noIndicatorAsIndent = parent.type === PlainValue.Type.SEQ_ITEM && parent.context.atLineStart;\n        if (!PlainValue.Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n        this.atLineStart = true;\n        this.lineStart = lineStart;\n        lineHasProps = false;\n        offset = inEnd;\n      } else if (ch === PlainValue.Char.COMMENT) {\n        const end = PlainValue.Node.endOfLine(src, offset + 1);\n        props.push(new PlainValue.Range(offset, end));\n        offset = end;\n      } else {\n        let end = PlainValue.Node.endOfIdentifier(src, offset + 1);\n\n        if (ch === PlainValue.Char.TAG && src[end] === ',' && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, end + 13))) {\n          // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n          // than an empty but 'foo.bar' private-tagged node in a flow collection\n          // followed without whitespace by a plain string starting with a year\n          // or date divided by something.\n          end = PlainValue.Node.endOfIdentifier(src, end + 5);\n        }\n\n        props.push(new PlainValue.Range(offset, end));\n        lineHasProps = true;\n        offset = PlainValue.Node.endOfWhiteSpace(src, end);\n      }\n\n      ch = src[offset];\n    } // '- &a : b' has an anchor on an empty node\n\n\n    if (lineHasProps && ch === ':' && PlainValue.Node.atBlank(src, offset + 1, true)) offset -= 1;\n    const type = ParseContext.parseType(src, offset, inFlow);\n    return {\n      props,\n      type,\n      valueStart: offset\n    };\n  }\n  /**\n   * Parses a node from the source\n   * @param {ParseContext} overlay\n   * @param {number} start - Index of first non-whitespace character for the node\n   * @returns {?Node} - null if at a document boundary\n   */\n\n\n}\n\n// Published as 'yaml/parse-cst'\nfunction parse(src) {\n  const cr = [];\n\n  if (src.indexOf('\\r') !== -1) {\n    src = src.replace(/\\r\\n?/g, (match, offset) => {\n      if (match.length > 1) cr.push(offset);\n      return '\\n';\n    });\n  }\n\n  const documents = [];\n  let offset = 0;\n\n  do {\n    const doc = new Document();\n    const context = new ParseContext({\n      src\n    });\n    offset = doc.parse(context, offset);\n    documents.push(doc);\n  } while (offset < src.length);\n\n  documents.setOrigRanges = () => {\n    if (cr.length === 0) return false;\n\n    for (let i = 1; i < cr.length; ++i) cr[i] -= i;\n\n    let crOffset = 0;\n\n    for (let i = 0; i < documents.length; ++i) {\n      crOffset = documents[i].setOrigRanges(cr, crOffset);\n    }\n\n    cr.splice(0, cr.length);\n    return true;\n  };\n\n  documents.toString = () => documents.join('...\\n');\n\n  return documents;\n}\n\nexports.parse = parse;\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nfunction addCommentBefore(str, indent, comment) {\n  if (!comment) return str;\n  const cc = comment.replace(/[\\s\\S]^/gm, `$&${indent}#`);\n  return `#${cc}\\n${indent}${str}`;\n}\nfunction addComment(str, indent, comment) {\n  return !comment ? str : comment.indexOf('\\n') === -1 ? `${str} #${comment}` : `${str}\\n` + comment.replace(/^/gm, `${indent || ''}#`);\n}\n\nclass Node {}\n\nfunction toJSON(value, arg, ctx) {\n  if (Array.isArray(value)) return value.map((v, i) => toJSON(v, String(i), ctx));\n\n  if (value && typeof value.toJSON === 'function') {\n    const anchor = ctx && ctx.anchors && ctx.anchors.get(value);\n    if (anchor) ctx.onCreate = res => {\n      anchor.res = res;\n      delete ctx.onCreate;\n    };\n    const res = value.toJSON(arg, ctx);\n    if (anchor && ctx.onCreate) ctx.onCreate(res);\n    return res;\n  }\n\n  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);\n  return value;\n}\n\nclass Scalar extends Node {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n\n  toJSON(arg, ctx) {\n    return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);\n  }\n\n  toString() {\n    return String(this.value);\n  }\n\n}\n\nfunction collectionFromPath(schema, path, value) {\n  let v = value;\n\n  for (let i = path.length - 1; i >= 0; --i) {\n    const k = path[i];\n    const o = Number.isInteger(k) && k >= 0 ? [] : {};\n    o[k] = v;\n    v = o;\n  }\n\n  return schema.createNode(v, false);\n} // null, undefined, or an empty non-string iterable (e.g. [])\n\n\nconst isEmptyPath = path => path == null || typeof path === 'object' && path[Symbol.iterator]().next().done;\nclass Collection extends Node {\n  constructor(schema) {\n    super();\n\n    PlainValue._defineProperty(this, \"items\", []);\n\n    this.schema = schema;\n  }\n\n  addIn(path, value) {\n    if (isEmptyPath(path)) this.add(value);else {\n      const [key, ...rest] = path;\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  }\n\n  deleteIn([key, ...rest]) {\n    if (rest.length === 0) return this.delete(key);\n    const node = this.get(key, true);\n    if (node instanceof Collection) return node.deleteIn(rest);else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n  }\n\n  getIn([key, ...rest], keepScalar) {\n    const node = this.get(key, true);\n    if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;\n  }\n\n  hasAllNullValues() {\n    return this.items.every(node => {\n      if (!node || node.type !== 'PAIR') return false;\n      const n = node.value;\n      return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;\n    });\n  }\n\n  hasIn([key, ...rest]) {\n    if (rest.length === 0) return this.has(key);\n    const node = this.get(key, true);\n    return node instanceof Collection ? node.hasIn(rest) : false;\n  }\n\n  setIn([key, ...rest], value) {\n    if (rest.length === 0) {\n      this.set(key, value);\n    } else {\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  } // overridden in implementations\n\n  /* istanbul ignore next */\n\n\n  toJSON() {\n    return null;\n  }\n\n  toString(ctx, {\n    blockItem,\n    flowChars,\n    isMap,\n    itemIndent\n  }, onComment, onChompKeep) {\n    const {\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;\n    if (inFlow) itemIndent += indentStep;\n    const allNullValues = isMap && this.hasAllNullValues();\n    ctx = Object.assign({}, ctx, {\n      allNullValues,\n      indent: itemIndent,\n      inFlow,\n      type: null\n    });\n    let chompKeep = false;\n    let hasItemWithNewLine = false;\n    const nodes = this.items.reduce((nodes, item, i) => {\n      let comment;\n\n      if (item) {\n        if (!chompKeep && item.spaceBefore) nodes.push({\n          type: 'comment',\n          str: ''\n        });\n        if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(line => {\n          nodes.push({\n            type: 'comment',\n            str: `#${line}`\n          });\n        });\n        if (item.comment) comment = item.comment;\n        if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;\n      }\n\n      chompKeep = false;\n      let str = stringify(item, ctx, () => comment = null, () => chompKeep = true);\n      if (inFlow && !hasItemWithNewLine && str.includes('\\n')) hasItemWithNewLine = true;\n      if (inFlow && i < this.items.length - 1) str += ',';\n      str = addComment(str, itemIndent, comment);\n      if (chompKeep && (comment || inFlow)) chompKeep = false;\n      nodes.push({\n        type: 'item',\n        str\n      });\n      return nodes;\n    }, []);\n    let str;\n\n    if (nodes.length === 0) {\n      str = flowChars.start + flowChars.end;\n    } else if (inFlow) {\n      const {\n        start,\n        end\n      } = flowChars;\n      const strings = nodes.map(n => n.str);\n\n      if (hasItemWithNewLine || strings.reduce((sum, str) => sum + str.length + 2, 2) > Collection.maxFlowStringSingleLineLength) {\n        str = start;\n\n        for (const s of strings) {\n          str += s ? `\\n${indentStep}${indent}${s}` : '\\n';\n        }\n\n        str += `\\n${indent}${end}`;\n      } else {\n        str = `${start} ${strings.join(' ')} ${end}`;\n      }\n    } else {\n      const strings = nodes.map(blockItem);\n      str = strings.shift();\n\n      for (const s of strings) str += s ? `\\n${indent}${s}` : '\\n';\n    }\n\n    if (this.comment) {\n      str += '\\n' + this.comment.replace(/^/gm, `${indent}#`);\n      if (onComment) onComment();\n    } else if (chompKeep && onChompKeep) onChompKeep();\n\n    return str;\n  }\n\n}\n\nPlainValue._defineProperty(Collection, \"maxFlowStringSingleLineLength\", 60);\n\nfunction asItemIndex(key) {\n  let idx = key instanceof Scalar ? key.value : key;\n  if (idx && typeof idx === 'string') idx = Number(idx);\n  return Number.isInteger(idx) && idx >= 0 ? idx : null;\n}\n\nclass YAMLSeq extends Collection {\n  add(value) {\n    this.items.push(value);\n  }\n\n  delete(key) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return false;\n    const del = this.items.splice(idx, 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return undefined;\n    const it = this.items[idx];\n    return !keepScalar && it instanceof Scalar ? it.value : it;\n  }\n\n  has(key) {\n    const idx = asItemIndex(key);\n    return typeof idx === 'number' && idx < this.items.length;\n  }\n\n  set(key, value) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') throw new Error(`Expected a valid index, not ${key}.`);\n    this.items[idx] = value;\n  }\n\n  toJSON(_, ctx) {\n    const seq = [];\n    if (ctx && ctx.onCreate) ctx.onCreate(seq);\n    let i = 0;\n\n    for (const item of this.items) seq.push(toJSON(item, String(i++), ctx));\n\n    return seq;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n    return super.toString(ctx, {\n      blockItem: n => n.type === 'comment' ? n.str : `- ${n.str}`,\n      flowChars: {\n        start: '[',\n        end: ']'\n      },\n      isMap: false,\n      itemIndent: (ctx.indent || '') + '  '\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst stringifyKey = (key, jsKey, ctx) => {\n  if (jsKey === null) return '';\n  if (typeof jsKey !== 'object') return String(jsKey);\n  if (key instanceof Node && ctx && ctx.doc) return key.toString({\n    anchors: {},\n    doc: ctx.doc,\n    indent: '',\n    indentStep: ctx.indentStep,\n    inFlow: true,\n    inStringifyKey: true,\n    stringify: ctx.stringify\n  });\n  return JSON.stringify(jsKey);\n};\n\nclass Pair extends Node {\n  constructor(key, value = null) {\n    super();\n    this.key = key;\n    this.value = value;\n    this.type = Pair.Type.PAIR;\n  }\n\n  get commentBefore() {\n    return this.key instanceof Node ? this.key.commentBefore : undefined;\n  }\n\n  set commentBefore(cb) {\n    if (this.key == null) this.key = new Scalar(null);\n    if (this.key instanceof Node) this.key.commentBefore = cb;else {\n      const msg = 'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.';\n      throw new Error(msg);\n    }\n  }\n\n  addToJSMap(ctx, map) {\n    const key = toJSON(this.key, '', ctx);\n\n    if (map instanceof Map) {\n      const value = toJSON(this.value, key, ctx);\n      map.set(key, value);\n    } else if (map instanceof Set) {\n      map.add(key);\n    } else {\n      const stringKey = stringifyKey(this.key, key, ctx);\n      map[stringKey] = toJSON(this.value, stringKey, ctx);\n    }\n\n    return map;\n  }\n\n  toJSON(_, ctx) {\n    const pair = ctx && ctx.mapAsMap ? new Map() : {};\n    return this.addToJSMap(ctx, pair);\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx || !ctx.doc) return JSON.stringify(this);\n    const {\n      indent: indentSize,\n      indentSeq,\n      simpleKeys\n    } = ctx.doc.options;\n    let {\n      key,\n      value\n    } = this;\n    let keyComment = key instanceof Node && key.comment;\n\n    if (simpleKeys) {\n      if (keyComment) {\n        throw new Error('With simple keys, key nodes cannot have comments');\n      }\n\n      if (key instanceof Collection) {\n        const msg = 'With simple keys, collection cannot be used as a key value';\n        throw new Error(msg);\n      }\n    }\n\n    const explicitKey = !simpleKeys && (!key || keyComment || key instanceof Collection || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL);\n    const {\n      doc,\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    ctx = Object.assign({}, ctx, {\n      implicitKey: !explicitKey,\n      indent: indent + indentStep\n    });\n    let chompKeep = false;\n    let str = stringify(key, ctx, () => keyComment = null, () => chompKeep = true);\n    str = addComment(str, ctx.indent, keyComment);\n\n    if (ctx.allNullValues && !simpleKeys) {\n      if (this.comment) {\n        str = addComment(str, ctx.indent, this.comment);\n        if (onComment) onComment();\n      } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();\n\n      return ctx.inFlow ? str : `? ${str}`;\n    }\n\n    str = explicitKey ? `? ${str}\\n${indent}:` : `${str}:`;\n\n    if (this.comment) {\n      // expected (but not strictly required) to be a single-line comment\n      str = addComment(str, ctx.indent, this.comment);\n      if (onComment) onComment();\n    }\n\n    let vcb = '';\n    let valueComment = null;\n\n    if (value instanceof Node) {\n      if (value.spaceBefore) vcb = '\\n';\n\n      if (value.commentBefore) {\n        const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);\n        vcb += `\\n${cs}`;\n      }\n\n      valueComment = value.comment;\n    } else if (value && typeof value === 'object') {\n      value = doc.schema.createNode(value, true);\n    }\n\n    ctx.implicitKey = false;\n    if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n\n    if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {\n      // If indentSeq === false, consider '- ' as part of indentation where possible\n      ctx.indent = ctx.indent.substr(2);\n    }\n\n    const valueStr = stringify(value, ctx, () => valueComment = null, () => chompKeep = true);\n    let ws = ' ';\n\n    if (vcb || this.comment) {\n      ws = `${vcb}\\n${ctx.indent}`;\n    } else if (!explicitKey && value instanceof Collection) {\n      const flow = valueStr[0] === '[' || valueStr[0] === '{';\n      if (!flow || valueStr.includes('\\n')) ws = `\\n${ctx.indent}`;\n    }\n\n    if (chompKeep && !valueComment && onChompKeep) onChompKeep();\n    return addComment(str + ws + valueStr, ctx.indent, valueComment);\n  }\n\n}\n\nPlainValue._defineProperty(Pair, \"Type\", {\n  PAIR: 'PAIR',\n  MERGE_PAIR: 'MERGE_PAIR'\n});\n\nconst getAliasCount = (node, anchors) => {\n  if (node instanceof Alias) {\n    const anchor = anchors.get(node.source);\n    return anchor.count * anchor.aliasCount;\n  } else if (node instanceof Collection) {\n    let count = 0;\n\n    for (const item of node.items) {\n      const c = getAliasCount(item, anchors);\n      if (c > count) count = c;\n    }\n\n    return count;\n  } else if (node instanceof Pair) {\n    const kc = getAliasCount(node.key, anchors);\n    const vc = getAliasCount(node.value, anchors);\n    return Math.max(kc, vc);\n  }\n\n  return 1;\n};\n\nclass Alias extends Node {\n  static stringify({\n    range,\n    source\n  }, {\n    anchors,\n    doc,\n    implicitKey,\n    inStringifyKey\n  }) {\n    let anchor = Object.keys(anchors).find(a => anchors[a] === source);\n    if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();\n    if (anchor) return `*${anchor}${implicitKey ? ' ' : ''}`;\n    const msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';\n    throw new Error(`${msg} [${range}]`);\n  }\n\n  constructor(source) {\n    super();\n    this.source = source;\n    this.type = PlainValue.Type.ALIAS;\n  }\n\n  set tag(t) {\n    throw new Error('Alias nodes cannot have tags');\n  }\n\n  toJSON(arg, ctx) {\n    if (!ctx) return toJSON(this.source, arg, ctx);\n    const {\n      anchors,\n      maxAliasCount\n    } = ctx;\n    const anchor = anchors.get(this.source);\n    /* istanbul ignore if */\n\n    if (!anchor || anchor.res === undefined) {\n      const msg = 'This should not happen: Alias anchor was not resolved?';\n      if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n    }\n\n    if (maxAliasCount >= 0) {\n      anchor.count += 1;\n      if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);\n\n      if (anchor.count * anchor.aliasCount > maxAliasCount) {\n        const msg = 'Excessive alias count indicates a resource exhaustion attack';\n        if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n      }\n    }\n\n    return anchor.res;\n  } // Only called when stringifying an alias mapping key while constructing\n  // Object output.\n\n\n  toString(ctx) {\n    return Alias.stringify(this, ctx);\n  }\n\n}\n\nPlainValue._defineProperty(Alias, \"default\", true);\n\nfunction findPair(items, key) {\n  const k = key instanceof Scalar ? key.value : key;\n\n  for (const it of items) {\n    if (it instanceof Pair) {\n      if (it.key === key || it.key === k) return it;\n      if (it.key && it.key.value === k) return it;\n    }\n  }\n\n  return undefined;\n}\nclass YAMLMap extends Collection {\n  add(pair, overwrite) {\n    if (!pair) pair = new Pair(pair);else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);\n    const prev = findPair(this.items, pair.key);\n    const sortEntries = this.schema && this.schema.sortMapEntries;\n\n    if (prev) {\n      if (overwrite) prev.value = pair.value;else throw new Error(`Key ${pair.key} already set`);\n    } else if (sortEntries) {\n      const i = this.items.findIndex(item => sortEntries(pair, item) < 0);\n      if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);\n    } else {\n      this.items.push(pair);\n    }\n  }\n\n  delete(key) {\n    const it = findPair(this.items, key);\n    if (!it) return false;\n    const del = this.items.splice(this.items.indexOf(it), 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const it = findPair(this.items, key);\n    const node = it && it.value;\n    return !keepScalar && node instanceof Scalar ? node.value : node;\n  }\n\n  has(key) {\n    return !!findPair(this.items, key);\n  }\n\n  set(key, value) {\n    this.add(new Pair(key, value), true);\n  }\n  /**\n   * @param {*} arg ignored\n   * @param {*} ctx Conversion context, originally set in Document#toJSON()\n   * @param {Class} Type If set, forces the returned collection type\n   * @returns {*} Instance of Type, Map, or Object\n   */\n\n\n  toJSON(_, ctx, Type) {\n    const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};\n    if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n    for (const item of this.items) item.addToJSMap(ctx, map);\n\n    return map;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n\n    for (const item of this.items) {\n      if (!(item instanceof Pair)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n    }\n\n    return super.toString(ctx, {\n      blockItem: n => n.str,\n      flowChars: {\n        start: '{',\n        end: '}'\n      },\n      isMap: true,\n      itemIndent: ctx.indent || ''\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst MERGE_KEY = '<<';\nclass Merge extends Pair {\n  constructor(pair) {\n    if (pair instanceof Pair) {\n      let seq = pair.value;\n\n      if (!(seq instanceof YAMLSeq)) {\n        seq = new YAMLSeq();\n        seq.items.push(pair.value);\n        seq.range = pair.value.range;\n      }\n\n      super(pair.key, seq);\n      this.range = pair.range;\n    } else {\n      super(new Scalar(MERGE_KEY), new YAMLSeq());\n    }\n\n    this.type = Pair.Type.MERGE_PAIR;\n  } // If the value associated with a merge key is a single mapping node, each of\n  // its key/value pairs is inserted into the current mapping, unless the key\n  // already exists in it. If the value associated with the merge key is a\n  // sequence, then this sequence is expected to contain mapping nodes and each\n  // of these nodes is merged in turn according to its order in the sequence.\n  // Keys in mapping nodes earlier in the sequence override keys specified in\n  // later mapping nodes. -- http://yaml.org/type/merge.html\n\n\n  addToJSMap(ctx, map) {\n    for (const {\n      source\n    } of this.value.items) {\n      if (!(source instanceof YAMLMap)) throw new Error('Merge sources must be maps');\n      const srcMap = source.toJSON(null, ctx, Map);\n\n      for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n          if (!map.has(key)) map.set(key, value);\n        } else if (map instanceof Set) {\n          map.add(key);\n        } else {\n          if (!Object.prototype.hasOwnProperty.call(map, key)) map[key] = value;\n        }\n      }\n    }\n\n    return map;\n  }\n\n  toString(ctx, onComment) {\n    const seq = this.value;\n    if (seq.items.length > 1) return super.toString(ctx, onComment);\n    this.value = seq.items[0];\n    const str = super.toString(ctx, onComment);\n    this.value = seq;\n    return str;\n  }\n\n}\n\nconst binaryOptions = {\n  defaultType: PlainValue.Type.BLOCK_LITERAL,\n  lineWidth: 76\n};\nconst boolOptions = {\n  trueStr: 'true',\n  falseStr: 'false'\n};\nconst intOptions = {\n  asBigInt: false\n};\nconst nullOptions = {\n  nullStr: 'null'\n};\nconst strOptions = {\n  defaultType: PlainValue.Type.PLAIN,\n  doubleQuoted: {\n    jsonEncoding: false,\n    minMultiLineLength: 40\n  },\n  fold: {\n    lineWidth: 80,\n    minContentWidth: 20\n  }\n};\n\nfunction resolveScalar(str, tags, scalarFallback) {\n  for (const {\n    format,\n    test,\n    resolve\n  } of tags) {\n    if (test) {\n      const match = str.match(test);\n\n      if (match) {\n        let res = resolve.apply(null, match);\n        if (!(res instanceof Scalar)) res = new Scalar(res);\n        if (format) res.format = format;\n        return res;\n      }\n    }\n  }\n\n  if (scalarFallback) str = scalarFallback(str);\n  return new Scalar(str);\n}\n\nconst FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line\n// returns index of last newline in more-indented block\n\nconst consumeMoreIndentedLines = (text, i) => {\n  let ch = text[i + 1];\n\n  while (ch === ' ' || ch === '\\t') {\n    do {\n      ch = text[i += 1];\n    } while (ch && ch !== '\\n');\n\n    ch = text[i + 1];\n  }\n\n  return i;\n};\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n *\n * @param {string} text\n * @param {string} indent\n * @param {string} [mode='flow'] `'block'` prevents more-indented lines\n *   from being folded; `'quoted'` allows for `\\` escapes, including escaped\n *   newlines\n * @param {Object} options\n * @param {number} [options.indentAtStart] Accounts for leading contents on\n *   the first line, defaulting to `indent.length`\n * @param {number} [options.lineWidth=80]\n * @param {number} [options.minContentWidth=20] Allow highly indented lines to\n *   stretch the line width\n * @param {function} options.onFold Called once if the text is folded\n * @param {function} options.onFold Called once if any line of text exceeds\n *   lineWidth characters\n */\n\n\nfunction foldFlowLines(text, indent, mode, {\n  indentAtStart,\n  lineWidth = 80,\n  minContentWidth = 20,\n  onFold,\n  onOverflow\n}) {\n  if (!lineWidth || lineWidth < 0) return text;\n  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n  if (text.length <= endStep) return text;\n  const folds = [];\n  const escapedFolds = {};\n  let end = lineWidth - (typeof indentAtStart === 'number' ? indentAtStart : indent.length);\n  let split = undefined;\n  let prev = undefined;\n  let overflow = false;\n  let i = -1;\n\n  if (mode === FOLD_BLOCK) {\n    i = consumeMoreIndentedLines(text, i);\n    if (i !== -1) end = i + endStep;\n  }\n\n  for (let ch; ch = text[i += 1];) {\n    if (mode === FOLD_QUOTED && ch === '\\\\') {\n      switch (text[i + 1]) {\n        case 'x':\n          i += 3;\n          break;\n\n        case 'u':\n          i += 5;\n          break;\n\n        case 'U':\n          i += 9;\n          break;\n\n        default:\n          i += 1;\n      }\n    }\n\n    if (ch === '\\n') {\n      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);\n      end = i + endStep;\n      split = undefined;\n    } else {\n      if (ch === ' ' && prev && prev !== ' ' && prev !== '\\n' && prev !== '\\t') {\n        // space surrounded by non-space can be replaced with newline + indent\n        const next = text[i + 1];\n        if (next && next !== ' ' && next !== '\\n' && next !== '\\t') split = i;\n      }\n\n      if (i >= end) {\n        if (split) {\n          folds.push(split);\n          end = split + endStep;\n          split = undefined;\n        } else if (mode === FOLD_QUOTED) {\n          // white-space collected at end may stretch past lineWidth\n          while (prev === ' ' || prev === '\\t') {\n            prev = ch;\n            ch = text[i += 1];\n            overflow = true;\n          } // i - 2 accounts for not-dropped last char + newline-escaping \\\n\n\n          folds.push(i - 2);\n          escapedFolds[i - 2] = true;\n          end = i - 2 + endStep;\n          split = undefined;\n        } else {\n          overflow = true;\n        }\n      }\n    }\n\n    prev = ch;\n  }\n\n  if (overflow && onOverflow) onOverflow();\n  if (folds.length === 0) return text;\n  if (onFold) onFold();\n  let res = text.slice(0, folds[0]);\n\n  for (let i = 0; i < folds.length; ++i) {\n    const fold = folds[i];\n    const end = folds[i + 1] || text.length;\n    if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\\\`;\n    res += `\\n${indent}${text.slice(fold + 1, end)}`;\n  }\n\n  return res;\n}\n\nconst getFoldOptions = ({\n  indentAtStart\n}) => indentAtStart ? Object.assign({\n  indentAtStart\n}, strOptions.fold) : strOptions.fold; // Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\n\n\nconst containsDocumentMarker = str => /^(%|---|\\.\\.\\.)/m.test(str);\n\nfunction lineLengthOverLimit(str, limit) {\n  const strLen = str.length;\n  if (strLen <= limit) return false;\n\n  for (let i = 0, start = 0; i < strLen; ++i) {\n    if (str[i] === '\\n') {\n      if (i - start > limit) return true;\n      start = i + 1;\n      if (strLen - start <= limit) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction doubleQuotedString(value, ctx) {\n  const {\n    implicitKey\n  } = ctx;\n  const {\n    jsonEncoding,\n    minMultiLineLength\n  } = strOptions.doubleQuoted;\n  const json = JSON.stringify(value);\n  if (jsonEncoding) return json;\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  let str = '';\n  let start = 0;\n\n  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\n    if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n      // space before newline needs to be escaped to not be folded\n      str += json.slice(start, i) + '\\\\ ';\n      i += 1;\n      start = i;\n      ch = '\\\\';\n    }\n\n    if (ch === '\\\\') switch (json[i + 1]) {\n      case 'u':\n        {\n          str += json.slice(start, i);\n          const code = json.substr(i + 2, 4);\n\n          switch (code) {\n            case '0000':\n              str += '\\\\0';\n              break;\n\n            case '0007':\n              str += '\\\\a';\n              break;\n\n            case '000b':\n              str += '\\\\v';\n              break;\n\n            case '001b':\n              str += '\\\\e';\n              break;\n\n            case '0085':\n              str += '\\\\N';\n              break;\n\n            case '00a0':\n              str += '\\\\_';\n              break;\n\n            case '2028':\n              str += '\\\\L';\n              break;\n\n            case '2029':\n              str += '\\\\P';\n              break;\n\n            default:\n              if (code.substr(0, 2) === '00') str += '\\\\x' + code.substr(2);else str += json.substr(i, 6);\n          }\n\n          i += 5;\n          start = i + 1;\n        }\n        break;\n\n      case 'n':\n        if (implicitKey || json[i + 2] === '\"' || json.length < minMultiLineLength) {\n          i += 1;\n        } else {\n          // folding will eat first newline\n          str += json.slice(start, i) + '\\n\\n';\n\n          while (json[i + 2] === '\\\\' && json[i + 3] === 'n' && json[i + 4] !== '\"') {\n            str += '\\n';\n            i += 2;\n          }\n\n          str += indent; // space after newline needs to be escaped to not be folded\n\n          if (json[i + 2] === ' ') str += '\\\\';\n          i += 1;\n          start = i + 1;\n        }\n\n        break;\n\n      default:\n        i += 1;\n    }\n  }\n\n  str = start ? str + json.slice(start) : json;\n  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));\n}\n\nfunction singleQuotedString(value, ctx) {\n  if (ctx.implicitKey) {\n    if (/\\n/.test(value)) return doubleQuotedString(value, ctx);\n  } else {\n    // single quoted string can't have leading or trailing whitespace around newline\n    if (/[ \\t]\\n|\\n[ \\t]/.test(value)) return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));\n}\n\nfunction blockString({\n  comment,\n  type,\n  value\n}, ctx, onComment, onChompKeep) {\n  // 1. Block can't end in whitespace unless the last line is non-empty.\n  // 2. Strings consisting of only whitespace are best rendered explicitly.\n  if (/\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n  const indentSize = indent ? '2' : '1'; // root is at -1\n\n  const literal = type === PlainValue.Type.BLOCK_FOLDED ? false : type === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth - indent.length);\n  let header = literal ? '|' : '>';\n  if (!value) return header + '\\n';\n  let wsStart = '';\n  let wsEnd = '';\n  value = value.replace(/[\\n\\t ]*$/, ws => {\n    const n = ws.indexOf('\\n');\n\n    if (n === -1) {\n      header += '-'; // strip\n    } else if (value === ws || n !== ws.length - 1) {\n      header += '+'; // keep\n\n      if (onChompKeep) onChompKeep();\n    }\n\n    wsEnd = ws.replace(/\\n$/, '');\n    return '';\n  }).replace(/^[\\n ]*/, ws => {\n    if (ws.indexOf(' ') !== -1) header += indentSize;\n    const m = ws.match(/ +$/);\n\n    if (m) {\n      wsStart = ws.slice(0, -m[0].length);\n      return m[0];\n    } else {\n      wsStart = ws;\n      return '';\n    }\n  });\n  if (wsEnd) wsEnd = wsEnd.replace(/\\n+(?!\\n|$)/g, `$&${indent}`);\n  if (wsStart) wsStart = wsStart.replace(/\\n+/g, `$&${indent}`);\n\n  if (comment) {\n    header += ' #' + comment.replace(/ ?[\\r\\n]+/g, ' ');\n    if (onComment) onComment();\n  }\n\n  if (!value) return `${header}${indentSize}\\n${indent}${wsEnd}`;\n\n  if (literal) {\n    value = value.replace(/\\n+/g, `$&${indent}`);\n    return `${header}\\n${indent}${wsStart}${value}${wsEnd}`;\n  }\n\n  value = value.replace(/\\n+/g, '\\n$&').replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent\n  .replace(/\\n+/g, `$&${indent}`);\n  const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);\n  return `${header}\\n${indent}${body}`;\n}\n\nfunction plainString(item, ctx, onComment, onChompKeep) {\n  const {\n    comment,\n    type,\n    value\n  } = item;\n  const {\n    actualString,\n    implicitKey,\n    indent,\n    inFlow\n  } = ctx;\n\n  if (implicitKey && /[\\n[\\]{},]/.test(value) || inFlow && /[[\\]{},]/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  if (!value || /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n    // not allowed:\n    // - empty string, '-' or '?'\n    // - start with an indicator character (except [?:-]) or /[?-] /\n    // - '\\n ', ': ' or ' \\n' anywhere\n    // - '#' not preceded by a non-space char\n    // - end with ' ' or ':'\n    return implicitKey || inFlow || value.indexOf('\\n') === -1 ? value.indexOf('\"') !== -1 && value.indexOf(\"'\") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (!implicitKey && !inFlow && type !== PlainValue.Type.PLAIN && value.indexOf('\\n') !== -1) {\n    // Where allowed & type not set explicitly, prefer block style for multiline strings\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (indent === '' && containsDocumentMarker(value)) {\n    ctx.forceBlockIndent = true;\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  const str = value.replace(/\\n+/g, `$&\\n${indent}`); // Verify that output will be parsed as a string, as e.g. plain numbers and\n  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n  // and others in v1.1.\n\n  if (actualString) {\n    const {\n      tags\n    } = ctx.doc.schema;\n    const resolved = resolveScalar(str, tags, tags.scalarFallback).value;\n    if (typeof resolved !== 'string') return doubleQuotedString(value, ctx);\n  }\n\n  const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));\n\n  if (comment && !inFlow && (body.indexOf('\\n') !== -1 || comment.indexOf('\\n') !== -1)) {\n    if (onComment) onComment();\n    return addCommentBefore(body, indent, comment);\n  }\n\n  return body;\n}\n\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n  const {\n    defaultType\n  } = strOptions;\n  const {\n    implicitKey,\n    inFlow\n  } = ctx;\n  let {\n    type,\n    value\n  } = item;\n\n  if (typeof value !== 'string') {\n    value = String(value);\n    item = Object.assign({}, item, {\n      value\n    });\n  }\n\n  const _stringify = _type => {\n    switch (_type) {\n      case PlainValue.Type.BLOCK_FOLDED:\n      case PlainValue.Type.BLOCK_LITERAL:\n        return blockString(item, ctx, onComment, onChompKeep);\n\n      case PlainValue.Type.QUOTE_DOUBLE:\n        return doubleQuotedString(value, ctx);\n\n      case PlainValue.Type.QUOTE_SINGLE:\n        return singleQuotedString(value, ctx);\n\n      case PlainValue.Type.PLAIN:\n        return plainString(item, ctx, onComment, onChompKeep);\n\n      default:\n        return null;\n    }\n  };\n\n  if (type !== PlainValue.Type.QUOTE_DOUBLE && /[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f]/.test(value)) {\n    // force double quotes on control characters\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  } else if ((implicitKey || inFlow) && (type === PlainValue.Type.BLOCK_FOLDED || type === PlainValue.Type.BLOCK_LITERAL)) {\n    // should not happen; blocks are not valid inside flow containers\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  }\n\n  let res = _stringify(type);\n\n  if (res === null) {\n    res = _stringify(defaultType);\n    if (res === null) throw new Error(`Unsupported default string type ${defaultType}`);\n  }\n\n  return res;\n}\n\nfunction stringifyNumber({\n  format,\n  minFractionDigits,\n  tag,\n  value\n}) {\n  if (typeof value === 'bigint') return String(value);\n  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';\n  let n = JSON.stringify(value);\n\n  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\\d/.test(n)) {\n    let i = n.indexOf('.');\n\n    if (i < 0) {\n      i = n.length;\n      n += '.';\n    }\n\n    let d = minFractionDigits - (n.length - i - 1);\n\n    while (d-- > 0) n += '0';\n  }\n\n  return n;\n}\n\nfunction checkFlowCollectionEnd(errors, cst) {\n  let char, name;\n\n  switch (cst.type) {\n    case PlainValue.Type.FLOW_MAP:\n      char = '}';\n      name = 'flow map';\n      break;\n\n    case PlainValue.Type.FLOW_SEQ:\n      char = ']';\n      name = 'flow sequence';\n      break;\n\n    default:\n      errors.push(new PlainValue.YAMLSemanticError(cst, 'Not a flow collection!?'));\n      return;\n  }\n\n  let lastItem;\n\n  for (let i = cst.items.length - 1; i >= 0; --i) {\n    const item = cst.items[i];\n\n    if (!item || item.type !== PlainValue.Type.COMMENT) {\n      lastItem = item;\n      break;\n    }\n  }\n\n  if (lastItem && lastItem.char !== char) {\n    const msg = `Expected ${name} to end with ${char}`;\n    let err;\n\n    if (typeof lastItem.offset === 'number') {\n      err = new PlainValue.YAMLSemanticError(cst, msg);\n      err.offset = lastItem.offset + 1;\n    } else {\n      err = new PlainValue.YAMLSemanticError(lastItem, msg);\n      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;\n    }\n\n    errors.push(err);\n  }\n}\nfunction checkFlowCommentSpace(errors, comment) {\n  const prev = comment.context.src[comment.range.start - 1];\n\n  if (prev !== '\\n' && prev !== '\\t' && prev !== ' ') {\n    const msg = 'Comments must be separated from other tokens by white space characters';\n    errors.push(new PlainValue.YAMLSemanticError(comment, msg));\n  }\n}\nfunction getLongKeyError(source, key) {\n  const sk = String(key);\n  const k = sk.substr(0, 8) + '...' + sk.substr(-8);\n  return new PlainValue.YAMLSemanticError(source, `The \"${k}\" key is too long`);\n}\nfunction resolveComments(collection, comments) {\n  for (const {\n    afterKey,\n    before,\n    comment\n  } of comments) {\n    let item = collection.items[before];\n\n    if (!item) {\n      if (comment !== undefined) {\n        if (collection.comment) collection.comment += '\\n' + comment;else collection.comment = comment;\n      }\n    } else {\n      if (afterKey && item.value) item = item.value;\n\n      if (comment === undefined) {\n        if (afterKey || !item.commentBefore) item.spaceBefore = true;\n      } else {\n        if (item.commentBefore) item.commentBefore += '\\n' + comment;else item.commentBefore = comment;\n      }\n    }\n  }\n}\n\n// on error, will return { str: string, errors: Error[] }\nfunction resolveString(doc, node) {\n  const res = node.strValue;\n  if (!res) return '';\n  if (typeof res === 'string') return res;\n  res.errors.forEach(error => {\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n  });\n  return res.str;\n}\n\nfunction resolveTagHandle(doc, node) {\n  const {\n    handle,\n    suffix\n  } = node.tag;\n  let prefix = doc.tagPrefixes.find(p => p.handle === handle);\n\n  if (!prefix) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    if (dtp) prefix = dtp.find(p => p.handle === handle);\n    if (!prefix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag handle is non-default and was not declared.`);\n  }\n\n  if (!suffix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);\n\n  if (handle === '!' && (doc.version || doc.options.version) === '1.0') {\n    if (suffix[0] === '^') {\n      doc.warnings.push(new PlainValue.YAMLWarning(node, 'YAML 1.0 ^ tag expansion is not supported'));\n      return suffix;\n    }\n\n    if (/[:/]/.test(suffix)) {\n      // word/foo -> tag:word.yaml.org,2002:foo\n      const vocab = suffix.match(/^([a-z0-9-]+)\\/(.*)/i);\n      return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;\n    }\n  }\n\n  return prefix.prefix + decodeURIComponent(suffix);\n}\n\nfunction resolveTagName(doc, node) {\n  const {\n    tag,\n    type\n  } = node;\n  let nonSpecific = false;\n\n  if (tag) {\n    const {\n      handle,\n      suffix,\n      verbatim\n    } = tag;\n\n    if (verbatim) {\n      if (verbatim !== '!' && verbatim !== '!!') return verbatim;\n      const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;\n      doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n    } else if (handle === '!' && !suffix) {\n      nonSpecific = true;\n    } else {\n      try {\n        return resolveTagHandle(doc, node);\n      } catch (error) {\n        doc.errors.push(error);\n      }\n    }\n  }\n\n  switch (type) {\n    case PlainValue.Type.BLOCK_FOLDED:\n    case PlainValue.Type.BLOCK_LITERAL:\n    case PlainValue.Type.QUOTE_DOUBLE:\n    case PlainValue.Type.QUOTE_SINGLE:\n      return PlainValue.defaultTags.STR;\n\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    case PlainValue.Type.PLAIN:\n      return nonSpecific ? PlainValue.defaultTags.STR : null;\n\n    default:\n      return null;\n  }\n}\n\nfunction resolveByTagName(doc, node, tagName) {\n  const {\n    tags\n  } = doc.schema;\n  const matchWithTest = [];\n\n  for (const tag of tags) {\n    if (tag.tag === tagName) {\n      if (tag.test) matchWithTest.push(tag);else {\n        const res = tag.resolve(doc, node);\n        return res instanceof Collection ? res : new Scalar(res);\n      }\n    }\n  }\n\n  const str = resolveString(doc, node);\n  if (typeof str === 'string' && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags.scalarFallback);\n  return null;\n}\n\nfunction getFallbackTagName({\n  type\n}) {\n  switch (type) {\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    default:\n      return PlainValue.defaultTags.STR;\n  }\n}\n\nfunction resolveTag(doc, node, tagName) {\n  try {\n    const res = resolveByTagName(doc, node, tagName);\n\n    if (res) {\n      if (tagName && node.tag) res.tag = tagName;\n      return res;\n    }\n  } catch (error) {\n    /* istanbul ignore if */\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n    return null;\n  }\n\n  try {\n    const fallback = getFallbackTagName(node);\n    if (!fallback) throw new Error(`The tag ${tagName} is unavailable`);\n    const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(node, msg));\n    const res = resolveByTagName(doc, node, fallback);\n    res.tag = tagName;\n    return res;\n  } catch (error) {\n    const refError = new PlainValue.YAMLReferenceError(node, error.message);\n    refError.stack = error.stack;\n    doc.errors.push(refError);\n    return null;\n  }\n}\n\nconst isCollectionItem = node => {\n  if (!node) return false;\n  const {\n    type\n  } = node;\n  return type === PlainValue.Type.MAP_KEY || type === PlainValue.Type.MAP_VALUE || type === PlainValue.Type.SEQ_ITEM;\n};\n\nfunction resolveNodeProps(errors, node) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let hasAnchor = false;\n  let hasTag = false;\n  const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;\n\n  for (const {\n    start,\n    end\n  } of props) {\n    switch (node.context.src[start]) {\n      case PlainValue.Char.COMMENT:\n        {\n          if (!node.commentHasRequiredWhitespace(start)) {\n            const msg = 'Comments must be separated from other tokens by white space characters';\n            errors.push(new PlainValue.YAMLSemanticError(node, msg));\n          }\n\n          const {\n            header,\n            valueRange\n          } = node;\n          const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;\n          cc.push(node.context.src.slice(start + 1, end));\n          break;\n        }\n      // Actual anchor & tag resolution is handled by schema, here we just complain\n\n      case PlainValue.Char.ANCHOR:\n        if (hasAnchor) {\n          const msg = 'A node can have at most one anchor';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasAnchor = true;\n        break;\n\n      case PlainValue.Char.TAG:\n        if (hasTag) {\n          const msg = 'A node can have at most one tag';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasTag = true;\n        break;\n    }\n  }\n\n  return {\n    comments,\n    hasAnchor,\n    hasTag\n  };\n}\n\nfunction resolveNodeValue(doc, node) {\n  const {\n    anchors,\n    errors,\n    schema\n  } = doc;\n\n  if (node.type === PlainValue.Type.ALIAS) {\n    const name = node.rawValue;\n    const src = anchors.getNode(name);\n\n    if (!src) {\n      const msg = `Aliased anchor not found: ${name}`;\n      errors.push(new PlainValue.YAMLReferenceError(node, msg));\n      return null;\n    } // Lazy resolution for circular references\n\n\n    const res = new Alias(src);\n\n    anchors._cstAliases.push(res);\n\n    return res;\n  }\n\n  const tagName = resolveTagName(doc, node);\n  if (tagName) return resolveTag(doc, node, tagName);\n\n  if (node.type !== PlainValue.Type.PLAIN) {\n    const msg = `Failed to resolve ${node.type} node here`;\n    errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n    return null;\n  }\n\n  try {\n    const str = resolveString(doc, node);\n    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);\n  } catch (error) {\n    if (!error.source) error.source = node;\n    errors.push(error);\n    return null;\n  }\n} // sets node.resolved on success\n\n\nfunction resolveNode(doc, node) {\n  if (!node) return null;\n  if (node.error) doc.errors.push(node.error);\n  const {\n    comments,\n    hasAnchor,\n    hasTag\n  } = resolveNodeProps(doc.errors, node);\n\n  if (hasAnchor) {\n    const {\n      anchors\n    } = doc;\n    const name = node.anchor;\n    const prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor\n    // name have already been resolved, so it may safely be renamed.\n\n    if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as\n    // anchors need to be available during resolution to allow for\n    // circular references.\n\n    anchors.map[name] = node;\n  }\n\n  if (node.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {\n    const msg = 'An alias node must not specify any properties';\n    doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n  }\n\n  const res = resolveNodeValue(doc, node);\n\n  if (res) {\n    res.range = [node.range.start, node.range.end];\n    if (doc.options.keepCstNodes) res.cstNode = node;\n    if (doc.options.keepNodeTypes) res.type = node.type;\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      res.commentBefore = res.commentBefore ? `${res.commentBefore}\\n${cb}` : cb;\n    }\n\n    const ca = comments.after.join('\\n');\n    if (ca) res.comment = res.comment ? `${res.comment}\\n${ca}` : ca;\n  }\n\n  return node.resolved = res;\n}\n\nfunction resolveMap(doc, cst) {\n  if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {\n    const msg = `A ${cst.type} node cannot be resolved as a mapping`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);\n  const map = new YAMLMap();\n  map.items = items;\n  resolveComments(map, comments);\n  let hasCollectionKey = false;\n\n  for (let i = 0; i < items.length; ++i) {\n    const {\n      key: iKey\n    } = items[i];\n    if (iKey instanceof Collection) hasCollectionKey = true;\n\n    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {\n      items[i] = new Merge(items[i]);\n      const sources = items[i].value.items;\n      let error = null;\n      sources.some(node => {\n        if (node instanceof Alias) {\n          // During parsing, alias sources are CST nodes; to account for\n          // circular references their resolved values can't be used here.\n          const {\n            type\n          } = node.source;\n          if (type === PlainValue.Type.MAP || type === PlainValue.Type.FLOW_MAP) return false;\n          return error = 'Merge nodes aliases can only point to maps';\n        }\n\n        return error = 'Merge nodes can only have Alias nodes as values';\n      });\n      if (error) doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));\n    } else {\n      for (let j = i + 1; j < items.length; ++j) {\n        const {\n          key: jKey\n        } = items[j];\n\n        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {\n          const msg = `Map keys must be unique; \"${iKey}\" is repeated`;\n          doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));\n          break;\n        }\n      }\n    }\n  }\n\n  if (hasCollectionKey && !doc.options.mapAsMap) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = map;\n  return map;\n}\n\nconst valueHasPairComment = ({\n  context: {\n    lineStart,\n    node,\n    src\n  },\n  props\n}) => {\n  if (props.length === 0) return false;\n  const {\n    start\n  } = props[0];\n  if (node && start > node.valueRange.start) return false;\n  if (src[start] !== PlainValue.Char.COMMENT) return false;\n\n  for (let i = lineStart; i < start; ++i) if (src[i] === '\\n') return false;\n\n  return true;\n};\n\nfunction resolvePairComment(item, pair) {\n  if (!valueHasPairComment(item)) return;\n  const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);\n  let found = false;\n  const cb = pair.value.commentBefore;\n\n  if (cb && cb.startsWith(comment)) {\n    pair.value.commentBefore = cb.substr(comment.length + 1);\n    found = true;\n  } else {\n    const cc = pair.value.comment;\n\n    if (!item.node && cc && cc.startsWith(comment)) {\n      pair.value.comment = cc.substr(comment.length + 1);\n      found = true;\n    }\n  }\n\n  if (found) pair.comment = comment;\n}\n\nfunction resolveBlockMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let keyStart = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          afterKey: !!key,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          afterKey: !!key,\n          before: items.length,\n          comment: item.comment\n        });\n        break;\n\n      case PlainValue.Type.MAP_KEY:\n        if (key !== undefined) items.push(new Pair(key));\n        if (item.error) doc.errors.push(item.error);\n        key = resolveNode(doc, item.node);\n        keyStart = null;\n        break;\n\n      case PlainValue.Type.MAP_VALUE:\n        {\n          if (key === undefined) key = null;\n          if (item.error) doc.errors.push(item.error);\n\n          if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) {\n            const msg = 'Nested mappings are not allowed in compact mappings';\n            doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));\n          }\n\n          let valueNode = item.node;\n\n          if (!valueNode && item.props.length > 0) {\n            // Comments on an empty mapping value need to be preserved, so we\n            // need to construct a minimal empty node here to use instead of the\n            // missing `item.node`. -- eemeli/yaml#19\n            valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);\n            valueNode.context = {\n              parent: item,\n              src: item.context.src\n            };\n            const pos = item.range.start + 1;\n            valueNode.range = {\n              start: pos,\n              end: pos\n            };\n            valueNode.valueRange = {\n              start: pos,\n              end: pos\n            };\n\n            if (typeof item.range.origStart === 'number') {\n              const origPos = item.range.origStart + 1;\n              valueNode.range.origStart = valueNode.range.origEnd = origPos;\n              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;\n            }\n          }\n\n          const pair = new Pair(key, resolveNode(doc, valueNode));\n          resolvePairComment(item, pair);\n          items.push(pair);\n\n          if (key && typeof keyStart === 'number') {\n            if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n          }\n\n          key = undefined;\n          keyStart = null;\n        }\n        break;\n\n      default:\n        if (key !== undefined) items.push(new Pair(key));\n        key = resolveNode(doc, item);\n        keyStart = item.range.start;\n        if (item.error) doc.errors.push(item.error);\n\n        next: for (let j = i + 1;; ++j) {\n          const nextItem = cst.items[j];\n\n          switch (nextItem && nextItem.type) {\n            case PlainValue.Type.BLANK_LINE:\n            case PlainValue.Type.COMMENT:\n              continue next;\n\n            case PlainValue.Type.MAP_VALUE:\n              break next;\n\n            default:\n              {\n                const msg = 'Implicit map keys need to be followed by map values';\n                doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n                break next;\n              }\n          }\n        }\n\n        if (item.valueRangeContainsNewline) {\n          const msg = 'Implicit map keys need to be on a single line';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n    }\n  }\n\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let explicitKey = false;\n  let next = '{';\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char === '?' && key === undefined && !explicitKey) {\n        explicitKey = true;\n        next = ':';\n        continue;\n      }\n\n      if (char === ':') {\n        if (key === undefined) key = null;\n\n        if (next === ':') {\n          next = ',';\n          continue;\n        }\n      } else {\n        if (explicitKey) {\n          if (key === undefined && char !== ',') key = null;\n          explicitKey = false;\n        }\n\n        if (key !== undefined) {\n          items.push(new Pair(key));\n          key = undefined;\n\n          if (char === ',') {\n            next = ':';\n            continue;\n          }\n        }\n      }\n\n      if (char === '}') {\n        if (i === cst.items.length - 1) continue;\n      } else if (char === next) {\n        next = ':';\n        continue;\n      }\n\n      const msg = `Flow map contains an unexpected ${char}`;\n      const err = new PlainValue.YAMLSyntaxError(cst, msg);\n      err.offset = offset;\n      doc.errors.push(err);\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        afterKey: !!key,\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        afterKey: !!key,\n        before: items.length,\n        comment: item.comment\n      });\n    } else if (key === undefined) {\n      if (next === ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Separator , missing in flow map'));\n      key = resolveNode(doc, item);\n    } else {\n      if (next !== ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Indicator : missing in flow map entry'));\n      items.push(new Pair(key, resolveNode(doc, item)));\n      key = undefined;\n      explicitKey = false;\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveSeq(doc, cst) {\n  if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {\n    const msg = `A ${cst.type} node cannot be resolved as a sequence`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);\n  const seq = new YAMLSeq();\n  seq.items = items;\n  resolveComments(seq, comments);\n\n  if (!doc.options.mapAsMap && items.some(it => it instanceof Pair && it.key instanceof Collection)) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = seq;\n  return seq;\n}\n\nfunction resolveBlockSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          comment: item.comment,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.SEQ_ITEM:\n        if (item.error) doc.errors.push(item.error);\n        items.push(resolveNode(doc, item.node));\n\n        if (item.hasProps) {\n          const msg = 'Sequence items cannot have tags or anchors before the - indicator';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n        break;\n\n      default:\n        if (item.error) doc.errors.push(item.error);\n        doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));\n    }\n  }\n\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let explicitKey = false;\n  let key = undefined;\n  let keyStart = null;\n  let next = '[';\n  let prevItem = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char !== ':' && (explicitKey || key !== undefined)) {\n        if (explicitKey && key === undefined) key = next ? items.pop() : null;\n        items.push(new Pair(key));\n        explicitKey = false;\n        key = undefined;\n        keyStart = null;\n      }\n\n      if (char === next) {\n        next = null;\n      } else if (!next && char === '?') {\n        explicitKey = true;\n      } else if (next !== '[' && char === ':' && key === undefined) {\n        if (next === ',') {\n          key = items.pop();\n\n          if (key instanceof Pair) {\n            const msg = 'Chaining flow sequence pairs is invalid';\n            const err = new PlainValue.YAMLSemanticError(cst, msg);\n            err.offset = offset;\n            doc.errors.push(err);\n          }\n\n          if (!explicitKey && typeof keyStart === 'number') {\n            const keyEnd = item.range ? item.range.start : item.offset;\n            if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n            const {\n              src\n            } = prevItem.context;\n\n            for (let i = keyStart; i < keyEnd; ++i) if (src[i] === '\\n') {\n              const msg = 'Implicit keys of flow sequence pairs need to be on a single line';\n              doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));\n              break;\n            }\n          }\n        } else {\n          key = null;\n        }\n\n        keyStart = null;\n        explicitKey = false;\n        next = null;\n      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {\n        const msg = `Flow sequence contains an unexpected ${char}`;\n        const err = new PlainValue.YAMLSyntaxError(cst, msg);\n        err.offset = offset;\n        doc.errors.push(err);\n      }\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        comment: item.comment,\n        before: items.length\n      });\n    } else {\n      if (next) {\n        const msg = `Expected a ${next} in flow sequence`;\n        doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n      }\n\n      const value = resolveNode(doc, item);\n\n      if (key === undefined) {\n        items.push(value);\n        prevItem = item;\n      } else {\n        items.push(new Pair(key, value));\n        key = undefined;\n      }\n\n      keyStart = item.range.start;\n      next = ',';\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nexports.Alias = Alias;\nexports.Collection = Collection;\nexports.Merge = Merge;\nexports.Node = Node;\nexports.Pair = Pair;\nexports.Scalar = Scalar;\nexports.YAMLMap = YAMLMap;\nexports.YAMLSeq = YAMLSeq;\nexports.addComment = addComment;\nexports.binaryOptions = binaryOptions;\nexports.boolOptions = boolOptions;\nexports.findPair = findPair;\nexports.intOptions = intOptions;\nexports.isEmptyPath = isEmptyPath;\nexports.nullOptions = nullOptions;\nexports.resolveMap = resolveMap;\nexports.resolveNode = resolveNode;\nexports.resolveSeq = resolveSeq;\nexports.resolveString = resolveString;\nexports.strOptions = strOptions;\nexports.stringifyNumber = stringifyNumber;\nexports.stringifyString = stringifyString;\nexports.toJSON = toJSON;\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-4a68b39b.js');\n\n/* global atob, btoa, Buffer */\nconst binary = {\n  identify: value => value instanceof Uint8Array,\n  // Buffer inherits from Uint8Array\n  default: false,\n  tag: 'tag:yaml.org,2002:binary',\n\n  /**\n   * Returns a Buffer in node and an Uint8Array in browsers\n   *\n   * To use the resulting buffer as an image, you'll want to do something like:\n   *\n   *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n   *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n   */\n  resolve: (doc, node) => {\n    const src = resolveSeq.resolveString(doc, node);\n\n    if (typeof Buffer === 'function') {\n      return Buffer.from(src, 'base64');\n    } else if (typeof atob === 'function') {\n      // On IE 11, atob() can't handle newlines\n      const str = atob(src.replace(/[\\n\\r]/g, ''));\n      const buffer = new Uint8Array(str.length);\n\n      for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);\n\n      return buffer;\n    } else {\n      const msg = 'This environment does not support reading binary tags; either Buffer or atob is required';\n      doc.errors.push(new PlainValue.YAMLReferenceError(node, msg));\n      return null;\n    }\n  },\n  options: resolveSeq.binaryOptions,\n  stringify: ({\n    comment,\n    type,\n    value\n  }, ctx, onComment, onChompKeep) => {\n    let src;\n\n    if (typeof Buffer === 'function') {\n      src = value instanceof Buffer ? value.toString('base64') : Buffer.from(value.buffer).toString('base64');\n    } else if (typeof btoa === 'function') {\n      let s = '';\n\n      for (let i = 0; i < value.length; ++i) s += String.fromCharCode(value[i]);\n\n      src = btoa(s);\n    } else {\n      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n    }\n\n    if (!type) type = resolveSeq.binaryOptions.defaultType;\n\n    if (type === PlainValue.Type.QUOTE_DOUBLE) {\n      value = src;\n    } else {\n      const {\n        lineWidth\n      } = resolveSeq.binaryOptions;\n      const n = Math.ceil(src.length / lineWidth);\n      const lines = new Array(n);\n\n      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n        lines[i] = src.substr(o, lineWidth);\n      }\n\n      value = lines.join(type === PlainValue.Type.BLOCK_LITERAL ? '\\n' : ' ');\n    }\n\n    return resolveSeq.stringifyString({\n      comment,\n      type,\n      value\n    }, ctx, onComment, onChompKeep);\n  }\n};\n\nfunction parsePairs(doc, cst) {\n  const seq = resolveSeq.resolveSeq(doc, cst);\n\n  for (let i = 0; i < seq.items.length; ++i) {\n    let item = seq.items[i];\n    if (item instanceof resolveSeq.Pair) continue;else if (item instanceof resolveSeq.YAMLMap) {\n      if (item.items.length > 1) {\n        const msg = 'Each pair must have its own sequence indicator';\n        throw new PlainValue.YAMLSemanticError(cst, msg);\n      }\n\n      const pair = item.items[0] || new resolveSeq.Pair();\n      if (item.commentBefore) pair.commentBefore = pair.commentBefore ? `${item.commentBefore}\\n${pair.commentBefore}` : item.commentBefore;\n      if (item.comment) pair.comment = pair.comment ? `${item.comment}\\n${pair.comment}` : item.comment;\n      item = pair;\n    }\n    seq.items[i] = item instanceof resolveSeq.Pair ? item : new resolveSeq.Pair(item);\n  }\n\n  return seq;\n}\nfunction createPairs(schema, iterable, ctx) {\n  const pairs = new resolveSeq.YAMLSeq(schema);\n  pairs.tag = 'tag:yaml.org,2002:pairs';\n\n  for (const it of iterable) {\n    let key, value;\n\n    if (Array.isArray(it)) {\n      if (it.length === 2) {\n        key = it[0];\n        value = it[1];\n      } else throw new TypeError(`Expected [key, value] tuple: ${it}`);\n    } else if (it && it instanceof Object) {\n      const keys = Object.keys(it);\n\n      if (keys.length === 1) {\n        key = keys[0];\n        value = it[key];\n      } else throw new TypeError(`Expected { key: value } tuple: ${it}`);\n    } else {\n      key = it;\n    }\n\n    const pair = schema.createPair(key, value, ctx);\n    pairs.items.push(pair);\n  }\n\n  return pairs;\n}\nconst pairs = {\n  default: false,\n  tag: 'tag:yaml.org,2002:pairs',\n  resolve: parsePairs,\n  createNode: createPairs\n};\n\nclass YAMLOMap extends resolveSeq.YAMLSeq {\n  constructor() {\n    super();\n\n    PlainValue._defineProperty(this, \"add\", resolveSeq.YAMLMap.prototype.add.bind(this));\n\n    PlainValue._defineProperty(this, \"delete\", resolveSeq.YAMLMap.prototype.delete.bind(this));\n\n    PlainValue._defineProperty(this, \"get\", resolveSeq.YAMLMap.prototype.get.bind(this));\n\n    PlainValue._defineProperty(this, \"has\", resolveSeq.YAMLMap.prototype.has.bind(this));\n\n    PlainValue._defineProperty(this, \"set\", resolveSeq.YAMLMap.prototype.set.bind(this));\n\n    this.tag = YAMLOMap.tag;\n  }\n\n  toJSON(_, ctx) {\n    const map = new Map();\n    if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n    for (const pair of this.items) {\n      let key, value;\n\n      if (pair instanceof resolveSeq.Pair) {\n        key = resolveSeq.toJSON(pair.key, '', ctx);\n        value = resolveSeq.toJSON(pair.value, key, ctx);\n      } else {\n        key = resolveSeq.toJSON(pair, '', ctx);\n      }\n\n      if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');\n      map.set(key, value);\n    }\n\n    return map;\n  }\n\n}\n\nPlainValue._defineProperty(YAMLOMap, \"tag\", 'tag:yaml.org,2002:omap');\n\nfunction parseOMap(doc, cst) {\n  const pairs = parsePairs(doc, cst);\n  const seenKeys = [];\n\n  for (const {\n    key\n  } of pairs.items) {\n    if (key instanceof resolveSeq.Scalar) {\n      if (seenKeys.includes(key.value)) {\n        const msg = 'Ordered maps must not include duplicate keys';\n        throw new PlainValue.YAMLSemanticError(cst, msg);\n      } else {\n        seenKeys.push(key.value);\n      }\n    }\n  }\n\n  return Object.assign(new YAMLOMap(), pairs);\n}\n\nfunction createOMap(schema, iterable, ctx) {\n  const pairs = createPairs(schema, iterable, ctx);\n  const omap = new YAMLOMap();\n  omap.items = pairs.items;\n  return omap;\n}\n\nconst omap = {\n  identify: value => value instanceof Map,\n  nodeClass: YAMLOMap,\n  default: false,\n  tag: 'tag:yaml.org,2002:omap',\n  resolve: parseOMap,\n  createNode: createOMap\n};\n\nclass YAMLSet extends resolveSeq.YAMLMap {\n  constructor() {\n    super();\n    this.tag = YAMLSet.tag;\n  }\n\n  add(key) {\n    const pair = key instanceof resolveSeq.Pair ? key : new resolveSeq.Pair(key);\n    const prev = resolveSeq.findPair(this.items, pair.key);\n    if (!prev) this.items.push(pair);\n  }\n\n  get(key, keepPair) {\n    const pair = resolveSeq.findPair(this.items, key);\n    return !keepPair && pair instanceof resolveSeq.Pair ? pair.key instanceof resolveSeq.Scalar ? pair.key.value : pair.key : pair;\n  }\n\n  set(key, value) {\n    if (typeof value !== 'boolean') throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);\n    const prev = resolveSeq.findPair(this.items, key);\n\n    if (prev && !value) {\n      this.items.splice(this.items.indexOf(prev), 1);\n    } else if (!prev && value) {\n      this.items.push(new resolveSeq.Pair(key));\n    }\n  }\n\n  toJSON(_, ctx) {\n    return super.toJSON(_, ctx, Set);\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n    if (this.hasAllNullValues()) return super.toString(ctx, onComment, onChompKeep);else throw new Error('Set items must all have null values');\n  }\n\n}\n\nPlainValue._defineProperty(YAMLSet, \"tag\", 'tag:yaml.org,2002:set');\n\nfunction parseSet(doc, cst) {\n  const map = resolveSeq.resolveMap(doc, cst);\n  if (!map.hasAllNullValues()) throw new PlainValue.YAMLSemanticError(cst, 'Set items must all have null values');\n  return Object.assign(new YAMLSet(), map);\n}\n\nfunction createSet(schema, iterable, ctx) {\n  const set = new YAMLSet();\n\n  for (const value of iterable) set.items.push(schema.createPair(value, null, ctx));\n\n  return set;\n}\n\nconst set = {\n  identify: value => value instanceof Set,\n  nodeClass: YAMLSet,\n  default: false,\n  tag: 'tag:yaml.org,2002:set',\n  resolve: parseSet,\n  createNode: createSet\n};\n\nconst parseSexagesimal = (sign, parts) => {\n  const n = parts.split(':').reduce((n, p) => n * 60 + Number(p), 0);\n  return sign === '-' ? -n : n;\n}; // hhhh:mm:ss.sss\n\n\nconst stringifySexagesimal = ({\n  value\n}) => {\n  if (isNaN(value) || !isFinite(value)) return resolveSeq.stringifyNumber(value);\n  let sign = '';\n\n  if (value < 0) {\n    sign = '-';\n    value = Math.abs(value);\n  }\n\n  const parts = [value % 60]; // seconds, including ms\n\n  if (value < 60) {\n    parts.unshift(0); // at least one : is required\n  } else {\n    value = Math.round((value - parts[0]) / 60);\n    parts.unshift(value % 60); // minutes\n\n    if (value >= 60) {\n      value = Math.round((value - parts[0]) / 60);\n      parts.unshift(value); // hours\n    }\n  }\n\n  return sign + parts.map(n => n < 10 ? '0' + String(n) : String(n)).join(':').replace(/000000\\d*$/, '') // % 60 may introduce error\n  ;\n};\n\nconst intTime = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,\n  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),\n  stringify: stringifySexagesimal\n};\nconst floatTime = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*)$/,\n  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),\n  stringify: stringifySexagesimal\n};\nconst timestamp = {\n  identify: value => value instanceof Date,\n  default: true,\n  tag: 'tag:yaml.org,2002:timestamp',\n  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n  // may be omitted altogether, resulting in a date format. In such a case, the time part is\n  // assumed to be 00:00:00Z (start of day, UTC).\n  test: RegExp('^(?:' + '([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n  '(?:(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n  '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n  '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n  ')?' + ')$'),\n  resolve: (str, year, month, day, hour, minute, second, millisec, tz) => {\n    if (millisec) millisec = (millisec + '00').substr(1, 3);\n    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);\n\n    if (tz && tz !== 'Z') {\n      let d = parseSexagesimal(tz[0], tz.slice(1));\n      if (Math.abs(d) < 30) d *= 60;\n      date -= 60000 * d;\n    }\n\n    return new Date(date);\n  },\n  stringify: ({\n    value\n  }) => value.toISOString().replace(/((T00:00)?:00)?\\.000Z$/, '')\n};\n\n/* global console, process, YAML_SILENCE_DEPRECATION_WARNINGS, YAML_SILENCE_WARNINGS */\nfunction shouldWarn(deprecation) {\n  const env = typeof process !== 'undefined' && process.env || {};\n\n  if (deprecation) {\n    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== 'undefined') return !YAML_SILENCE_DEPRECATION_WARNINGS;\n    return !env.YAML_SILENCE_DEPRECATION_WARNINGS;\n  }\n\n  if (typeof YAML_SILENCE_WARNINGS !== 'undefined') return !YAML_SILENCE_WARNINGS;\n  return !env.YAML_SILENCE_WARNINGS;\n}\n\nfunction warn(warning, type) {\n  if (shouldWarn(false)) {\n    const emit = typeof process !== 'undefined' && process.emitWarning; // This will throw in Jest if `warning` is an Error instance due to\n    // https://github.com/facebook/jest/issues/2549\n\n    if (emit) emit(warning, type);else {\n      // eslint-disable-next-line no-console\n      console.warn(type ? `${type}: ${warning}` : warning);\n    }\n  }\n}\nfunction warnFileDeprecation(filename) {\n  if (shouldWarn(true)) {\n    const path = filename.replace(/.*yaml[/\\\\]/i, '').replace(/\\.js$/, '').replace(/\\\\/g, '/');\n    warn(`The endpoint 'yaml/${path}' will be removed in a future release.`, 'DeprecationWarning');\n  }\n}\nconst warned = {};\nfunction warnOptionDeprecation(name, alternative) {\n  if (!warned[name] && shouldWarn(true)) {\n    warned[name] = true;\n    let msg = `The option '${name}' will be removed in a future release`;\n    msg += alternative ? `, use '${alternative}' instead.` : '.';\n    warn(msg, 'DeprecationWarning');\n  }\n}\n\nexports.binary = binary;\nexports.floatTime = floatTime;\nexports.intTime = intTime;\nexports.omap = omap;\nexports.pairs = pairs;\nexports.set = set;\nexports.timestamp = timestamp;\nexports.warn = warn;\nexports.warnFileDeprecation = warnFileDeprecation;\nexports.warnOptionDeprecation = warnOptionDeprecation;\n","module.exports = require('./dist').YAML\n","// Note: These are not official or complete. I've basically just made them up based on documentation.\n// They are good enough for now but will probably need to be updated/expanded. \n// Hopefully people start publishing OpenAPI schemas soon.\n\nconst {objectMeta: metadata}= require('./common.js');\n\nmodule.exports = {\n  \"/azureidentity-aadpodidentity-v1.json\": {\n    $schema: \"http://json-schema.org/draft-04/schema#\",\n    type: \"object\",\n    properties: {\n      apiVersion: {\n        type: \"string\",\n      },\n      kind: {\n        type: \"string\",\n      },\n      metadata,\n      spec: {\n        type: \"object\",\n        properties: {\n          type: {\n            type: \"integer\",\n          },\n          resourceID: {\n            type: \"string\",\n          },\n          clientID: {\n            type: \"string\",\n          },\n        },\n        required: [\"type\", \"resourceID\", \"clientID\"],\n      },\n    },\n    required: [\"apiVersion\", \"kind\", \"metadata\", \"spec\"],\n  },\n};","// Note: These are not official or complete. I've basically just made them up based on documentation.\n// They are good enough for now but will probably need to be updated/expanded.\n// Hopefully people start publishing OpenAPI schemas soon.\n\nconst { objectMeta } = require(\"./common.js\");\n\nmodule.exports = {\n  \"/azureidentitybinding-aadpodidentity-v1.json\": {\n    $schema: \"http://json-schema.org/draft-04/schema#\",\n    type: \"object\",\n    properties: {\n      apiVersion: {\n        type: \"string\",\n      },\n      kind: {\n        type: \"string\",\n      },\n      metadata: objectMeta,\n      spec: {\n        type: \"object\",\n        properties: {\n          azureIdentity: {\n            type: \"string\",\n          },\n          selector: {\n            type: \"string\",\n          },\n        },\n        required: [\"azureIdentity\", \"selector\"],\n      },\n    },\n    required: [\"apiVersion\", \"kind\", \"metadata\", \"spec\"],\n  },\n};\n","// Note: These are not official or complete. I've basically just made them up based on documentation.\n// They are good enough for now but will probably need to be updated/expanded. \n// Hopefully people start publishing OpenAPI schemas soon.\n\nconst {objectMeta: metadata}= require('./common.js');\n\nmodule.exports = {\n  \"/azurepodidentityexception-aadpodidentity-v1.json\": {\n    $schema: \"http://json-schema.org/draft-04/schema#\",\n    type: \"object\",\n    properties: {\n      apiVersion: {\n        type: \"string\",\n      },\n      kind: {\n        type: \"string\",\n      },\n      metadata,\n      spec: {\n        type: \"object\",\n        properties: {\n          name: {\n            type: \"string\",\n          },\n          podLabels: {\n            type: \"object\",\n          },\n        },\n        required: [\"podLabels\"],\n      },\n    },\n    required: [\"apiVersion\", \"kind\", \"metadata\", \"spec\"],\n  },\n};","module.exports = {\n  objectMeta: {\n    $schema: \"http://json-schema.org/schema#\",\n    type: \"object\",\n    description:\n      \"ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.\",\n    properties: {\n      uid: {\n        type: \"string\",\n        description:\n          \"UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\\n\\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids\",\n      },\n      deletionTimestamp: {\n        description:\n          \"DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.\\n\\nPopulated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata\",\n        type: [\"object\", \"null\"],\n        // Removed because its out of scope for now\n        // $ref:\n        //   \"_definitions.json#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time\",\n      },\n      clusterName: {\n        type: \"string\",\n        description:\n          \"The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.\",\n      },\n      deletionGracePeriodSeconds: {\n        type: \"integer\",\n        description:\n          \"Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.\",\n        format: \"int64\",\n      },\n      labels: {\n        additionalProperties: {\n          type: \"string\",\n        },\n        type: \"object\",\n        description:\n          \"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels\",\n      },\n      namespace: {\n        type: \"string\",\n        description:\n          'Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\\n\\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces',\n      },\n      generation: {\n        type: \"integer\",\n        description:\n          \"A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.\",\n        format: \"int64\",\n      },\n      finalizers: {\n        items: {\n          type: \"string\",\n        },\n        type: \"array\",\n        description:\n          \"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.\",\n        \"x-kubernetes-patch-strategy\": \"merge\",\n      },\n      generateName: {\n        type: \"string\",\n        description:\n          \"GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\\n\\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\\n\\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency\",\n      },\n      annotations: {\n        additionalProperties: {\n          type: \"string\",\n        },\n        type: \"object\",\n        description:\n          \"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations\",\n      },\n      resourceVersion: {\n        type: \"string\",\n        description:\n          \"An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\\n\\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\",\n      },\n      ownerReferences: {\n        items: {\n          type: \"object\",\n          // Removed because its out of scope for now\n          // $ref:\n          //   \"_definitions.json#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference\",\n        },\n        type: \"array\",\n        description:\n          \"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.\",\n        \"x-kubernetes-patch-strategy\": \"merge\",\n        \"x-kubernetes-patch-merge-key\": \"uid\",\n      },\n      creationTimestamp: {\n        description:\n          \"CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.\\n\\nPopulated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata\",\n        type: [\"object\", \"null\"],\n        // Removed because its out of scope for now\n        // $ref:\n        //   \"_definitions.json#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time\",\n      },\n      managedFields: {\n        items: {\n          type: \"object\",\n          // Removed because its out of scope for now\n          // $ref:\n          //   \"_definitions.json#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry\",\n        },\n        type: \"array\",\n        description:\n          \"ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like \\\"ci-cd\\\". The set of fields is always in the version that the workflow used when modifying the object.\",\n      },\n      selfLink: {\n        type: \"string\",\n        description:\n          \"SelfLink is a URL representing this object. Populated by the system. Read-only.\\n\\nDEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release.\",\n      },\n      name: {\n        type: \"string\",\n        description:\n          \"Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names\",\n      },\n    },\n  },\n  listMeta: {\n    $schema: \"http://json-schema.org/schema#\",\n    type: \"object\",\n    description:\n      \"ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.\",\n    properties: {\n      continue: {\n        type: \"string\",\n        description:\n          \"continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.\",\n      },\n      remainingItemCount: {\n        type: \"integer\",\n        description:\n          \"remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact.\",\n        format: \"int64\",\n      },\n      selfLink: {\n        type: \"string\",\n        description:\n          \"selfLink is a URL representing this object. Populated by the system. Read-only.\\n\\nDEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release.\",\n      },\n      resourceVersion: {\n        type: \"string\",\n        description:\n          \"String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\",\n      },\n    },\n  },\n};\n","const { objectMeta, listMeta } = require(\"./common.js\");\n\n// Generated using openapi2jsonschema https://raw.githubusercontent.com/kubernetes/kubernetes/master/api/openapi-spec/swagger.json\n\nconst customResourceDefinitionCondition = {\n  $schema: \"http://json-schema.org/schema#\",\n  required: [\"type\", \"status\"],\n  type: \"object\",\n  description:\n    \"CustomResourceDefinitionCondition contains details for the current condition of this pod.\",\n  properties: {\n    status: {\n      type: \"string\",\n      description:\n        \"status is the status of the condition. Can be True, False, Unknown.\",\n    },\n    type: {\n      type: \"string\",\n      description:\n        \"type is the type of the condition. Types include Established, NamesAccepted and Terminating.\",\n    },\n    message: {\n      type: \"string\",\n      description:\n        \"message is a human-readable message indicating details about last transition.\",\n    },\n    lastTransitionTime: {\n      description:\n        \"lastTransitionTime last time the condition transitioned from one status to another.\",\n      type: [\"object\", \"null\"],\n      // Removed because its out of scope for now\n      //   $ref:\n      //     \"_definitions.json#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time\",\n    },\n    reason: {\n      type: \"string\",\n      description:\n        \"reason is a unique, one-word, CamelCase reason for the condition's last transition.\",\n    },\n  },\n};\n\nconst customResourceDefinitionNames = {\n  $schema: \"http://json-schema.org/schema#\",\n  required: [\"plural\", \"kind\"],\n  type: \"object\",\n  description:\n    \"CustomResourceDefinitionNames indicates the names to serve this CustomResourceDefinition\",\n  properties: {\n    shortNames: {\n      items: {\n        type: \"string\",\n      },\n      type: \"array\",\n      description:\n        \"shortNames are short names for the resource, exposed in API discovery documents, and used by clients to support invocations like `kubectl get <shortname>`. It must be all lowercase.\",\n    },\n    kind: {\n      type: \"string\",\n      description:\n        \"kind is the serialized kind of the resource. It is normally CamelCase and singular. Custom resource instances will use this value as the `kind` attribute in API calls.\",\n    },\n    singular: {\n      type: \"string\",\n      description:\n        \"singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased `kind`.\",\n    },\n    listKind: {\n      type: \"string\",\n      description:\n        'listKind is the serialized kind of the list for this resource. Defaults to \"`kind`List\".',\n    },\n    plural: {\n      type: \"string\",\n      description:\n        \"plural is the plural name of the resource to serve. The custom resources are served under `/apis/<group>/<version>/.../<plural>`. Must match the name of the CustomResourceDefinition (in the form `<names.plural>.<group>`). Must be all lowercase.\",\n    },\n    categories: {\n      items: {\n        type: \"string\",\n      },\n      type: \"array\",\n      description:\n        \"categories is a list of grouped resources this custom resource belongs to (e.g. 'all'). This is published in API discovery documents, and used by clients to support invocations like `kubectl get all`.\",\n    },\n  },\n};\n\nconst customResourceValidation = {\n  $schema: \"http://json-schema.org/schema#\",\n  type: \"object\",\n  description:\n    \"CustomResourceValidation is a list of validation methods for CustomResources.\",\n  properties: {\n    openAPIV3Schema: {\n      description:\n        \"openAPIV3Schema is the OpenAPI v3 schema to use for validation and pruning.\",\n      type: [\"object\", \"null\"],\n      // Removed because its out of scope for now\n      //\"$ref\": \"_definitions.json#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaProps\"\n    },\n  },\n};\n\nconst customResourceDefinitionVersion = {\n  $schema: \"http://json-schema.org/schema#\",\n  required: [\"name\", \"served\", \"storage\"],\n  type: \"object\",\n  description: \"CustomResourceDefinitionVersion describes a version for CRD.\",\n  properties: {\n    name: {\n      type: \"string\",\n      description:\n        \"name is the version name, e.g. \\u201cv1\\u201d, \\u201cv2beta1\\u201d, etc. The custom resources are served under this version at `/apis/<group>/<version>/...` if `served` is true.\",\n    },\n    storage: {\n      type: \"boolean\",\n      description:\n        \"storage indicates this version should be used when persisting custom resources to storage. There must be exactly one version with storage=true.\",\n    },\n    additionalPrinterColumns: {\n      items: {\n        type: [\"object\", \"null\"],\n        // Removed because its out of scope for now\n        // $ref:\n        //   \"_definitions.json#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceColumnDefinition\",\n      },\n      type: \"array\",\n      description:\n        \"additionalPrinterColumns specifies additional columns returned in Table output. See https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables for details. Top-level and per-version columns are mutually exclusive. Per-version columns must not all be set to identical values (top-level columns should be used instead). If no top-level or per-version columns are specified, a single column displaying the age of the custom resource is used.\",\n    },\n    subresources: {\n      description:\n        \"subresources specify what subresources this version of the defined custom resource have. Top-level and per-version subresources are mutually exclusive. Per-version subresources must not all be set to identical values (top-level subresources should be used instead).\",\n      type: [\"object\", \"null\"],\n      // Removed because its out of scope for now\n      //   $ref:\n      //     \"_definitions.json#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceSubresources\",\n    },\n    served: {\n      type: \"boolean\",\n      description:\n        \"served is a flag enabling/disabling this version from being served via REST APIs\",\n    },\n    schema: customResourceValidation,\n  },\n};\n\nconst customResourceDefinitionStatus = {\n  $schema: \"http://json-schema.org/schema#\",\n  type: \"object\",\n  description:\n    \"CustomResourceDefinitionStatus indicates the state of the CustomResourceDefinition\",\n  properties: {\n    acceptedNames: customResourceDefinitionNames,\n    conditions: {\n      items: customResourceDefinitionCondition,\n      type: \"array\",\n      description:\n        \"conditions indicate state for particular aspects of a CustomResourceDefinition\",\n    },\n    storedVersions: {\n      items: {\n        type: \"string\",\n      },\n      type: \"array\",\n      description:\n        \"storedVersions lists all versions of CustomResources that were ever persisted. Tracking these versions allows a migration path for stored versions in etcd. The field is mutable so a migration controller can finish a migration to another version (ensuring no old objects are left in storage), and then remove the rest of the versions from this list. Versions may not be removed from `spec.versions` while they exist in this list.\",\n    },\n  },\n};\n\nconst customResourceDefinitionSpec = {\n  $schema: \"http://json-schema.org/schema#\",\n  required: [\"group\", \"names\", \"scope\"],\n  type: \"object\",\n  description:\n    \"CustomResourceDefinitionSpec describes how a user wants their resource to appear\",\n  properties: {\n    conversion: {\n      description: \"conversion defines conversion settings for the CRD.\",\n      type: [\"object\", \"null\"],\n      // Removed because its out of scope for now\n      //   $ref:\n      //     \"_definitions.json#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceConversion\",\n    },\n    group: {\n      type: \"string\",\n      description:\n        \"group is the API group of the defined custom resource. The custom resources are served under `/apis/<group>/...`. Must match the name of the CustomResourceDefinition (in the form `<names.plural>.<group>`).\",\n    },\n    versions: {\n      items: customResourceDefinitionVersion,\n      type: \"array\",\n      description:\n        'versions is the list of all API versions of the defined custom resource. Optional if `version` is specified. The name of the first item in the `versions` list must match the `version` field if `version` and `versions` are both specified. Version names are used to compute the order in which served versions are listed in API discovery. If the version string is \"kube-like\", it will sort above non \"kube-like\" version strings, which are ordered lexicographically. \"Kube-like\" versions start with a \"v\", then are followed by a number (the major version), then optionally the string \"alpha\" or \"beta\" and another number (the minor version). These are sorted first by GA > beta > alpha (where GA is a version with no suffix such as beta or alpha), and then by comparing major version, then minor version. An example sorted list of versions: v10, v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10.',\n    },\n    additionalPrinterColumns: {\n      items: {\n        type: [\"object\", \"null\"],\n        // Removed because its out of scope for now\n        // $ref:\n        //   \"_definitions.json#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceColumnDefinition\",\n      },\n      type: \"array\",\n      description:\n        \"additionalPrinterColumns specifies additional columns returned in Table output. See https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables for details. If present, this field configures columns for all versions. Top-level and per-version columns are mutually exclusive. If no top-level or per-version columns are specified, a single column displaying the age of the custom resource is used.\",\n    },\n    preserveUnknownFields: {\n      type: \"boolean\",\n      description:\n        \"preserveUnknownFields indicates that object fields which are not specified in the OpenAPI schema should be preserved when persisting to storage. apiVersion, kind, metadata and known fields inside metadata are always preserved. If false, schemas must be defined for all versions. Defaults to true in v1beta for backwards compatibility. Deprecated: will be required to be false in v1. Preservation of unknown fields can be specified in the validation schema using the `x-kubernetes-preserve-unknown-fields: true` extension. See https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#pruning-versus-preserving-unknown-fields for details.\",\n    },\n    version: {\n      type: \"string\",\n      description:\n        \"version is the API version of the defined custom resource. The custom resources are served under `/apis/<group>/<version>/...`. Must match the name of the first item in the `versions` list if `version` and `versions` are both specified. Optional if `versions` is specified. Deprecated: use `versions` instead.\",\n    },\n    names: customResourceDefinitionNames,\n    scope: {\n      type: \"string\",\n      description:\n        \"scope indicates whether the defined custom resource is cluster- or namespace-scoped. Allowed values are `Cluster` and `Namespaced`. Default is `Namespaced`.\",\n    },\n    validation: customResourceValidation,\n    subresources: {\n      description:\n        \"subresources specify what subresources the defined custom resource has. If present, this field configures subresources for all versions. Top-level and per-version subresources are mutually exclusive.\",\n      type: [\"object\", \"null\"],\n      // Removed because its out of scope for now\n      //   $ref:\n      //     \"_definitions.json#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceSubresources\",\n    },\n  },\n};\n\nconst customResourceDefinition = {\n  description:\n    \"CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>. Deprecated in v1.16, planned for removal in v1.19. Use apiextensions.k8s.io/v1 CustomResourceDefinition instead.\",\n  required: [\"spec\"],\n  \"x-kubernetes-group-version-kind\": [\n    {\n      kind: \"CustomResourceDefinition\",\n      version: \"v1beta1\",\n      group: \"apiextensions.k8s.io\",\n    },\n  ],\n  $schema: \"http://json-schema.org/schema#\",\n  type: \"object\",\n  properties: {\n    status: customResourceDefinitionStatus,\n    kind: {\n      type: \"string\",\n      description:\n        \"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\n    },\n    spec: customResourceDefinitionSpec,\n    apiVersion: {\n      type: \"string\",\n      description:\n        \"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\n    },\n    metadata: objectMeta,\n  },\n};\n\nconst customResourceDefinitionList = {\n  description:\n    \"CustomResourceDefinitionList is a list of CustomResourceDefinition objects.\",\n  required: [\"items\"],\n  \"x-kubernetes-group-version-kind\": [\n    {\n      kind: \"CustomResourceDefinitionList\",\n      version: \"v1\",\n      group: \"apiextensions.k8s.io\",\n    },\n  ],\n  $schema: \"http://json-schema.org/schema#\",\n  type: \"object\",\n  properties: {\n    items: {\n      items: customResourceDefinition,\n    },\n    type: \"array\",\n    description: \"items list individual CustomResourceDefinition objects\",\n  },\n  kind: {\n    type: \"string\",\n    description:\n      \"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\n  },\n  apiVersion: {\n    type: \"string\",\n    description:\n      \"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\n  },\n  metadata: listMeta,\n};\n\nmodule.exports = {\n  \"/customresourcedefinition-apiextensions-v1beta1.json\": customResourceDefinition,\n  \"/customresourcedefinitionlist-apiextensions-v1beta1.json\": customResourceDefinitionList,\n};\n","// Note: These are not official or complete. I've basically just made them up based on documentation.\n// They are good enough for now but will probably need to be updated/expanded. \n// Hopefully people start publishing OpenAPI schemas soon.\n\nconst { objectMeta } = require(\"./common.js\");\nconst entityRule = {\n  type: \"object\",\n  properties: {\n    nets: {\n      type: [\"array\", \"null\"],\n    },\n    notNets: {\n      type: [\"array\", \"null\"],\n    },\n    selector: { type: \"string\" },\n    notSelector: { type: \"string\" },\n    namespaceSelector: { type: \"string\" },\n    ports: {\n      type: [\"array\", \"null\"],\n    },\n    notPorts: {\n      type: [\"array\", \"null\"],\n    },\n    serviceAccounts: {\n      names: {\n        type: [\"array\", \"null\"],\n      },\n      selector: { type: \"string\" },\n    },\n  },\n};\nconst rule = {\n  type: \"object\",\n  properties: {\n    action: {\n      type: \"string\",\n    },\n    metadata: { annotations: {} },\n    protocol: {\n      type: \"string\",\n    },\n    notProtocol: {\n      type: \"string\",\n    },\n    icmp: {\n      type: \"object\",\n    },\n    notIcmp: {\n      type: \"object\",\n    },\n    ipVersion: {\n      type: \"integer\",\n    },\n    destination: entityRule,\n    source: entityRule,\n  },\n};\nmodule.exports = {\n  \"/globalnetworkpolicy-crd-v1.json\": {\n    $schema: \"http://json-schema.org/draft-04/schema#\",\n    type: \"object\",\n    properties: {\n      apiVersion: {\n        type: \"string\",\n      },\n      kind: {\n        type: \"string\",\n      },\n      metadata: objectMeta,\n      spec: {\n        type: \"object\",\n        properties: {\n          selector: {\n            type: \"string\",\n          },\n          order: {\n            type: \"number\",\n          },\n          serviceAccountSelector: {\n            type: \"object\",\n          },\n          types: {\n            type: \"array\",\n            items: [],\n          },\n          ingress: {\n            type: [\"array\", \"null\"],\n            items: [rule],\n          },\n          egress: {\n            type: [\"array\", \"null\"],\n            items: [rule],\n          },\n        },\n      },\n    },\n    required: [\"apiVersion\", \"kind\", \"metadata\", \"spec\"],\n  },\n};\n","const azureIdentity = require(\"./azureIdentity\");\nconst azureIdentityBinding = require(\"./azureIdentityBinding\");\nconst azureIdentityException = require(\"./azureIdentityException\");\nconst sealedSecrets = require(\"./sealedSecrets\");\nconst networkPolicy = require(\"./networkPolicy\");\nconst customResourceDefinition = require(\"./customResourceDefinition\");\nconst istio = require(\"./istio\");\nconst globalnetworkpolicy = require(\"./globalNetworkPolicy\");\n\nconst schemas = {\n  ...azureIdentity,\n  ...azureIdentityException,\n  ...azureIdentityBinding,\n  ...sealedSecrets,\n  ...networkPolicy,\n  ...globalnetworkpolicy,\n  ...customResourceDefinition,\n  ...istio,\n};\n\nmodule.exports = schemas;\n","// ➜  tmp.cxdEWiLJbp git clone git@github.com:istio/api.git\n// ➜  tmp.cxdEWiLJbp echo '[' > schema.js; find api -iname '*.gen.json' -exec sh -c \"cat {}; echo ','\" \\; >> schema.js; echo ']' >> schema.js\nconst schemas = [\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Configuration affecting network reachability of a sidecar.\",\n      version: \"v1alpha3\",\n    },\n    components: {\n      schemas: {\n        \"istio.networking.v1alpha3.ClientTLSSettings\": {\n          description:\n            \"SSL/TLS related settings for upstream connections. See Envoy's [TLS context](https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/auth/cert.proto.html) for more details. These settings are common to both HTTP and TCP upstreams.\",\n          type: \"object\",\n          properties: {\n            mode: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ClientTLSSettings.TLSmode\",\n            },\n            clientCertificate: {\n              description:\n                \"REQUIRED if mode is `MUTUAL`. The path to the file holding the client-side TLS certificate to use. Should be empty if mode is `ISTIO_MUTUAL`.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            privateKey: {\n              description:\n                \"REQUIRED if mode is `MUTUAL`. The path to the file holding the client's private key. Should be empty if mode is `ISTIO_MUTUAL`.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            caCertificates: {\n              description:\n                \"OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate. If omitted, the proxy will not verify the server's certificate. Should be empty if mode is `ISTIO_MUTUAL`.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            credentialName: {\n              description:\n                \"The name of the secret that holds the TLS certs for the client including the CA certificates. Applicable only on Kubernetes. Secret must exist in the same namespace with the proxy using the certificates. The secret (of type `generic`)should contain the following keys and values: `key: \\u003cprivateKey\\u003e`, `cert: \\u003cserverCert\\u003e`, `cacert: \\u003cCACertificate\\u003e`. Secret of type tls for client certificates along with ca.crt key for CA certificates is also supported. Only one of client certificates and CA certificate or credentialName can be specified.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            subjectAltNames: {\n              description:\n                \"A list of alternate names to verify the subject identity in the certificate. If specified, the proxy will verify that the server certificate's subject alt name matches one of the specified values. If specified, this list overrides the value of subject_alt_names from the ServiceEntry.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            sni: {\n              description:\n                \"SNI string to present to the server during TLS handshake.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.PortSelector\": {\n          description:\n            \"PortSelector specifies the number of a port to be used for matching or selection for final routing.\",\n          type: \"object\",\n          properties: {\n            number: {\n              description: \"Valid port number\",\n              type: \"integer\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.ClientTLSSettings.TLSmode\": {\n          description: \"TLS connection mode\",\n          type: \"string\",\n          enum: [\"DISABLE\", \"SIMPLE\", \"MUTUAL\", \"ISTIO_MUTUAL\"],\n        },\n        \"istio.networking.v1alpha3.WorkloadSelector\": {\n          description:\n            \"`WorkloadSelector` specifies the criteria used to determine if the `Gateway`, `Sidecar`, or `EnvoyFilter` or `ServiceEntry` configuration can be applied to a proxy. The matching criteria includes the metadata associated with a proxy, workload instance info such as labels attached to the pod/VM, or any other info that the proxy provides to Istio during the initial handshake. If multiple conditions are specified, all conditions need to match in order for the workload instance to be selected. Currently, only label based selection mechanism is supported.\",\n          type: \"object\",\n          properties: {\n            labels: {\n              description:\n                \"One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied. The scope of label search is restricted to the configuration namespace in which the the resource is present.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.Port\": {\n          description:\n            \"Port describes the properties of a specific port of a service.\",\n          type: \"object\",\n          properties: {\n            number: {\n              description: \"A valid non-negative integer port number.\",\n              type: \"integer\",\n            },\n            name: {\n              description: \"Label assigned to the port.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            protocol: {\n              description:\n                \"The protocol exposed on the port. MUST BE one of HTTP|HTTPS|GRPC|HTTP2|MONGO|TCP|TLS. TLS implies the connection will be routed based on the SNI header to the destination without terminating the TLS connection.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.ServerTLSSettings\": {\n          type: \"object\",\n          properties: {\n            mode: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ServerTLSSettings.TLSmode\",\n            },\n            privateKey: {\n              description:\n                \"REQUIRED if mode is `SIMPLE` or `MUTUAL`. The path to the file holding the server's private key.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            caCertificates: {\n              description:\n                \"REQUIRED if mode is `MUTUAL`. The path to a file containing certificate authority certificates to use in verifying a presented client side certificate.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            credentialName: {\n              description:\n                \"For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates. Applicable only on Kubernetes. The secret (of type`generic`) should contain the following keys and values: `key: \\u003cprivateKey\\u003e`, `cert: \\u003cserverCert\\u003e`, `cacert: \\u003cCACertificate\\u003e`. Secret of type tls for server certificates along with ca.crt key for CA certificates is also supported. Only one of server certificates and CA certificate or credentialName can be specified.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            subjectAltNames: {\n              description:\n                \"A list of alternate names to verify the subject identity in the certificate presented by the client.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            httpsRedirect: {\n              description:\n                \"If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.\",\n              type: \"boolean\",\n            },\n            serverCertificate: {\n              description:\n                \"REQUIRED if mode is `SIMPLE` or `MUTUAL`. The path to the file holding the server-side TLS certificate to use.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            verifyCertificateSpki: {\n              description:\n                \"An optional list of base64-encoded SHA-256 hashes of the SKPIs of authorized client certificates. Note: When both verify_certificate_hash and verify_certificate_spki are specified, a hash matching either value will result in the certificate being accepted.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            verifyCertificateHash: {\n              description:\n                \"An optional list of hex-encoded SHA-256 hashes of the authorized client certificates. Both simple and colon separated formats are acceptable. Note: When both verify_certificate_hash and verify_certificate_spki are specified, a hash matching either value will result in the certificate being accepted.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            minProtocolVersion: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ServerTLSSettings.TLSProtocol\",\n            },\n            maxProtocolVersion: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ServerTLSSettings.TLSProtocol\",\n            },\n            cipherSuites: {\n              description:\n                \"Optional: If specified, only support the specified cipher list. Otherwise default to the default cipher list supported by Envoy.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.ServerTLSSettings.TLSmode\": {\n          description: \"TLS modes enforced by the proxy\",\n          type: \"string\",\n          enum: [\n            \"PASSTHROUGH\",\n            \"SIMPLE\",\n            \"MUTUAL\",\n            \"AUTO_PASSTHROUGH\",\n            \"ISTIO_MUTUAL\",\n          ],\n        },\n        \"istio.networking.v1alpha3.ServerTLSSettings.TLSProtocol\": {\n          description: \"TLS protocol versions.\",\n          type: \"string\",\n          enum: [\"TLS_AUTO\", \"TLSV1_0\", \"TLSV1_1\", \"TLSV1_2\", \"TLSV1_3\"],\n        },\n        \"istio.networking.v1alpha3.Sidecar\": {\n          description:\n            \"`Sidecar` describes the configuration of the sidecar proxy that mediates inbound and outbound communication of the workload instance to which it is attached.\",\n          type: \"object\",\n          properties: {\n            workloadSelector: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.WorkloadSelector\",\n            },\n            ingress: {\n              description:\n                \"Ingress specifies the configuration of the sidecar for processing inbound traffic to the attached workload instance. If omitted, Istio will automatically configure the sidecar based on the information about the workload obtained from the orchestration platform (e.g., exposed ports, services, etc.). If specified, inbound ports are configured if and only if the workload instance is associated with a service.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1alpha3.IstioIngressListener\",\n              },\n            },\n            egress: {\n              description:\n                \"Egress specifies the configuration of the sidecar for processing outbound traffic from the attached workload instance to other services in the mesh. If not specified, inherits the system detected defaults from the namespace-wide or the global default Sidecar.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1alpha3.IstioEgressListener\",\n              },\n            },\n            outboundTrafficPolicy: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.OutboundTrafficPolicy\",\n            },\n            localhost: {\n              $ref: \"#/components/schemas/istio.networking.v1alpha3.Localhost\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.IstioIngressListener\": {\n          description:\n            \"`IstioIngressListener` specifies the properties of an inbound traffic listener on the sidecar proxy attached to a workload instance.\",\n          type: \"object\",\n          properties: {\n            port: {\n              $ref: \"#/components/schemas/istio.networking.v1alpha3.Port\",\n            },\n            bind: {\n              description:\n                \"The IP to which the listener should be bound. Must be in the format `x.x.x.x`. Unix domain socket addresses are not allowed in the bind field for ingress listeners. If omitted, Istio will automatically configure the defaults based on imported services and the workload instances to which this configuration is applied to.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            defaultEndpoint: {\n              description:\n                \"The loopback IP endpoint or Unix domain socket to which traffic should be forwarded to. This configuration can be used to redirect traffic arriving at the bind `IP:Port` on the sidecar to a `localhost:port` or Unix domain socket where the application workload instance is listening for connections. Format should be `127.0.0.1:PORT` or `unix:///path/to/socket`\",\n              type: \"string\",\n              format: \"string\",\n            },\n            captureMode: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.CaptureMode\",\n            },\n            localhostClientTls: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ClientTLSSettings\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.IstioEgressListener\": {\n          description:\n            \"`IstioEgressListener` specifies the properties of an outbound traffic listener on the sidecar proxy attached to a workload instance.\",\n          type: \"object\",\n          properties: {\n            port: {\n              $ref: \"#/components/schemas/istio.networking.v1alpha3.Port\",\n            },\n            bind: {\n              description:\n                \"The IP or the Unix domain socket to which the listener should be bound to. Port MUST be specified if bind is not empty. Format: `x.x.x.x` or `unix:///path/to/uds` or `unix://@foobar` (Linux abstract namespace). If omitted, Istio will automatically configure the defaults based on imported services, the workload instances to which this configuration is applied to and the captureMode. If captureMode is `NONE`, bind will default to 127.0.0.1.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            hosts: {\n              description:\n                \"One or more service hosts exposed by the listener in `namespace/dnsName` format. Services in the specified namespace matching `dnsName` will be exposed. The corresponding service can be a service in the service registry (e.g., a Kubernetes or cloud foundry service) or a service specified using a `ServiceEntry` or `VirtualService` configuration. Any associated `DestinationRule` in the same namespace will also be used.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            captureMode: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.CaptureMode\",\n            },\n            localhostServerTls: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ServerTLSSettings\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.OutboundTrafficPolicy\": {\n          description:\n            \"`OutboundTrafficPolicy` sets the default behavior of the sidecar for handling outbound traffic from the application. If your application uses one or more external services that are not known apriori, setting the policy to `ALLOW_ANY` will cause the sidecars to route any unknown traffic originating from the application to its requested destination. Users are strongly encouraged to use `ServiceEntry` configurations to explicitly declare any external dependencies, instead of using `ALLOW_ANY`, so that traffic to these services can be monitored.\",\n          type: \"object\",\n          properties: {\n            mode: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.OutboundTrafficPolicy.Mode\",\n            },\n            egressProxy: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.Destination\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.Localhost\": {\n          description:\n            \"`Localhost` describes the sidecar settings related to the communication between the sidecar and the workload it is attached to in a Kubernetes Pod or a VM. These settings apply by default to all ingress and egress listeners in a sidecar unless overridden.\",\n          type: \"object\",\n          properties: {\n            clientTls: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ClientTLSSettings\",\n            },\n            serverTls: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ServerTLSSettings\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.CaptureMode\": {\n          description:\n            \"`CaptureMode` describes how traffic to a listener is expected to be captured. Applicable only when the listener is bound to an IP.\",\n          type: \"string\",\n          enum: [\"DEFAULT\", \"IPTABLES\", \"NONE\"],\n        },\n        \"istio.networking.v1alpha3.OutboundTrafficPolicy.Mode\": {\n          type: \"string\",\n          enum: [\"REGISTRY_ONLY\", \"ALLOW_ANY\"],\n        },\n        \"istio.networking.v1alpha3.Destination\": {\n          description:\n            \"Destination indicates the network addressable service to which the request/connection will be sent after processing a routing rule. The destination.host should unambiguously refer to a service in the service registry. Istio's service registry is composed of all the services found in the platform's service registry (e.g., Kubernetes services, Consul services), as well as services declared through the [ServiceEntry](https://istio.io/docs/reference/config/networking/service-entry/#ServiceEntry) resource.\",\n          type: \"object\",\n          properties: {\n            host: {\n              description:\n                \"The name of a service from the service registry. Service names are looked up from the platform's service registry (e.g., Kubernetes services, Consul services, etc.) and from the hosts declared by [ServiceEntry](https://istio.io/docs/reference/config/networking/service-entry/#ServiceEntry). Traffic forwarded to destinations that are not found in either of the two, will be dropped.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            port: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.PortSelector\",\n            },\n            subset: {\n              description:\n                \"The name of a subset within the service. Applicable only to services within the mesh. The subset must be defined in a corresponding DestinationRule.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Customizing Envoy configuration generated by Istio.\",\n      version: \"v1alpha3\",\n    },\n    components: {\n      schemas: {\n        \"istio.networking.v1alpha3.EnvoyFilter\": {\n          description:\n            \"EnvoyFilter provides a mechanism to customize the Envoy configuration generated by Istio Pilot.\",\n          type: \"object\",\n          properties: {\n            workloadSelector: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.WorkloadSelector\",\n            },\n            configPatches: {\n              description: \"One or more patches with match conditions.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1alpha3.EnvoyFilter.EnvoyConfigObjectPatch\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.WorkloadSelector\": {\n          description:\n            \"`WorkloadSelector` specifies the criteria used to determine if the `Gateway`, `Sidecar`, or `EnvoyFilter` or `ServiceEntry` configuration can be applied to a proxy. The matching criteria includes the metadata associated with a proxy, workload instance info such as labels attached to the pod/VM, or any other info that the proxy provides to Istio during the initial handshake. If multiple conditions are specified, all conditions need to match in order for the workload instance to be selected. Currently, only label based selection mechanism is supported.\",\n          type: \"object\",\n          properties: {\n            labels: {\n              description:\n                \"One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied. The scope of label search is restricted to the configuration namespace in which the the resource is present.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.EnvoyFilter.EnvoyConfigObjectPatch\": {\n          description: \"Changes to be made to various envoy config objects.\",\n          type: \"object\",\n          properties: {\n            applyTo: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.EnvoyFilter.ApplyTo\",\n            },\n            match: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.EnvoyFilter.EnvoyConfigObjectMatch\",\n            },\n            patch: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.EnvoyFilter.Patch\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.EnvoyFilter.ApplyTo\": {\n          description:\n            \"ApplyTo specifies where in the Envoy configuration, the given patch should be applied.\",\n          type: \"string\",\n          enum: [\n            \"INVALID\",\n            \"LISTENER\",\n            \"FILTER_CHAIN\",\n            \"NETWORK_FILTER\",\n            \"HTTP_FILTER\",\n            \"ROUTE_CONFIGURATION\",\n            \"VIRTUAL_HOST\",\n            \"HTTP_ROUTE\",\n            \"CLUSTER\",\n          ],\n        },\n        \"istio.networking.v1alpha3.EnvoyFilter.PatchContext\": {\n          description:\n            \"PatchContext selects a class of configurations based on the traffic flow direction and workload type.\",\n          type: \"string\",\n          enum: [\"ANY\", \"SIDECAR_INBOUND\", \"SIDECAR_OUTBOUND\", \"GATEWAY\"],\n        },\n        \"istio.networking.v1alpha3.EnvoyFilter.ProxyMatch\": {\n          description: \"One or more properties of the proxy to match on.\",\n          type: \"object\",\n          properties: {\n            proxyVersion: {\n              description:\n                \"A regular expression in golang regex format (RE2) that can be used to select proxies using a specific version of istio proxy. The Istio version for a given proxy is obtained from the node metadata field ISTIO_VERSION supplied by the proxy when connecting to Pilot. This value is embedded as an environment variable (ISTIO_META_ISTIO_VERSION) in the Istio proxy docker image. Custom proxy implementations should provide this metadata variable to take advantage of the Istio version check option.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            metadata: {\n              description:\n                \"Match on the node metadata supplied by a proxy when connecting to Istio Pilot. Note that while Envoy's node metadata is of type Struct, only string key-value pairs are processed by Pilot. All keys specified in the metadata must match with exact values. The match will fail if any of the specified keys are absent or the values fail to match.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.EnvoyFilter.ClusterMatch\": {\n          description:\n            \"Conditions specified in ClusterMatch must be met for the patch to be applied to a cluster.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                'The exact name of the cluster to match. To match a specific cluster by name, such as the internally generated \"Passthrough\" cluster, leave all fields in clusterMatch empty, except the name.',\n              type: \"string\",\n              format: \"string\",\n            },\n            portNumber: {\n              description:\n                \"The service port for which this cluster was generated. If omitted, applies to clusters for any port.\",\n              type: \"integer\",\n            },\n            service: {\n              description:\n                \"The fully qualified service name for this cluster. If omitted, applies to clusters for any service. For services defined through service entries, the service name is same as the hosts defined in the service entry.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            subset: {\n              description:\n                \"The subset associated with the service. If omitted, applies to clusters for any subset of a service.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.EnvoyFilter.RouteConfigurationMatch\": {\n          description:\n            \"Conditions specified in RouteConfigurationMatch must be met for the patch to be applied to a route configuration object or a specific virtual host within the route configuration.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                'Route configuration name to match on. Can be used to match a specific route configuration by name, such as the internally generated \"http_proxy\" route configuration for all sidecars.',\n              type: \"string\",\n              format: \"string\",\n            },\n            portNumber: {\n              description:\n                \"The service port number or gateway server port number for which this route configuration was generated. If omitted, applies to route configurations for all ports.\",\n              type: \"integer\",\n            },\n            portName: {\n              description:\n                \"Applicable only for GATEWAY context. The gateway server port name for which this route configuration was generated.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            gateway: {\n              description:\n                \"The Istio gateway config's namespace/name for which this route configuration was generated. Applies only if the context is GATEWAY. Should be in the namespace/name format. Use this field in conjunction with the portNumber and portName to accurately select the Envoy route configuration for a specific HTTPS server within a gateway config object.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            vhost: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.EnvoyFilter.RouteConfigurationMatch.VirtualHostMatch\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.EnvoyFilter.RouteConfigurationMatch.VirtualHostMatch\": {\n          description:\n            \"Match a specific virtual host inside a route configuration.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"The VirtualHosts objects generated by Istio are named as host:port, where the host typically corresponds to the VirtualService's host field or the hostname of a service in the registry.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            route: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.EnvoyFilter.RouteConfigurationMatch.RouteMatch\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.EnvoyFilter.RouteConfigurationMatch.RouteMatch\": {\n          description:\n            \"Match a specific route inside a virtual host in a route configuration.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                'The Route objects generated by default are named as \"default\". Route objects generated using a virtual service will carry the name used in the virtual service\\'s HTTP routes.',\n              type: \"string\",\n              format: \"string\",\n            },\n            action: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.EnvoyFilter.RouteConfigurationMatch.RouteMatch.Action\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.EnvoyFilter.RouteConfigurationMatch.RouteMatch.Action\": {\n          description:\n            \"Action refers to the route action taken by Envoy when a http route matches.\",\n          type: \"string\",\n          enum: [\"ANY\", \"ROUTE\", \"REDIRECT\", \"DIRECT_RESPONSE\"],\n        },\n        \"istio.networking.v1alpha3.EnvoyFilter.ListenerMatch\": {\n          description:\n            \"Conditions specified in a listener match must be met for the patch to be applied to a specific listener across all filter chains, or a specific filter chain inside the listener.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"Match a specific listener by its name. The listeners generated by Pilot are typically named as IP:Port.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            portNumber: {\n              description:\n                \"The service port/gateway port to which traffic is being sent/received. If not specified, matches all listeners. Even though inbound listeners are generated for the instance/pod ports, only service ports should be used to match listeners.\",\n              type: \"integer\",\n            },\n            portName: {\n              description:\n                \"Instead of using specific port numbers, a set of ports matching a given service's port name can be selected. Matching is case insensitive. Not implemented. $hide_from_docs\",\n              type: \"string\",\n              format: \"string\",\n            },\n            filterChain: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.EnvoyFilter.ListenerMatch.FilterChainMatch\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.EnvoyFilter.ListenerMatch.FilterChainMatch\": {\n          description:\n            \"For listeners with multiple filter chains (e.g., inbound listeners on sidecars with permissive mTLS, gateway listeners with multiple SNI matches), the filter chain match can be used to select a specific filter chain to patch.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description: \"The name assigned to the filter chain.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            sni: {\n              description:\n                \"The SNI value used by a filter chain's match condition. This condition will evaluate to false if the filter chain has no sni match.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            transportProtocol: {\n              description:\n                \"Applies only to SIDECAR_INBOUND context. If non-empty, a transport protocol to consider when determining a filter chain match. This value will be compared against the transport protocol of a new connection, when it's detected by the tls_inspector listener filter.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            applicationProtocols: {\n              description:\n                \"Applies only to sidecars. If non-empty, a comma separated set of application protocols to consider when determining a filter chain match. This value will be compared against the application protocols of a new connection, when it's detected by one of the listener filters such as the http_inspector.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            filter: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.EnvoyFilter.ListenerMatch.FilterMatch\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.EnvoyFilter.ListenerMatch.FilterMatch\": {\n          description:\n            \"Conditions to match a specific filter within a filter chain.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description: \"The filter name to match on.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            subFilter: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.EnvoyFilter.ListenerMatch.SubFilterMatch\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.EnvoyFilter.ListenerMatch.SubFilterMatch\": {\n          description:\n            \"Conditions to match a specific filter within another filter. This field is typically useful to match a HTTP filter inside the envoy.http_connection_manager network filter. This could also be applicable for thrift filters.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description: \"The filter name to match on.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.EnvoyFilter.Patch\": {\n          description:\n            \"Patch specifies how the selected object should be modified.\",\n          type: \"object\",\n          properties: {\n            operation: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.EnvoyFilter.Patch.Operation\",\n            },\n            value: {\n              description:\n                \"The JSON config of the object being patched. This will be merged using json merge semantics with the existing proto in the path.\",\n              type: \"object\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.EnvoyFilter.Patch.Operation\": {\n          description:\n            \"Operation denotes how the patch should be applied to the selected configuration.\",\n          type: \"string\",\n          enum: [\n            \"INVALID\",\n            \"MERGE\",\n            \"ADD\",\n            \"REMOVE\",\n            \"INSERT_BEFORE\",\n            \"INSERT_AFTER\",\n            \"INSERT_FIRST\",\n          ],\n        },\n        \"istio.networking.v1alpha3.EnvoyFilter.EnvoyConfigObjectMatch\": {\n          description:\n            \"One or more match conditions to be met before a patch is applied to the generated configuration for a given proxy.\",\n          type: \"object\",\n          properties: {\n            context: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.EnvoyFilter.PatchContext\",\n            },\n            proxy: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.EnvoyFilter.ProxyMatch\",\n            },\n          },\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"listener\"],\n                    properties: {\n                      listener: {\n                        $ref:\n                          \"#/components/schemas/istio.networking.v1alpha3.EnvoyFilter.ListenerMatch\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"routeConfiguration\"],\n                    properties: {\n                      routeConfiguration: {\n                        $ref:\n                          \"#/components/schemas/istio.networking.v1alpha3.EnvoyFilter.RouteConfigurationMatch\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"cluster\"],\n                    properties: {\n                      cluster: {\n                        $ref:\n                          \"#/components/schemas/istio.networking.v1alpha3.EnvoyFilter.ClusterMatch\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"listener\"],\n              properties: {\n                listener: {\n                  $ref:\n                    \"#/components/schemas/istio.networking.v1alpha3.EnvoyFilter.ListenerMatch\",\n                },\n              },\n            },\n            {\n              required: [\"routeConfiguration\"],\n              properties: {\n                routeConfiguration: {\n                  $ref:\n                    \"#/components/schemas/istio.networking.v1alpha3.EnvoyFilter.RouteConfigurationMatch\",\n                },\n              },\n            },\n            {\n              required: [\"cluster\"],\n              properties: {\n                cluster: {\n                  $ref:\n                    \"#/components/schemas/istio.networking.v1alpha3.EnvoyFilter.ClusterMatch\",\n                },\n              },\n            },\n          ],\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Configuration affecting service registry.\",\n      version: \"v1alpha3\",\n    },\n    components: {\n      schemas: {\n        \"istio.networking.v1alpha3.WorkloadSelector\": {\n          description:\n            \"`WorkloadSelector` specifies the criteria used to determine if the `Gateway`, `Sidecar`, or `EnvoyFilter` or `ServiceEntry` configuration can be applied to a proxy. The matching criteria includes the metadata associated with a proxy, workload instance info such as labels attached to the pod/VM, or any other info that the proxy provides to Istio during the initial handshake. If multiple conditions are specified, all conditions need to match in order for the workload instance to be selected. Currently, only label based selection mechanism is supported.\",\n          type: \"object\",\n          properties: {\n            labels: {\n              description:\n                \"One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied. The scope of label search is restricted to the configuration namespace in which the the resource is present.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.Port\": {\n          description:\n            \"Port describes the properties of a specific port of a service.\",\n          type: \"object\",\n          properties: {\n            number: {\n              description: \"A valid non-negative integer port number.\",\n              type: \"integer\",\n            },\n            name: {\n              description: \"Label assigned to the port.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            protocol: {\n              description:\n                \"The protocol exposed on the port. MUST BE one of HTTP|HTTPS|GRPC|HTTP2|MONGO|TCP|TLS. TLS implies the connection will be routed based on the SNI header to the destination without terminating the TLS connection.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.ServiceEntry\": {\n          description:\n            \"ServiceEntry enables adding additional entries into Istio's internal service registry.\",\n          type: \"object\",\n          properties: {\n            exportTo: {\n              description:\n                \"A list of namespaces to which this service is exported. Exporting a service allows it to be used by sidecars, gateways and virtual services defined in other namespaces. This feature provides a mechanism for service owners and mesh administrators to control the visibility of services across namespace boundaries.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            subjectAltNames: {\n              description:\n                \"If specified, the proxy will verify that the server certificate's subject alternate name matches one of the specified values.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            workloadSelector: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.WorkloadSelector\",\n            },\n            hosts: {\n              description:\n                \"The hosts associated with the ServiceEntry. Could be a DNS name with wildcard prefix.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            addresses: {\n              description:\n                \"The virtual IP addresses associated with the service. Could be CIDR prefix. For HTTP traffic, generated route configurations will include http route domains for both the `addresses` and `hosts` field values and the destination will be identified based on the HTTP Host/Authority header. If one or more IP addresses are specified, the incoming traffic will be identified as belonging to this service if the destination IP matches the IP/CIDRs specified in the addresses field. If the Addresses field is empty, traffic will be identified solely based on the destination port. In such scenarios, the port on which the service is being accessed must not be shared by any other service in the mesh. In other words, the sidecar will behave as a simple TCP proxy, forwarding incoming traffic on a specified port to the specified destination endpoint IP/host. Unix domain socket addresses are not supported in this field.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            ports: {\n              description:\n                \"The ports associated with the external service. If the Endpoints are Unix domain socket addresses, there must be exactly one port.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.networking.v1alpha3.Port\",\n              },\n            },\n            location: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ServiceEntry.Location\",\n            },\n            resolution: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ServiceEntry.Resolution\",\n            },\n            endpoints: {\n              description:\n                \"One or more endpoints associated with the service. Only one of `endpoints` or `workloadSelector` can be specified.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1alpha3.WorkloadEntry\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.ServiceEntry.Location\": {\n          description:\n            \"Location specifies whether the service is part of Istio mesh or outside the mesh. Location determines the behavior of several features, such as service-to-service mTLS authentication, policy enforcement, etc. When communicating with services outside the mesh, Istio's mTLS authentication is disabled, and policy enforcement is performed on the client-side as opposed to server-side.\",\n          type: \"string\",\n          enum: [\"MESH_EXTERNAL\", \"MESH_INTERNAL\"],\n        },\n        \"istio.networking.v1alpha3.ServiceEntry.Resolution\": {\n          description:\n            \"Resolution determines how the proxy will resolve the IP addresses of the network endpoints associated with the service, so that it can route to one of them. The resolution mode specified here has no impact on how the application resolves the IP address associated with the service. The application may still have to use DNS to resolve the service to an IP so that the outbound traffic can be captured by the Proxy. Alternatively, for HTTP services, the application could directly communicate with the proxy (e.g., by setting HTTP_PROXY) to talk to these services.\",\n          type: \"string\",\n          enum: [\"NONE\", \"STATIC\", \"DNS\"],\n        },\n        \"istio.networking.v1alpha3.WorkloadEntry\": {\n          description:\n            \"WorkloadEntry enables specifying the properties of a single non-Kubernetes workload such a VM or a bare metal services that can be referred to by service entries.\",\n          type: \"object\",\n          properties: {\n            labels: {\n              description: \"One or more labels associated with the endpoint.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            ports: {\n              description:\n                \"Set of ports associated with the endpoint. The ports must be associated with a port name that was declared as part of the service. Do not use for `unix://` addresses.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"integer\",\n              },\n            },\n            weight: {\n              description:\n                \"The load balancing weight associated with the endpoint. Endpoints with higher weights will receive proportionally higher traffic.\",\n              type: \"integer\",\n            },\n            address: {\n              description:\n                \"Address associated with the network endpoint without the port. Domain names can be used if and only if the resolution is set to DNS, and must be fully-qualified without wildcards. Use the form unix:///absolute/path/to/socket for Unix domain socket endpoints.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            network: {\n              description:\n                \"Network enables Istio to group endpoints resident in the same L3 domain/network. All endpoints in the same network are assumed to be directly reachable from one another. When endpoints in different networks cannot reach each other directly, an Istio Gateway can be used to establish connectivity (usually using the `AUTO_PASSTHROUGH` mode in a Gateway Server). This is an advanced configuration used typically for spanning an Istio mesh over multiple clusters.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            locality: {\n              description:\n                'The locality associated with the endpoint. A locality corresponds to a failure domain (e.g., country/region/zone). Arbitrary failure domain hierarchies can be represented by separating each encapsulating failure domain by /. For example, the locality of an an endpoint in US, in US-East-1 region, within availability zone az-1, in data center rack r11 can be represented as us/us-east-1/az-1/r11. Istio will configure the sidecar to route to endpoints within the same locality as the sidecar. If none of the endpoints in the locality are available, endpoints parent locality (but within the same network ID) will be chosen. For example, if there are two endpoints in same network (networkID \"n1\"), say e1 with locality us/us-east-1/az-1/r11 and e2 with locality us/us-east-1/az-2/r12, a sidecar from us/us-east-1/az-1/r11 locality will prefer e1 from the same locality over e2 from a different locality. Endpoint e2 could be the IP associated with a gateway (that bridges networks n1 and n2), or the IP associated with a standard service endpoint.',\n              type: \"string\",\n              format: \"string\",\n            },\n            serviceAccount: {\n              description:\n                \"The service account associated with the workload if a sidecar is present in the workload. The service account must be present in the same namespace as the configuration ( WorkloadEntry or a ServiceEntry)\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Configuration affecting edge load balancer.\",\n      version: \"v1alpha3\",\n    },\n    components: {\n      schemas: {\n        \"istio.networking.v1alpha3.Gateway\": {\n          description:\n            \"Gateway describes a load balancer operating at the edge of the mesh receiving incoming or outgoing HTTP/TCP connections.\",\n          type: \"object\",\n          properties: {\n            servers: {\n              description: \"A list of server specifications.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.networking.v1alpha3.Server\",\n              },\n            },\n            selector: {\n              description:\n                \"One or more labels that indicate a specific set of pods/VMs on which this gateway configuration should be applied. The scope of label search is restricted to the configuration namespace in which the the resource is present. In other words, the Gateway resource must reside in the same namespace as the gateway workload instance. If selector is nil, the Gateway will be applied to all workloads.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.Server\": {\n          description:\n            \"`Server` describes the properties of the proxy on a given load balancer port. For example,\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"An optional name of the server, when set must be unique across all servers. This will be used for variety of purposes like prefixing stats generated with this name etc.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            tls: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ServerTLSSettings\",\n            },\n            port: {\n              $ref: \"#/components/schemas/istio.networking.v1alpha3.Port\",\n            },\n            bind: {\n              description:\n                \"The ip or the Unix domain socket to which the listener should be bound to. Format: `x.x.x.x` or `unix:///path/to/uds` or `unix://@foobar` (Linux abstract namespace). When using Unix domain sockets, the port number should be 0.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            hosts: {\n              description:\n                \"One or more hosts exposed by this gateway. While typically applicable to HTTP services, it can also be used for TCP services using TLS with SNI. A host is specified as a `dnsName` with an optional `namespace/` prefix. The `dnsName` should be specified using FQDN format, optionally including a wildcard character in the left-most component (e.g., `prod/*.example.com`). Set the `dnsName` to `*` to select all `VirtualService` hosts from the specified namespace (e.g.,`prod/*`).\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            defaultEndpoint: {\n              description:\n                \"The loopback IP endpoint or Unix domain socket to which traffic should be forwarded to by default. Format should be `127.0.0.1:PORT` or `unix:///path/to/socket` or `unix://@foobar` (Linux abstract namespace). NOT IMPLEMENTED. $hide_from_docs\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.Port\": {\n          description:\n            \"Port describes the properties of a specific port of a service.\",\n          type: \"object\",\n          properties: {\n            number: {\n              description: \"A valid non-negative integer port number.\",\n              type: \"integer\",\n            },\n            name: {\n              description: \"Label assigned to the port.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            protocol: {\n              description:\n                \"The protocol exposed on the port. MUST BE one of HTTP|HTTPS|GRPC|HTTP2|MONGO|TCP|TLS. TLS implies the connection will be routed based on the SNI header to the destination without terminating the TLS connection.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.ServerTLSSettings\": {\n          type: \"object\",\n          properties: {\n            mode: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ServerTLSSettings.TLSmode\",\n            },\n            privateKey: {\n              description:\n                \"REQUIRED if mode is `SIMPLE` or `MUTUAL`. The path to the file holding the server's private key.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            caCertificates: {\n              description:\n                \"REQUIRED if mode is `MUTUAL`. The path to a file containing certificate authority certificates to use in verifying a presented client side certificate.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            credentialName: {\n              description:\n                \"For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates. Applicable only on Kubernetes. The secret (of type`generic`) should contain the following keys and values: `key: \\u003cprivateKey\\u003e`, `cert: \\u003cserverCert\\u003e`, `cacert: \\u003cCACertificate\\u003e`. Secret of type tls for server certificates along with ca.crt key for CA certificates is also supported. Only one of server certificates and CA certificate or credentialName can be specified.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            subjectAltNames: {\n              description:\n                \"A list of alternate names to verify the subject identity in the certificate presented by the client.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            httpsRedirect: {\n              description:\n                \"If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.\",\n              type: \"boolean\",\n            },\n            serverCertificate: {\n              description:\n                \"REQUIRED if mode is `SIMPLE` or `MUTUAL`. The path to the file holding the server-side TLS certificate to use.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            verifyCertificateSpki: {\n              description:\n                \"An optional list of base64-encoded SHA-256 hashes of the SKPIs of authorized client certificates. Note: When both verify_certificate_hash and verify_certificate_spki are specified, a hash matching either value will result in the certificate being accepted.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            verifyCertificateHash: {\n              description:\n                \"An optional list of hex-encoded SHA-256 hashes of the authorized client certificates. Both simple and colon separated formats are acceptable. Note: When both verify_certificate_hash and verify_certificate_spki are specified, a hash matching either value will result in the certificate being accepted.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            minProtocolVersion: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ServerTLSSettings.TLSProtocol\",\n            },\n            maxProtocolVersion: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ServerTLSSettings.TLSProtocol\",\n            },\n            cipherSuites: {\n              description:\n                \"Optional: If specified, only support the specified cipher list. Otherwise default to the default cipher list supported by Envoy.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.ServerTLSSettings.TLSmode\": {\n          description: \"TLS modes enforced by the proxy\",\n          type: \"string\",\n          enum: [\n            \"PASSTHROUGH\",\n            \"SIMPLE\",\n            \"MUTUAL\",\n            \"AUTO_PASSTHROUGH\",\n            \"ISTIO_MUTUAL\",\n          ],\n        },\n        \"istio.networking.v1alpha3.ServerTLSSettings.TLSProtocol\": {\n          description: \"TLS protocol versions.\",\n          type: \"string\",\n          enum: [\"TLS_AUTO\", \"TLSV1_0\", \"TLSV1_1\", \"TLSV1_2\", \"TLSV1_3\"],\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Configuration affecting VMs onboarded into the mesh.\",\n      version: \"v1alpha3\",\n    },\n    components: {\n      schemas: {\n        \"istio.networking.v1alpha3.WorkloadEntry\": {\n          description:\n            \"WorkloadEntry enables specifying the properties of a single non-Kubernetes workload such a VM or a bare metal services that can be referred to by service entries.\",\n          type: \"object\",\n          properties: {\n            labels: {\n              description: \"One or more labels associated with the endpoint.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            ports: {\n              description:\n                \"Set of ports associated with the endpoint. The ports must be associated with a port name that was declared as part of the service. Do not use for `unix://` addresses.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"integer\",\n              },\n            },\n            weight: {\n              description:\n                \"The load balancing weight associated with the endpoint. Endpoints with higher weights will receive proportionally higher traffic.\",\n              type: \"integer\",\n            },\n            address: {\n              description:\n                \"Address associated with the network endpoint without the port. Domain names can be used if and only if the resolution is set to DNS, and must be fully-qualified without wildcards. Use the form unix:///absolute/path/to/socket for Unix domain socket endpoints.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            network: {\n              description:\n                \"Network enables Istio to group endpoints resident in the same L3 domain/network. All endpoints in the same network are assumed to be directly reachable from one another. When endpoints in different networks cannot reach each other directly, an Istio Gateway can be used to establish connectivity (usually using the `AUTO_PASSTHROUGH` mode in a Gateway Server). This is an advanced configuration used typically for spanning an Istio mesh over multiple clusters.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            locality: {\n              description:\n                'The locality associated with the endpoint. A locality corresponds to a failure domain (e.g., country/region/zone). Arbitrary failure domain hierarchies can be represented by separating each encapsulating failure domain by /. For example, the locality of an an endpoint in US, in US-East-1 region, within availability zone az-1, in data center rack r11 can be represented as us/us-east-1/az-1/r11. Istio will configure the sidecar to route to endpoints within the same locality as the sidecar. If none of the endpoints in the locality are available, endpoints parent locality (but within the same network ID) will be chosen. For example, if there are two endpoints in same network (networkID \"n1\"), say e1 with locality us/us-east-1/az-1/r11 and e2 with locality us/us-east-1/az-2/r12, a sidecar from us/us-east-1/az-1/r11 locality will prefer e1 from the same locality over e2 from a different locality. Endpoint e2 could be the IP associated with a gateway (that bridges networks n1 and n2), or the IP associated with a standard service endpoint.',\n              type: \"string\",\n              format: \"string\",\n            },\n            serviceAccount: {\n              description:\n                \"The service account associated with the workload if a sidecar is present in the workload. The service account must be present in the same namespace as the configuration ( WorkloadEntry or a ServiceEntry)\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Configuration affecting label/content routing, sni routing, etc.\",\n      version: \"v1alpha3\",\n    },\n    components: {\n      schemas: {\n        \"istio.networking.v1alpha3.PortSelector\": {\n          description:\n            \"PortSelector specifies the number of a port to be used for matching or selection for final routing.\",\n          type: \"object\",\n          properties: {\n            number: {\n              description: \"Valid port number\",\n              type: \"integer\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.Destination\": {\n          description:\n            \"Destination indicates the network addressable service to which the request/connection will be sent after processing a routing rule. The destination.host should unambiguously refer to a service in the service registry. Istio's service registry is composed of all the services found in the platform's service registry (e.g., Kubernetes services, Consul services), as well as services declared through the [ServiceEntry](https://istio.io/docs/reference/config/networking/service-entry/#ServiceEntry) resource.\",\n          type: \"object\",\n          properties: {\n            host: {\n              description:\n                \"The name of a service from the service registry. Service names are looked up from the platform's service registry (e.g., Kubernetes services, Consul services, etc.) and from the hosts declared by [ServiceEntry](https://istio.io/docs/reference/config/networking/service-entry/#ServiceEntry). Traffic forwarded to destinations that are not found in either of the two, will be dropped.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            port: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.PortSelector\",\n            },\n            subset: {\n              description:\n                \"The name of a subset within the service. Applicable only to services within the mesh. The subset must be defined in a corresponding DestinationRule.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.VirtualService\": {\n          description: \"Configuration affecting traffic routing.\",\n          type: \"object\",\n          properties: {\n            exportTo: {\n              description:\n                \"A list of namespaces to which this virtual service is exported. Exporting a virtual service allows it to be used by sidecars and gateways defined in other namespaces. This feature provides a mechanism for service owners and mesh administrators to control the visibility of virtual services across namespace boundaries.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            tls: {\n              description:\n                \"An ordered list of route rule for non-terminated TLS \\u0026 HTTPS traffic. Routing is typically performed using the SNI value presented by the ClientHello message. TLS routes will be applied to platform service ports named 'https-*', 'tls-*', unterminated gateway ports using HTTPS/TLS protocols (i.e. with \\\"passthrough\\\" TLS mode) and service entry ports using HTTPS/TLS protocols. The first rule matching an incoming request is used. NOTE: Traffic 'https-*' or 'tls-*' ports without associated virtual service will be treated as opaque TCP traffic.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.networking.v1alpha3.TLSRoute\",\n              },\n            },\n            tcp: {\n              description:\n                \"An ordered list of route rules for opaque TCP traffic. TCP routes will be applied to any port that is not a HTTP or TLS port. The first rule matching an incoming request is used.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.networking.v1alpha3.TCPRoute\",\n              },\n            },\n            http: {\n              description:\n                \"An ordered list of route rules for HTTP traffic. HTTP routes will be applied to platform service ports named 'http-*'/'http2-*'/'grpc-*', gateway ports with protocol HTTP/HTTP2/GRPC/ TLS-terminated-HTTPS and service entry ports using HTTP/HTTP2/GRPC protocols. The first rule matching an incoming request is used.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1alpha3.HTTPRoute\",\n              },\n            },\n            hosts: {\n              description:\n                \"The destination hosts to which traffic is being sent. Could be a DNS name with wildcard prefix or an IP address. Depending on the platform, short-names can also be used instead of a FQDN (i.e. has no dots in the name). In such a scenario, the FQDN of the host would be derived based on the underlying platform.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            gateways: {\n              description:\n                \"The names of gateways and sidecars that should apply these routes. Gateways in other namespaces may be referred to by `\\u003cgateway namespace\\u003e/\\u003cgateway name\\u003e`; specifying a gateway with no namespace qualifier is the same as specifying the VirtualService's namespace. A single VirtualService is used for sidecars inside the mesh as well as for one or more gateways. The selection condition imposed by this field can be overridden using the source field in the match conditions of protocol-specific routes. The reserved word `mesh` is used to imply all the sidecars in the mesh. When this field is omitted, the default gateway (`mesh`) will be used, which would apply the rule to all sidecars in the mesh. If a list of gateway names is provided, the rules will apply only to the gateways. To apply the rules to both gateways and sidecars, specify `mesh` as one of the gateway names.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.HTTPRoute\": {\n          description:\n            \"Describes match conditions and actions for routing HTTP/1.1, HTTP2, and gRPC traffic. See VirtualService for usage examples.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"The name assigned to the route for debugging purposes. The route's name will be concatenated with the match's name and will be logged in the access logs for requests matching this route/match.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            route: {\n              description:\n                \"A HTTP rule can either redirect or forward (default) traffic. The forwarding target can be one of several versions of a service (see glossary in beginning of document). Weights associated with the service version determine the proportion of traffic it receives.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1alpha3.HTTPRouteDestination\",\n              },\n            },\n            match: {\n              description:\n                \"Match conditions to be satisfied for the rule to be activated. All conditions inside a single match block have AND semantics, while the list of match blocks have OR semantics. The rule is matched if any one of the match blocks succeed.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1alpha3.HTTPMatchRequest\",\n              },\n            },\n            redirect: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.HTTPRedirect\",\n            },\n            delegate: {\n              $ref: \"#/components/schemas/istio.networking.v1alpha3.Delegate\",\n            },\n            rewrite: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.HTTPRewrite\",\n            },\n            timeout: {\n              description: \"Timeout for HTTP requests.\",\n              type: \"string\",\n            },\n            retries: {\n              $ref: \"#/components/schemas/istio.networking.v1alpha3.HTTPRetry\",\n            },\n            fault: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.HTTPFaultInjection\",\n            },\n            mirror: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.Destination\",\n            },\n            mirrorPercent: {\n              description:\n                \"Percentage of the traffic to be mirrored by the `mirror` field. Use of integer `mirror_percent` value is deprecated. Use the double `mirror_percentage` field instead\",\n              type: \"integer\",\n              deprecated: true,\n              nullable: true,\n            },\n            mirrorPercentage: {\n              $ref: \"#/components/schemas/istio.networking.v1alpha3.Percent\",\n            },\n            corsPolicy: {\n              $ref: \"#/components/schemas/istio.networking.v1alpha3.CorsPolicy\",\n            },\n            headers: {\n              $ref: \"#/components/schemas/istio.networking.v1alpha3.Headers\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.TLSRoute\": {\n          description:\n            'Describes match conditions and actions for routing unterminated TLS traffic (TLS/HTTPS) The following routing rule forwards unterminated TLS traffic arriving at port 443 of gateway called \"mygateway\" to internal services in the mesh based on the SNI value.',\n          type: \"object\",\n          properties: {\n            route: {\n              description:\n                \"The destination to which the connection should be forwarded to.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1alpha3.RouteDestination\",\n              },\n            },\n            match: {\n              description:\n                \"Match conditions to be satisfied for the rule to be activated. All conditions inside a single match block have AND semantics, while the list of match blocks have OR semantics. The rule is matched if any one of the match blocks succeed.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1alpha3.TLSMatchAttributes\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.TCPRoute\": {\n          description:\n            \"Describes match conditions and actions for routing TCP traffic. The following routing rule forwards traffic arriving at port 27017 for mongo.prod.svc.cluster.local to another Mongo server on port 5555.\",\n          type: \"object\",\n          properties: {\n            route: {\n              description:\n                \"The destination to which the connection should be forwarded to.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1alpha3.RouteDestination\",\n              },\n            },\n            match: {\n              description:\n                \"Match conditions to be satisfied for the rule to be activated. All conditions inside a single match block have AND semantics, while the list of match blocks have OR semantics. The rule is matched if any one of the match blocks succeed.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1alpha3.L4MatchAttributes\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.HTTPMatchRequest\": {\n          description:\n            \"HttpMatchRequest specifies a set of criterion to be met in order for the rule to be applied to the HTTP request. For example, the following restricts the rule to match only requests where the URL path starts with /ratings/v2/ and the request contains a custom `end-user` header with value `jason`.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"The name assigned to a match. The match's name will be concatenated with the parent route's name and will be logged in the access logs for requests matching this route.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            method: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.StringMatch\",\n            },\n            port: {\n              description:\n                \"Specifies the ports on the host that is being addressed. Many services only expose a single port or label ports with the protocols they support, in these cases it is not required to explicitly select the port.\",\n              type: \"integer\",\n            },\n            gateways: {\n              description:\n                \"Names of gateways where the rule should be applied. Gateway names in the top-level `gateways` field of the VirtualService (if any) are overridden. The gateway match is independent of sourceLabels.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            headers: {\n              description:\n                \"The header keys must be lowercase and use hyphen as the separator, e.g. _x-request-id_.\",\n              type: \"object\",\n              additionalProperties: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1alpha3.StringMatch\",\n              },\n            },\n            uri: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.StringMatch\",\n            },\n            scheme: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.StringMatch\",\n            },\n            authority: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.StringMatch\",\n            },\n            sourceLabels: {\n              description:\n                \"One or more labels that constrain the applicability of a rule to workloads with the given labels. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it must include the reserved gateway `mesh` for this field to be applicable.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            queryParams: {\n              description: \"Query parameters for matching.\",\n              type: \"object\",\n              additionalProperties: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1alpha3.StringMatch\",\n              },\n            },\n            ignoreUriCase: {\n              description:\n                \"Flag to specify whether the URI matching should be case-insensitive.\",\n              type: \"boolean\",\n            },\n            withoutHeaders: {\n              description:\n                \"withoutHeader has the same syntax with the header, but has opposite meaning. If a header is matched with a matching rule among withoutHeader, the traffic becomes not matched one.\",\n              type: \"object\",\n              additionalProperties: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1alpha3.StringMatch\",\n              },\n            },\n            sourceNamespace: {\n              description:\n                \"Source namespace constraining the applicability of a rule to workloads in that namespace. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it must include the reserved gateway `mesh` for this field to be applicable.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.HTTPRouteDestination\": {\n          description:\n            'Each routing rule is associated with one or more service versions (see glossary in beginning of document). Weights associated with the version determine the proportion of traffic it receives. For example, the following rule will route 25% of traffic for the \"reviews\" service to instances with the \"v2\" tag and the remaining traffic (i.e., 75%) to \"v1\".',\n          type: \"object\",\n          properties: {\n            headers: {\n              $ref: \"#/components/schemas/istio.networking.v1alpha3.Headers\",\n            },\n            destination: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.Destination\",\n            },\n            weight: {\n              description:\n                \"The proportion of traffic to be forwarded to the service version. (0-100). Sum of weights across destinations SHOULD BE == 100. If there is only one destination in a rule, the weight value is assumed to be 100.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.HTTPRedirect\": {\n          description:\n            \"HTTPRedirect can be used to send a 301 redirect response to the caller, where the Authority/Host and the URI in the response can be swapped with the specified values. For example, the following rule redirects requests for /v1/getProductRatings API on the ratings service to /v1/bookRatings provided by the bookratings service.\",\n          type: \"object\",\n          properties: {\n            uri: {\n              description:\n                \"On a redirect, overwrite the Path portion of the URL with this value. Note that the entire path will be replaced, irrespective of the request URI being matched as an exact path or prefix.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            authority: {\n              description:\n                \"On a redirect, overwrite the Authority/Host portion of the URL with this value.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            redirectCode: {\n              description:\n                \"On a redirect, Specifies the HTTP status code to use in the redirect response. The default response code is MOVED_PERMANENTLY (301).\",\n              type: \"integer\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.Delegate\": {\n          description:\n            \"Describes the delegate VirtualService. The following routing rules forward the traffic to `/productpage` by a delegate VirtualService named `productpage`, forward the traffic to `/reviews` by a delegate VirtualService named `reviews`.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"Name specifies the name of the delegate VirtualService.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            namespace: {\n              description:\n                \"Namespace specifies the namespace where the delegate VirtualService resides. By default, it is same to the root's.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.HTTPRewrite\": {\n          description:\n            \"HTTPRewrite can be used to rewrite specific parts of a HTTP request before forwarding the request to the destination. Rewrite primitive can be used only with HTTPRouteDestination. The following example demonstrates how to rewrite the URL prefix for api call (/ratings) to ratings service before making the actual API call.\",\n          type: \"object\",\n          properties: {\n            uri: {\n              description:\n                \"rewrite the path (or the prefix) portion of the URI with this value. If the original URI was matched based on prefix, the value provided in this field will replace the corresponding matched prefix.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            authority: {\n              description: \"rewrite the Authority/Host header with this value.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.HTTPRetry\": {\n          description:\n            \"Describes the retry policy to use when a HTTP request fails. For example, the following rule sets the maximum number of retries to 3 when calling ratings:v1 service, with a 2s timeout per retry attempt.\",\n          type: \"object\",\n          properties: {\n            attempts: {\n              description:\n                \"Number of retries for a given request. The interval between retries will be determined automatically (25ms+). Actual number of retries attempted depends on the request `timeout` of the [HTTP route](https://istio.io/docs/reference/config/networking/virtual-service/#HTTPRoute).\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            perTryTimeout: {\n              description:\n                \"Timeout per retry attempt for a given request. format: 1h/1m/1s/1ms. MUST BE \\u003e=1ms.\",\n              type: \"string\",\n            },\n            retryOn: {\n              description:\n                \"Specifies the conditions under which retry takes place. One or more policies can be specified using a ‘,’ delimited list. See the [retry policies](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on) and [gRPC retry policies](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-grpc-on) for more details.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            retryRemoteLocalities: {\n              description:\n                \"Flag to specify whether the retries should retry to other localities. See the [retry plugin configuration](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/http_connection_management#retry-plugin-configuration) for more details.\",\n              type: \"boolean\",\n              nullable: true,\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.HTTPFaultInjection\": {\n          description:\n            \"HTTPFaultInjection can be used to specify one or more faults to inject while forwarding HTTP requests to the destination specified in a route. Fault specification is part of a VirtualService rule. Faults include aborting the Http request from downstream service, and/or delaying proxying of requests. A fault rule MUST HAVE delay or abort or both.\",\n          type: \"object\",\n          properties: {\n            delay: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.HTTPFaultInjection.Delay\",\n            },\n            abort: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.HTTPFaultInjection.Abort\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.Percent\": {\n          description:\n            \"Percent specifies a percentage in the range of [0.0, 100.0].\",\n          type: \"object\",\n          properties: {\n            value: {\n              type: \"number\",\n              format: \"double\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.CorsPolicy\": {\n          description:\n            \"Describes the Cross-Origin Resource Sharing (CORS) policy, for a given service. Refer to [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS) for further details about cross origin resource sharing. For example, the following rule restricts cross origin requests to those originating from example.com domain using HTTP POST/GET, and sets the `Access-Control-Allow-Credentials` header to false. In addition, it only exposes `X-Foo-bar` header and sets an expiry period of 1 day.\",\n          type: \"object\",\n          properties: {\n            allowOrigin: {\n              description:\n                \"The list of origins that are allowed to perform CORS requests. The content will be serialized into the Access-Control-Allow-Origin header. Wildcard * will allow all origins. $hide_from_docs\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n              deprecated: true,\n            },\n            allowOrigins: {\n              description:\n                \"String patterns that match allowed origins. An origin is allowed if any of the string matchers match. If a match is found, then the outgoing Access-Control-Allow-Origin would be set to the origin as provided by the client.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1alpha3.StringMatch\",\n              },\n            },\n            allowMethods: {\n              description:\n                \"List of HTTP methods allowed to access the resource. The content will be serialized into the Access-Control-Allow-Methods header.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            allowHeaders: {\n              description:\n                \"List of HTTP headers that can be used when requesting the resource. Serialized to Access-Control-Allow-Headers header.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            exposeHeaders: {\n              description:\n                \"A white list of HTTP headers that the browsers are allowed to access. Serialized into Access-Control-Expose-Headers header.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            maxAge: {\n              description:\n                \"Specifies how long the results of a preflight request can be cached. Translates to the `Access-Control-Max-Age` header.\",\n              type: \"string\",\n            },\n            allowCredentials: {\n              description:\n                \"Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials. Translates to `Access-Control-Allow-Credentials` header.\",\n              type: \"boolean\",\n              nullable: true,\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.Headers\": {\n          description:\n            \"Message headers can be manipulated when Envoy forwards requests to, or responses from, a destination service. Header manipulation rules can be specified for a specific route destination or for all destinations. The following VirtualService adds a `test` header with the value `true` to requests that are routed to any `reviews` service destination. It also romoves the `foo` response header, but only from responses coming from the `v1` subset (version) of the `reviews` service.\",\n          type: \"object\",\n          properties: {\n            response: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.Headers.HeaderOperations\",\n            },\n            request: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.Headers.HeaderOperations\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.Headers.HeaderOperations\": {\n          description:\n            \"HeaderOperations Describes the header manipulations to apply\",\n          type: \"object\",\n          properties: {\n            set: {\n              description:\n                \"Overwrite the headers specified by key with the given values\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            add: {\n              description:\n                \"Append the given values to the headers specified by keys (will create a comma-separated list of values)\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            remove: {\n              description: \"Remove a the specified headers\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.TLSMatchAttributes\": {\n          description: \"TLS connection match attributes.\",\n          type: \"object\",\n          properties: {\n            port: {\n              description:\n                \"Specifies the port on the host that is being addressed. Many services only expose a single port or label ports with the protocols they support, in these cases it is not required to explicitly select the port.\",\n              type: \"integer\",\n            },\n            gateways: {\n              description:\n                \"Names of gateways where the rule should be applied. Gateway names in the top-level `gateways` field of the VirtualService (if any) are overridden. The gateway match is independent of sourceLabels.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            sourceLabels: {\n              description:\n                \"One or more labels that constrain the applicability of a rule to workloads with the given labels. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it should include the reserved gateway `mesh` in order for this field to be applicable.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            sourceNamespace: {\n              description:\n                \"Source namespace constraining the applicability of a rule to workloads in that namespace. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it must include the reserved gateway `mesh` for this field to be applicable.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            destinationSubnets: {\n              description:\n                \"IPv4 or IPv6 ip addresses of destination with optional subnet. E.g., a.b.c.d/xx form or just a.b.c.d.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            sniHosts: {\n              description:\n                \"SNI (server name indicator) to match on. Wildcard prefixes can be used in the SNI value, e.g., *.com will match foo.example.com as well as example.com. An SNI value must be a subset (i.e., fall within the domain) of the corresponding virtual serivce's hosts.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.RouteDestination\": {\n          description: \"L4 routing rule weighted destination.\",\n          type: \"object\",\n          properties: {\n            destination: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.Destination\",\n            },\n            weight: {\n              description:\n                \"The proportion of traffic to be forwarded to the service version. If there is only one destination in a rule, all traffic will be routed to it irrespective of the weight.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.L4MatchAttributes\": {\n          description:\n            \"L4 connection match attributes. Note that L4 connection matching support is incomplete.\",\n          type: \"object\",\n          properties: {\n            port: {\n              description:\n                \"Specifies the port on the host that is being addressed. Many services only expose a single port or label ports with the protocols they support, in these cases it is not required to explicitly select the port.\",\n              type: \"integer\",\n            },\n            gateways: {\n              description:\n                \"Names of gateways where the rule should be applied. Gateway names in the top-level `gateways` field of the VirtualService (if any) are overridden. The gateway match is independent of sourceLabels.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            sourceLabels: {\n              description:\n                \"One or more labels that constrain the applicability of a rule to workloads with the given labels. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it should include the reserved gateway `mesh` in order for this field to be applicable.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            sourceNamespace: {\n              description:\n                \"Source namespace constraining the applicability of a rule to workloads in that namespace. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it must include the reserved gateway `mesh` for this field to be applicable.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            destinationSubnets: {\n              description:\n                \"IPv4 or IPv6 ip addresses of destination with optional subnet. E.g., a.b.c.d/xx form or just a.b.c.d.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            sourceSubnet: {\n              description:\n                \"IPv4 or IPv6 ip address of source with optional subnet. E.g., a.b.c.d/xx form or just a.b.c.d $hide_from_docs\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.StringMatch\": {\n          description:\n            \"Describes how to match a given string in HTTP headers. Match is case-sensitive.\",\n          type: \"object\",\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"exact\"],\n                    properties: {\n                      exact: {\n                        description: \"exact string match\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"prefix\"],\n                    properties: {\n                      prefix: {\n                        description: \"prefix-based match\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"regex\"],\n                    properties: {\n                      regex: {\n                        description:\n                          \"RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"exact\"],\n              properties: {\n                exact: {\n                  description: \"exact string match\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"prefix\"],\n              properties: {\n                prefix: {\n                  description: \"prefix-based match\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"regex\"],\n              properties: {\n                regex: {\n                  description:\n                    \"RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n          ],\n        },\n        \"istio.networking.v1alpha3.HTTPFaultInjection.Delay\": {\n          description:\n            'Delay specification is used to inject latency into the request forwarding path. The following example will introduce a 5 second delay in 1 out of every 1000 requests to the \"v1\" version of the \"reviews\" service from all pods with label env: prod',\n          type: \"object\",\n          properties: {\n            percent: {\n              description:\n                \"Percentage of requests on which the delay will be injected (0-100). Use of integer `percent` value is deprecated. Use the double `percentage` field instead.\",\n              type: \"integer\",\n              format: \"int32\",\n              deprecated: true,\n            },\n            percentage: {\n              $ref: \"#/components/schemas/istio.networking.v1alpha3.Percent\",\n            },\n          },\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"fixedDelay\"],\n                    properties: {\n                      fixedDelay: {\n                        description:\n                          \"Add a fixed delay before forwarding the request. Format: 1h/1m/1s/1ms. MUST be \\u003e=1ms.\",\n                        type: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"exponentialDelay\"],\n                    properties: {\n                      exponentialDelay: {\n                        type: \"string\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"fixedDelay\"],\n              properties: {\n                fixedDelay: {\n                  description:\n                    \"Add a fixed delay before forwarding the request. Format: 1h/1m/1s/1ms. MUST be \\u003e=1ms.\",\n                  type: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"exponentialDelay\"],\n              properties: {\n                exponentialDelay: {\n                  type: \"string\",\n                },\n              },\n            },\n          ],\n        },\n        \"istio.networking.v1alpha3.HTTPFaultInjection.Abort\": {\n          description:\n            'Abort specification is used to prematurely abort a request with a pre-specified error code. The following example will return an HTTP 400 error code for 1 out of every 1000 requests to the \"ratings\" service \"v1\".',\n          type: \"object\",\n          properties: {\n            percentage: {\n              $ref: \"#/components/schemas/istio.networking.v1alpha3.Percent\",\n            },\n          },\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"httpStatus\"],\n                    properties: {\n                      httpStatus: {\n                        description:\n                          \"HTTP status code to use to abort the Http request.\",\n                        type: \"integer\",\n                        format: \"int32\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"grpcStatus\"],\n                    properties: {\n                      grpcStatus: {\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"http2Error\"],\n                    properties: {\n                      http2Error: {\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"httpStatus\"],\n              properties: {\n                httpStatus: {\n                  description:\n                    \"HTTP status code to use to abort the Http request.\",\n                  type: \"integer\",\n                  format: \"int32\",\n                },\n              },\n            },\n            {\n              required: [\"grpcStatus\"],\n              properties: {\n                grpcStatus: {\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"http2Error\"],\n              properties: {\n                http2Error: {\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n          ],\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Configuration affecting load balancing, outlier detection, etc.\",\n      version: \"v1alpha3\",\n    },\n    components: {\n      schemas: {\n        \"istio.networking.v1alpha3.DestinationRule\": {\n          description:\n            \"DestinationRule defines policies that apply to traffic intended for a service after routing has occurred.\",\n          type: \"object\",\n          properties: {\n            host: {\n              description:\n                \"The name of a service from the service registry. Service names are looked up from the platform's service registry (e.g., Kubernetes services, Consul services, etc.) and from the hosts declared by [ServiceEntries](https://istio.io/docs/reference/config/networking/service-entry/#ServiceEntry). Rules defined for services that do not exist in the service registry will be ignored.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            trafficPolicy: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.TrafficPolicy\",\n            },\n            subsets: {\n              description:\n                \"One or more named sets that represent individual versions of a service. Traffic policies can be overridden at subset level.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.networking.v1alpha3.Subset\",\n              },\n            },\n            exportTo: {\n              description:\n                \"A list of namespaces to which this destination rule is exported. The resolution of a destination rule to apply to a service occurs in the context of a hierarchy of namespaces. Exporting a destination rule allows it to be included in the resolution hierarchy for services in other namespaces. This feature provides a mechanism for service owners and mesh administrators to control the visibility of destination rules across namespace boundaries.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.TrafficPolicy\": {\n          description:\n            \"Traffic policies to apply for a specific destination, across all destination ports. See DestinationRule for examples.\",\n          type: \"object\",\n          properties: {\n            loadBalancer: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.LoadBalancerSettings\",\n            },\n            connectionPool: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ConnectionPoolSettings\",\n            },\n            outlierDetection: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.OutlierDetection\",\n            },\n            tls: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ClientTLSSettings\",\n            },\n            portLevelSettings: {\n              description:\n                \"Traffic policies specific to individual ports. Note that port level settings will override the destination-level settings. Traffic settings specified at the destination-level will not be inherited when overridden by port-level settings, i.e. default values will be applied to fields omitted in port-level traffic policies.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.Subset\": {\n          description:\n            \"A subset of endpoints of a service. Subsets can be used for scenarios like A/B testing, or routing to a specific version of a service. Refer to [VirtualService](https://istio.io/docs/reference/config/networking/virtual-service/#VirtualService) documentation for examples of using subsets in these scenarios. In addition, traffic policies defined at the service-level can be overridden at a subset-level. The following rule uses a round robin load balancing policy for all traffic going to a subset named testversion that is composed of endpoints (e.g., pods) with labels (version:v3).\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"Name of the subset. The service name and the subset name can be used for traffic splitting in a route rule.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            trafficPolicy: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.TrafficPolicy\",\n            },\n            labels: {\n              description:\n                \"Labels apply a filter over the endpoints of a service in the service registry. See route rules for examples of usage.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.LoadBalancerSettings\": {\n          description:\n            \"Load balancing policies to apply for a specific destination. See Envoy's load balancing [documentation](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/load_balancing) for more details.\",\n          type: \"object\",\n          properties: {\n            localityLbSetting: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.LocalityLoadBalancerSetting\",\n            },\n          },\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"simple\"],\n                    properties: {\n                      simple: {\n                        $ref:\n                          \"#/components/schemas/istio.networking.v1alpha3.LoadBalancerSettings.SimpleLB\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"consistentHash\"],\n                    properties: {\n                      consistentHash: {\n                        $ref:\n                          \"#/components/schemas/istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"simple\"],\n              properties: {\n                simple: {\n                  $ref:\n                    \"#/components/schemas/istio.networking.v1alpha3.LoadBalancerSettings.SimpleLB\",\n                },\n              },\n            },\n            {\n              required: [\"consistentHash\"],\n              properties: {\n                consistentHash: {\n                  $ref:\n                    \"#/components/schemas/istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB\",\n                },\n              },\n            },\n          ],\n        },\n        \"istio.networking.v1alpha3.ConnectionPoolSettings\": {\n          description:\n            \"Connection pool settings for an upstream host. The settings apply to each individual host in the upstream service. See Envoy's [circuit breaker](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/circuit_breaking) for more details. Connection pool settings can be applied at the TCP level as well as at HTTP level.\",\n          type: \"object\",\n          properties: {\n            tcp: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings\",\n            },\n            http: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettings\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.OutlierDetection\": {\n          description:\n            \"A Circuit breaker implementation that tracks the status of each individual host in the upstream service. Applicable to both HTTP and TCP services. For HTTP services, hosts that continually return 5xx errors for API calls are ejected from the pool for a pre-defined period of time. For TCP services, connection timeouts or connection failures to a given host counts as an error when measuring the consecutive errors metric. See Envoy's [outlier detection](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/outlier) for more details.\",\n          type: \"object\",\n          properties: {\n            interval: {\n              description:\n                \"Time interval between ejection sweep analysis. format: 1h/1m/1s/1ms. MUST BE \\u003e=1ms. Default is 10s.\",\n              type: \"string\",\n            },\n            consecutiveErrors: {\n              description:\n                \"Number of errors before a host is ejected from the connection pool. Defaults to 5. When the upstream host is accessed over HTTP, a 502, 503, or 504 return code qualifies as an error. When the upstream host is accessed over an opaque TCP connection, connect timeouts and connection error/failure events qualify as an error. $hide_from_docs\",\n              type: \"integer\",\n              format: \"int32\",\n              deprecated: true,\n            },\n            consecutiveGatewayErrors: {\n              description:\n                \"Number of gateway errors before a host is ejected from the connection pool. When the upstream host is accessed over HTTP, a 502, 503, or 504 return code qualifies as a gateway error. When the upstream host is accessed over an opaque TCP connection, connect timeouts and connection error/failure events qualify as a gateway error. This feature is disabled by default or when set to the value 0.\",\n              type: \"integer\",\n              nullable: true,\n            },\n            consecutive5xxErrors: {\n              description:\n                \"Number of 5xx errors before a host is ejected from the connection pool. When the upstream host is accessed over an opaque TCP connection, connect timeouts, connection error/failure and request failure events qualify as a 5xx error. This feature defaults to 5 but can be disabled by setting the value to 0.\",\n              type: \"integer\",\n              nullable: true,\n            },\n            baseEjectionTime: {\n              description:\n                \"Minimum ejection duration. A host will remain ejected for a period equal to the product of minimum ejection duration and the number of times the host has been ejected. This technique allows the system to automatically increase the ejection period for unhealthy upstream servers. format: 1h/1m/1s/1ms. MUST BE \\u003e=1ms. Default is 30s.\",\n              type: \"string\",\n            },\n            maxEjectionPercent: {\n              description:\n                \"Maximum % of hosts in the load balancing pool for the upstream service that can be ejected. Defaults to 10%.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            minHealthPercent: {\n              description:\n                \"Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode. When the percentage of healthy hosts in the load balancing pool drops below this threshold, outlier detection will be disabled and the proxy will load balance across all hosts in the pool (healthy and unhealthy). The threshold can be disabled by setting it to 0%. The default is 0% as it's not typically applicable in k8s environments with few pods per service.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.ClientTLSSettings\": {\n          description:\n            \"SSL/TLS related settings for upstream connections. See Envoy's [TLS context](https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/auth/cert.proto.html) for more details. These settings are common to both HTTP and TCP upstreams.\",\n          type: \"object\",\n          properties: {\n            mode: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ClientTLSSettings.TLSmode\",\n            },\n            clientCertificate: {\n              description:\n                \"REQUIRED if mode is `MUTUAL`. The path to the file holding the client-side TLS certificate to use. Should be empty if mode is `ISTIO_MUTUAL`.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            privateKey: {\n              description:\n                \"REQUIRED if mode is `MUTUAL`. The path to the file holding the client's private key. Should be empty if mode is `ISTIO_MUTUAL`.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            caCertificates: {\n              description:\n                \"OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate. If omitted, the proxy will not verify the server's certificate. Should be empty if mode is `ISTIO_MUTUAL`.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            credentialName: {\n              description:\n                \"The name of the secret that holds the TLS certs for the client including the CA certificates. Applicable only on Kubernetes. Secret must exist in the same namespace with the proxy using the certificates. The secret (of type `generic`)should contain the following keys and values: `key: \\u003cprivateKey\\u003e`, `cert: \\u003cserverCert\\u003e`, `cacert: \\u003cCACertificate\\u003e`. Secret of type tls for client certificates along with ca.crt key for CA certificates is also supported. Only one of client certificates and CA certificate or credentialName can be specified.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            subjectAltNames: {\n              description:\n                \"A list of alternate names to verify the subject identity in the certificate. If specified, the proxy will verify that the server certificate's subject alt name matches one of the specified values. If specified, this list overrides the value of subject_alt_names from the ServiceEntry.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            sni: {\n              description:\n                \"SNI string to present to the server during TLS handshake.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy\": {\n          description:\n            \"Traffic policies that apply to specific ports of the service\",\n          type: \"object\",\n          properties: {\n            loadBalancer: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.LoadBalancerSettings\",\n            },\n            connectionPool: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ConnectionPoolSettings\",\n            },\n            outlierDetection: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.OutlierDetection\",\n            },\n            tls: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ClientTLSSettings\",\n            },\n            port: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.PortSelector\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.PortSelector\": {\n          description:\n            \"PortSelector specifies the number of a port to be used for matching or selection for final routing.\",\n          type: \"object\",\n          properties: {\n            number: {\n              description: \"Valid port number\",\n              type: \"integer\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.LocalityLoadBalancerSetting\": {\n          description:\n            \"Locality-weighted load balancing allows administrators to control the distribution of traffic to endpoints based on the localities of where the traffic originates and where it will terminate. These localities are specified using arbitrary labels that designate a hierarchy of localities in {region}/{zone}/{sub-zone} form. For additional detail refer to [Locality Weight](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/locality_weight) The following example shows how to setup locality weights mesh-wide.\",\n          type: \"object\",\n          properties: {\n            distribute: {\n              description:\n                \"Optional: only one of distribute or failover can be set. Explicitly specify loadbalancing weight across different zones and geographical locations. Refer to [Locality weighted load balancing](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/locality_weight) If empty, the locality weight is set according to the endpoints number within it.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1alpha3.LocalityLoadBalancerSetting.Distribute\",\n              },\n            },\n            failover: {\n              description:\n                \"Optional: only failover or distribute can be set. Explicitly specify the region traffic will land on when endpoints in local region becomes unhealthy. Should be used together with OutlierDetection to detect unhealthy endpoints. Note: if no OutlierDetection specified, this will not take effect.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1alpha3.LocalityLoadBalancerSetting.Failover\",\n              },\n            },\n            enabled: {\n              description:\n                \"enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety. e.g. true means that turn on locality load balancing for this DestinationRule no matter what mesh wide settings is.\",\n              type: \"boolean\",\n              nullable: true,\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.LoadBalancerSettings.SimpleLB\": {\n          description:\n            \"Standard load balancing algorithms that require no tuning.\",\n          type: \"string\",\n          enum: [\"ROUND_ROBIN\", \"LEAST_CONN\", \"RANDOM\", \"PASSTHROUGH\"],\n        },\n        \"istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB\": {\n          description:\n            \"Consistent Hash-based load balancing can be used to provide soft session affinity based on HTTP headers, cookies or other properties. This load balancing policy is applicable only for HTTP connections. The affinity to a particular destination host will be lost when one or more hosts are added/removed from the destination service.\",\n          type: \"object\",\n          properties: {\n            minimumRingSize: {\n              description:\n                \"The minimum number of virtual nodes to use for the hash ring. Defaults to 1024. Larger ring sizes result in more granular load distributions. If the number of hosts in the load balancing pool is larger than the ring size, each host will be assigned a single virtual node.\",\n              type: \"integer\",\n            },\n          },\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"httpHeaderName\"],\n                    properties: {\n                      httpHeaderName: {\n                        description: \"Hash based on a specific HTTP header.\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"httpCookie\"],\n                    properties: {\n                      httpCookie: {\n                        $ref:\n                          \"#/components/schemas/istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"useSourceIp\"],\n                    properties: {\n                      useSourceIp: {\n                        description: \"Hash based on the source IP address.\",\n                        type: \"boolean\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"httpQueryParameterName\"],\n                    properties: {\n                      httpQueryParameterName: {\n                        description:\n                          \"Hash based on a specific HTTP query parameter.\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"httpHeaderName\"],\n              properties: {\n                httpHeaderName: {\n                  description: \"Hash based on a specific HTTP header.\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"httpCookie\"],\n              properties: {\n                httpCookie: {\n                  $ref:\n                    \"#/components/schemas/istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie\",\n                },\n              },\n            },\n            {\n              required: [\"useSourceIp\"],\n              properties: {\n                useSourceIp: {\n                  description: \"Hash based on the source IP address.\",\n                  type: \"boolean\",\n                },\n              },\n            },\n            {\n              required: [\"httpQueryParameterName\"],\n              properties: {\n                httpQueryParameterName: {\n                  description: \"Hash based on a specific HTTP query parameter.\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n          ],\n        },\n        \"istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie\": {\n          description:\n            \"Describes a HTTP cookie that will be used as the hash key for the Consistent Hash load balancer. If the cookie is not present, it will be generated.\",\n          type: \"object\",\n          properties: {\n            path: {\n              description: \"Path to set for the cookie.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            name: {\n              description: \"Name of the cookie.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            ttl: {\n              description: \"Lifetime of the cookie.\",\n              type: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings\": {\n          description:\n            \"Settings common to both HTTP and TCP upstream connections.\",\n          type: \"object\",\n          properties: {\n            maxConnections: {\n              description:\n                \"Maximum number of HTTP1 /TCP connections to a destination host. Default 2^32-1.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            connectTimeout: {\n              description:\n                \"TCP connection timeout. format: 1h/1m/1s/1ms. MUST BE \\u003e=1ms. Default is 10s.\",\n              type: \"string\",\n            },\n            tcpKeepalive: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettings\": {\n          description: \"Settings applicable to HTTP1.1/HTTP2/GRPC connections.\",\n          type: \"object\",\n          properties: {\n            http1MaxPendingRequests: {\n              description:\n                \"Maximum number of pending HTTP requests to a destination. Default 2^32-1.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            http2MaxRequests: {\n              description:\n                \"Maximum number of requests to a backend. Default 2^32-1.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            maxRequestsPerConnection: {\n              description:\n                'Maximum number of requests per connection to a backend. Setting this parameter to 1 disables keep alive. Default 0, meaning \"unlimited\", up to 2^29.',\n              type: \"integer\",\n              format: \"int32\",\n            },\n            maxRetries: {\n              description:\n                \"Maximum number of retries that can be outstanding to all hosts in a cluster at a given time. Defaults to 2^32-1.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            idleTimeout: {\n              description:\n                \"The idle timeout for upstream connection pool connections. The idle timeout is defined as the period in which there are no active requests. If not set, the default is 1 hour. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. Applies to both HTTP1.1 and HTTP2 connections.\",\n              type: \"string\",\n            },\n            h2UpgradePolicy: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettings.H2UpgradePolicy\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive\": {\n          description: \"TCP keepalive.\",\n          type: \"object\",\n          properties: {\n            time: {\n              description:\n                \"The time duration a connection needs to be idle before keep-alive probes start being sent. Default is to use the OS level configuration (unless overridden, Linux defaults to 7200s (ie 2 hours.)\",\n              type: \"string\",\n            },\n            probes: {\n              description:\n                \"Maximum number of keepalive probes to send without response before deciding the connection is dead. Default is to use the OS level configuration (unless overridden, Linux defaults to 9.)\",\n              type: \"integer\",\n            },\n            interval: {\n              description:\n                \"The time duration between keep-alive probes. Default is to use the OS level configuration (unless overridden, Linux defaults to 75s.)\",\n              type: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettings.H2UpgradePolicy\": {\n          description: \"Policy for upgrading http1.1 connections to http2.\",\n          type: \"string\",\n          enum: [\"DEFAULT\", \"DO_NOT_UPGRADE\", \"UPGRADE\"],\n        },\n        \"istio.networking.v1alpha3.ClientTLSSettings.TLSmode\": {\n          description: \"TLS connection mode\",\n          type: \"string\",\n          enum: [\"DISABLE\", \"SIMPLE\", \"MUTUAL\", \"ISTIO_MUTUAL\"],\n        },\n        \"istio.networking.v1alpha3.LocalityLoadBalancerSetting.Distribute\": {\n          description:\n            \"Describes how traffic originating in the 'from' zone or sub-zone is distributed over a set of 'to' zones. Syntax for specifying a zone is {region}/{zone}/{sub-zone} and terminal wildcards are allowed on any segment of the specification. Examples: * - matches all localities us-west/* - all zones and sub-zones within the us-west region us-west/zone-1/* - all sub-zones within us-west/zone-1\",\n          type: \"object\",\n          properties: {\n            from: {\n              description:\n                \"Originating locality, '/' separated, e.g. 'region/zone/sub_zone'.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            to: {\n              description:\n                \"Map of upstream localities to traffic distribution weights. The sum of all weights should be == 100. Any locality not assigned a weight will receive no traffic.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"integer\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.LocalityLoadBalancerSetting.Failover\": {\n          description:\n            \"Specify the traffic failover policy across regions. Since zone and sub-zone failover is supported by default this only needs to be specified for regions when the operator needs to constrain traffic failover so that the default behavior of failing over to any endpoint globally does not apply. This is useful when failing over traffic across regions would not improve service health or may need to be restricted for other reasons like regulatory controls.\",\n          type: \"object\",\n          properties: {\n            from: {\n              description: \"Originating region.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            to: {\n              description:\n                \"Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Configuration affecting network reachability of a sidecar.\",\n      version: \"v1beta1\",\n    },\n    components: {\n      schemas: {\n        \"istio.networking.v1beta1.ClientTLSSettings\": {\n          description:\n            \"SSL/TLS related settings for upstream connections. See Envoy's [TLS context](https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/auth/cert.proto.html) for more details. These settings are common to both HTTP and TCP upstreams.\",\n          type: \"object\",\n          properties: {\n            mode: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ClientTLSSettings.TLSmode\",\n            },\n            clientCertificate: {\n              description:\n                \"REQUIRED if mode is `MUTUAL`. The path to the file holding the client-side TLS certificate to use. Should be empty if mode is `ISTIO_MUTUAL`.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            privateKey: {\n              description:\n                \"REQUIRED if mode is `MUTUAL`. The path to the file holding the client's private key. Should be empty if mode is `ISTIO_MUTUAL`.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            caCertificates: {\n              description:\n                \"OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate. If omitted, the proxy will not verify the server's certificate. Should be empty if mode is `ISTIO_MUTUAL`.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            credentialName: {\n              description:\n                \"The name of the secret that holds the TLS certs for the client including the CA certificates. Applicable only on Kubernetes. Secret must exist in the same namespace with the proxy using the certificates. The secret (of type `generic`)should contain the following keys and values: `key: \\u003cprivateKey\\u003e`, `cert: \\u003cserverCert\\u003e`, `cacert: \\u003cCACertificate\\u003e`. Secret of type tls for client certificates along with ca.crt key for CA certificates is also supported. Only one of client certificates and CA certificate or credentialName can be specified.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            subjectAltNames: {\n              description:\n                \"A list of alternate names to verify the subject identity in the certificate. If specified, the proxy will verify that the server certificate's subject alt name matches one of the specified values. If specified, this list overrides the value of subject_alt_names from the ServiceEntry.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            sni: {\n              description:\n                \"SNI string to present to the server during TLS handshake.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.PortSelector\": {\n          description:\n            \"PortSelector specifies the number of a port to be used for matching or selection for final routing.\",\n          type: \"object\",\n          properties: {\n            number: {\n              description: \"Valid port number\",\n              type: \"integer\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.ClientTLSSettings.TLSmode\": {\n          description: \"TLS connection mode\",\n          type: \"string\",\n          enum: [\"DISABLE\", \"SIMPLE\", \"MUTUAL\", \"ISTIO_MUTUAL\"],\n        },\n        \"istio.networking.v1beta1.Port\": {\n          description:\n            \"Port describes the properties of a specific port of a service.\",\n          type: \"object\",\n          properties: {\n            number: {\n              description: \"A valid non-negative integer port number.\",\n              type: \"integer\",\n            },\n            name: {\n              description: \"Label assigned to the port.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            protocol: {\n              description:\n                \"The protocol exposed on the port. MUST BE one of HTTP|HTTPS|GRPC|HTTP2|MONGO|TCP|TLS. TLS implies the connection will be routed based on the SNI header to the destination without terminating the TLS connection.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.ServerTLSSettings\": {\n          type: \"object\",\n          properties: {\n            mode: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ServerTLSSettings.TLSmode\",\n            },\n            privateKey: {\n              description:\n                \"REQUIRED if mode is `SIMPLE` or `MUTUAL`. The path to the file holding the server's private key.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            caCertificates: {\n              description:\n                \"REQUIRED if mode is `MUTUAL`. The path to a file containing certificate authority certificates to use in verifying a presented client side certificate.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            credentialName: {\n              description:\n                \"For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates. Applicable only on Kubernetes, and only if the dynamic credential fetching feature is enabled in the proxy by setting `ISTIO_META_USER_SDS` metadata variable. The secret (of type `generic`) should contain the following keys and values: `key: \\u003cprivateKey\\u003e`, `cert: \\u003cserverCert\\u003e`, `cacert: \\u003cCACertificate\\u003e`. Secret of type tls for server certificates along with ca.crt key for CA certificates is also supported. Only one of server certificates and CA certificate or credentialName can be specified.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            subjectAltNames: {\n              description:\n                \"A list of alternate names to verify the subject identity in the certificate presented by the client.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            httpsRedirect: {\n              description:\n                \"If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.\",\n              type: \"boolean\",\n            },\n            serverCertificate: {\n              description:\n                \"REQUIRED if mode is `SIMPLE` or `MUTUAL`. The path to the file holding the server-side TLS certificate to use.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            verifyCertificateSpki: {\n              description:\n                \"An optional list of base64-encoded SHA-256 hashes of the SKPIs of authorized client certificates. Note: When both verify_certificate_hash and verify_certificate_spki are specified, a hash matching either value will result in the certificate being accepted.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            verifyCertificateHash: {\n              description:\n                \"An optional list of hex-encoded SHA-256 hashes of the authorized client certificates. Both simple and colon separated formats are acceptable. Note: When both verify_certificate_hash and verify_certificate_spki are specified, a hash matching either value will result in the certificate being accepted.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            minProtocolVersion: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ServerTLSSettings.TLSProtocol\",\n            },\n            maxProtocolVersion: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ServerTLSSettings.TLSProtocol\",\n            },\n            cipherSuites: {\n              description:\n                \"Optional: If specified, only support the specified cipher list. Otherwise default to the default cipher list supported by Envoy.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1beta1.ServerTLSSettings.TLSmode\": {\n          description: \"TLS modes enforced by the proxy\",\n          type: \"string\",\n          enum: [\n            \"PASSTHROUGH\",\n            \"SIMPLE\",\n            \"MUTUAL\",\n            \"AUTO_PASSTHROUGH\",\n            \"ISTIO_MUTUAL\",\n          ],\n        },\n        \"istio.networking.v1beta1.ServerTLSSettings.TLSProtocol\": {\n          description: \"TLS protocol versions.\",\n          type: \"string\",\n          enum: [\"TLS_AUTO\", \"TLSV1_0\", \"TLSV1_1\", \"TLSV1_2\", \"TLSV1_3\"],\n        },\n        \"istio.networking.v1beta1.WorkloadSelector\": {\n          description:\n            \"`WorkloadSelector` specifies the criteria used to determine if the `Gateway`, `Sidecar`, or `EnvoyFilter` configuration can be applied to a proxy. The matching criteria includes the metadata associated with a proxy, workload instance info such as labels attached to the pod/VM, or any other info that the proxy provides to Istio during the initial handshake. If multiple conditions are specified, all conditions need to match in order for the workload instance to be selected. Currently, only label based selection mechanism is supported.\",\n          type: \"object\",\n          properties: {\n            labels: {\n              description:\n                \"One or more labels that indicate a specific set of pods/VMs on which this `Sidecar` configuration should be applied. The scope of label search is restricted to the configuration namespace in which the the resource is present.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1beta1.Sidecar\": {\n          description:\n            \"`Sidecar` describes the configuration of the sidecar proxy that mediates inbound and outbound communication of the workload instance to which it is attached.\",\n          type: \"object\",\n          properties: {\n            workloadSelector: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.WorkloadSelector\",\n            },\n            ingress: {\n              description:\n                \"Ingress specifies the configuration of the sidecar for processing inbound traffic to the attached workload instance. If omitted, Istio will automatically configure the sidecar based on the information about the workload obtained from the orchestration platform (e.g., exposed ports, services, etc.). If specified, inbound ports are configured if and only if the workload instance is associated with a service.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1beta1.IstioIngressListener\",\n              },\n            },\n            egress: {\n              description:\n                \"Egress specifies the configuration of the sidecar for processing outbound traffic from the attached workload instance to other services in the mesh. If not specified, inherits the system detected defaults from the namespace-wide or the global default Sidecar.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1beta1.IstioEgressListener\",\n              },\n            },\n            outboundTrafficPolicy: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.OutboundTrafficPolicy\",\n            },\n            localhost: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.Localhost\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.IstioIngressListener\": {\n          description:\n            \"`IstioIngressListener` specifies the properties of an inbound traffic listener on the sidecar proxy attached to a workload instance.\",\n          type: \"object\",\n          properties: {\n            port: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.Port\",\n            },\n            bind: {\n              description:\n                \"The IP to which the listener should be bound. Must be in the format `x.x.x.x`. Unix domain socket addresses are not allowed in the bind field for ingress listeners. If omitted, Istio will automatically configure the defaults based on imported services and the workload instances to which this configuration is applied to.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            defaultEndpoint: {\n              description:\n                \"The loopback IP endpoint or Unix domain socket to which traffic should be forwarded to. This configuration can be used to redirect traffic arriving at the bind `IP:Port` on the sidecar to a `localhost:port` or Unix domain socket where the application workload instance is listening for connections. Format should be `127.0.0.1:PORT` or `unix:///path/to/socket`\",\n              type: \"string\",\n              format: \"string\",\n            },\n            captureMode: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.CaptureMode\",\n            },\n            localhostClientTls: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ClientTLSSettings\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.IstioEgressListener\": {\n          description:\n            \"`IstioEgressListener` specifies the properties of an outbound traffic listener on the sidecar proxy attached to a workload instance.\",\n          type: \"object\",\n          properties: {\n            port: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.Port\",\n            },\n            bind: {\n              description:\n                \"The IP or the Unix domain socket to which the listener should be bound to. Port MUST be specified if bind is not empty. Format: `x.x.x.x` or `unix:///path/to/uds` or `unix://@foobar` (Linux abstract namespace). If omitted, Istio will automatically configure the defaults based on imported services, the workload instances to which this configuration is applied to and the captureMode. If captureMode is `NONE`, bind will default to 127.0.0.1.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            hosts: {\n              description:\n                \"One or more service hosts exposed by the listener in `namespace/dnsName` format. Services in the specified namespace matching `dnsName` will be exposed. The corresponding service can be a service in the service registry (e.g., a Kubernetes or cloud foundry service) or a service specified using a `ServiceEntry` or `VirtualService` configuration. Any associated `DestinationRule` in the same namespace will also be used.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            captureMode: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.CaptureMode\",\n            },\n            localhostServerTls: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ServerTLSSettings\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.OutboundTrafficPolicy\": {\n          description:\n            \"`OutboundTrafficPolicy` sets the default behavior of the sidecar for handling outbound traffic from the application. If your application uses one or more external services that are not known apriori, setting the policy to `ALLOW_ANY` will cause the sidecars to route any unknown traffic originating from the application to its requested destination. Users are strongly encouraged to use `ServiceEntry` configurations to explicitly declare any external dependencies, instead of using `ALLOW_ANY`, so that traffic to these services can be monitored.\",\n          type: \"object\",\n          properties: {\n            mode: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.OutboundTrafficPolicy.Mode\",\n            },\n            egressProxy: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.Destination\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.Localhost\": {\n          description:\n            \"`Localhost` describes the sidecar settings related to the communication between the sidecar and the workload it is attached to in a Kubernetes Pod or a VM. These settings apply by default to all ingress and egress listeners in a sidecar unless overridden.\",\n          type: \"object\",\n          properties: {\n            clientTls: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ClientTLSSettings\",\n            },\n            serverTls: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ServerTLSSettings\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.CaptureMode\": {\n          description:\n            \"`CaptureMode` describes how traffic to a listener is expected to be captured. Applicable only when the listener is bound to an IP.\",\n          type: \"string\",\n          enum: [\"DEFAULT\", \"IPTABLES\", \"NONE\"],\n        },\n        \"istio.networking.v1beta1.OutboundTrafficPolicy.Mode\": {\n          type: \"string\",\n          enum: [\"REGISTRY_ONLY\", \"ALLOW_ANY\"],\n        },\n        \"istio.networking.v1beta1.Destination\": {\n          description:\n            \"Destination indicates the network addressable service to which the request/connection will be sent after processing a routing rule. The destination.host should unambiguously refer to a service in the service registry. Istio's service registry is composed of all the services found in the platform's service registry (e.g., Kubernetes services, Consul services), as well as services declared through the [ServiceEntry](https://istio.io/docs/reference/config/networking/service-entry/#ServiceEntry) resource.\",\n          type: \"object\",\n          properties: {\n            host: {\n              description:\n                \"The name of a service from the service registry. Service names are looked up from the platform's service registry (e.g., Kubernetes services, Consul services, etc.) and from the hosts declared by [ServiceEntry](https://istio.io/docs/reference/config/networking/service-entry/#ServiceEntry). Traffic forwarded to destinations that are not found in either of the two, will be dropped.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            port: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.PortSelector\",\n            },\n            subset: {\n              description:\n                \"The name of a subset within the service. Applicable only to services within the mesh. The subset must be defined in a corresponding DestinationRule.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Configuration affecting service registry.\",\n      version: \"v1beta1\",\n    },\n    components: {\n      schemas: {\n        \"istio.networking.v1beta1.Port\": {\n          description:\n            \"Port describes the properties of a specific port of a service.\",\n          type: \"object\",\n          properties: {\n            number: {\n              description: \"A valid non-negative integer port number.\",\n              type: \"integer\",\n            },\n            name: {\n              description: \"Label assigned to the port.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            protocol: {\n              description:\n                \"The protocol exposed on the port. MUST BE one of HTTP|HTTPS|GRPC|HTTP2|MONGO|TCP|TLS. TLS implies the connection will be routed based on the SNI header to the destination without terminating the TLS connection.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.ServiceEntry\": {\n          description:\n            \"ServiceEntry enables adding additional entries into Istio's internal service registry.\",\n          type: \"object\",\n          properties: {\n            exportTo: {\n              description:\n                \"A list of namespaces to which this service is exported. Exporting a service allows it to be used by sidecars, gateways and virtual services defined in other namespaces. This feature provides a mechanism for service owners and mesh administrators to control the visibility of services across namespace boundaries.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            subjectAltNames: {\n              description:\n                \"If specified, the proxy will verify that the server certificate's subject alternate name matches one of the specified values.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            hosts: {\n              description:\n                \"The hosts associated with the ServiceEntry. Could be a DNS name with wildcard prefix.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            addresses: {\n              description:\n                \"The virtual IP addresses associated with the service. Could be CIDR prefix. For HTTP traffic, generated route configurations will include http route domains for both the `addresses` and `hosts` field values and the destination will be identified based on the HTTP Host/Authority header. If one or more IP addresses are specified, the incoming traffic will be identified as belonging to this service if the destination IP matches the IP/CIDRs specified in the addresses field. If the Addresses field is empty, traffic will be identified solely based on the destination port. In such scenarios, the port on which the service is being accessed must not be shared by any other service in the mesh. In other words, the sidecar will behave as a simple TCP proxy, forwarding incoming traffic on a specified port to the specified destination endpoint IP/host. Unix domain socket addresses are not supported in this field.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            ports: {\n              description:\n                \"The ports associated with the external service. If the Endpoints are Unix domain socket addresses, there must be exactly one port.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.networking.v1beta1.Port\",\n              },\n            },\n            location: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ServiceEntry.Location\",\n            },\n            resolution: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ServiceEntry.Resolution\",\n            },\n            endpoints: {\n              description:\n                \"One or more endpoints associated with the service. Only one of `endpoints` or `workloadSelector` can be specified.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1beta1.WorkloadEntry\",\n              },\n            },\n            workloadSelector: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.WorkloadSelector\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.ServiceEntry.Location\": {\n          description:\n            \"Location specifies whether the service is part of Istio mesh or outside the mesh. Location determines the behavior of several features, such as service-to-service mTLS authentication, policy enforcement, etc. When communicating with services outside the mesh, Istio's mTLS authentication is disabled, and policy enforcement is performed on the client-side as opposed to server-side.\",\n          type: \"string\",\n          enum: [\"MESH_EXTERNAL\", \"MESH_INTERNAL\"],\n        },\n        \"istio.networking.v1beta1.ServiceEntry.Resolution\": {\n          description:\n            \"Resolution determines how the proxy will resolve the IP addresses of the network endpoints associated with the service, so that it can route to one of them. The resolution mode specified here has no impact on how the application resolves the IP address associated with the service. The application may still have to use DNS to resolve the service to an IP so that the outbound traffic can be captured by the Proxy. Alternatively, for HTTP services, the application could directly communicate with the proxy (e.g., by setting HTTP_PROXY) to talk to these services.\",\n          type: \"string\",\n          enum: [\"NONE\", \"STATIC\", \"DNS\"],\n        },\n        \"istio.networking.v1beta1.WorkloadEntry\": {\n          description:\n            \"WorkloadEntry enables specifying the properties of a single non-Kubernetes workload such a VM or a bare metal services that can be referred to by service entries.\",\n          type: \"object\",\n          properties: {\n            labels: {\n              description: \"One or more labels associated with the endpoint.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            ports: {\n              description:\n                \"Set of ports associated with the endpoint. The ports must be associated with a port name that was declared as part of the service. Do not use for `unix://` addresses.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"integer\",\n              },\n            },\n            weight: {\n              description:\n                \"The load balancing weight associated with the endpoint. Endpoints with higher weights will receive proportionally higher traffic.\",\n              type: \"integer\",\n            },\n            address: {\n              description:\n                \"Address associated with the network endpoint without the port. Domain names can be used if and only if the resolution is set to DNS, and must be fully-qualified without wildcards. Use the form unix:///absolute/path/to/socket for Unix domain socket endpoints.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            network: {\n              description:\n                \"Network enables Istio to group endpoints resident in the same L3 domain/network. All endpoints in the same network are assumed to be directly reachable from one another. When endpoints in different networks cannot reach each other directly, an Istio Gateway can be used to establish connectivity (usually using the `AUTO_PASSTHROUGH` mode in a Gateway Server). This is an advanced configuration used typically for spanning an Istio mesh over multiple clusters.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            locality: {\n              description:\n                'The locality associated with the endpoint. A locality corresponds to a failure domain (e.g., country/region/zone). Arbitrary failure domain hierarchies can be represented by separating each encapsulating failure domain by /. For example, the locality of an an endpoint in US, in US-East-1 region, within availability zone az-1, in data center rack r11 can be represented as us/us-east-1/az-1/r11. Istio will configure the sidecar to route to endpoints within the same locality as the sidecar. If none of the endpoints in the locality are available, endpoints parent locality (but within the same network ID) will be chosen. For example, if there are two endpoints in same network (networkID \"n1\"), say e1 with locality us/us-east-1/az-1/r11 and e2 with locality us/us-east-1/az-2/r12, a sidecar from us/us-east-1/az-1/r11 locality will prefer e1 from the same locality over e2 from a different locality. Endpoint e2 could be the IP associated with a gateway (that bridges networks n1 and n2), or the IP associated with a standard service endpoint.',\n              type: \"string\",\n              format: \"string\",\n            },\n            serviceAccount: {\n              description:\n                \"The service account associated with the workload if a sidecar is present in the workload. The service account must be present in the same namespace as the configuration ( WorkloadEntry or a ServiceEntry)\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.WorkloadSelector\": {\n          description:\n            \"`WorkloadSelector` specifies the criteria used to determine if the `Gateway`, `Sidecar`, or `EnvoyFilter` configuration can be applied to a proxy. The matching criteria includes the metadata associated with a proxy, workload instance info such as labels attached to the pod/VM, or any other info that the proxy provides to Istio during the initial handshake. If multiple conditions are specified, all conditions need to match in order for the workload instance to be selected. Currently, only label based selection mechanism is supported.\",\n          type: \"object\",\n          properties: {\n            labels: {\n              description:\n                \"One or more labels that indicate a specific set of pods/VMs on which this `Sidecar` configuration should be applied. The scope of label search is restricted to the configuration namespace in which the the resource is present.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Configuration affecting edge load balancer.\",\n      version: \"v1beta1\",\n    },\n    components: {\n      schemas: {\n        \"istio.networking.v1beta1.Gateway\": {\n          description:\n            \"Gateway describes a load balancer operating at the edge of the mesh receiving incoming or outgoing HTTP/TCP connections.\",\n          type: \"object\",\n          properties: {\n            servers: {\n              description: \"A list of server specifications.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.networking.v1beta1.Server\",\n              },\n            },\n            selector: {\n              description:\n                \"One or more labels that indicate a specific set of pods/VMs on which this gateway configuration should be applied. The scope of label search is restricted to the configuration namespace in which the the resource is present. In other words, the Gateway resource must reside in the same namespace as the gateway workload instance. If selector is nil, the Gateway will be applied to all workloads.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1beta1.Server\": {\n          description:\n            \"`Server` describes the properties of the proxy on a given load balancer port. For example,\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"An optional name of the server, when set must be unique across all servers. This will be used for variety of purposes like prefixing stats generated with this name etc.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            tls: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ServerTLSSettings\",\n            },\n            port: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.Port\",\n            },\n            bind: {\n              description:\n                \"The ip or the Unix domain socket to which the listener should be bound to. Format: `x.x.x.x` or `unix:///path/to/uds` or `unix://@foobar` (Linux abstract namespace). When using Unix domain sockets, the port number should be 0.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            hosts: {\n              description:\n                \"One or more hosts exposed by this gateway. While typically applicable to HTTP services, it can also be used for TCP services using TLS with SNI. A host is specified as a `dnsName` with an optional `namespace/` prefix. The `dnsName` should be specified using FQDN format, optionally including a wildcard character in the left-most component (e.g., `prod/*.example.com`). Set the `dnsName` to `*` to select all `VirtualService` hosts from the specified namespace (e.g.,`prod/*`).\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            defaultEndpoint: {\n              description:\n                \"The loopback IP endpoint or Unix domain socket to which traffic should be forwarded to by default. Format should be `127.0.0.1:PORT` or `unix:///path/to/socket` or `unix://@foobar` (Linux abstract namespace). NOT IMPLEMENTED. $hide_from_docs\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.Port\": {\n          description:\n            \"Port describes the properties of a specific port of a service.\",\n          type: \"object\",\n          properties: {\n            number: {\n              description: \"A valid non-negative integer port number.\",\n              type: \"integer\",\n            },\n            name: {\n              description: \"Label assigned to the port.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            protocol: {\n              description:\n                \"The protocol exposed on the port. MUST BE one of HTTP|HTTPS|GRPC|HTTP2|MONGO|TCP|TLS. TLS implies the connection will be routed based on the SNI header to the destination without terminating the TLS connection.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.ServerTLSSettings\": {\n          type: \"object\",\n          properties: {\n            mode: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ServerTLSSettings.TLSmode\",\n            },\n            privateKey: {\n              description:\n                \"REQUIRED if mode is `SIMPLE` or `MUTUAL`. The path to the file holding the server's private key.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            caCertificates: {\n              description:\n                \"REQUIRED if mode is `MUTUAL`. The path to a file containing certificate authority certificates to use in verifying a presented client side certificate.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            credentialName: {\n              description:\n                \"For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates. Applicable only on Kubernetes, and only if the dynamic credential fetching feature is enabled in the proxy by setting `ISTIO_META_USER_SDS` metadata variable. The secret (of type `generic`) should contain the following keys and values: `key: \\u003cprivateKey\\u003e`, `cert: \\u003cserverCert\\u003e`, `cacert: \\u003cCACertificate\\u003e`. Secret of type tls for server certificates along with ca.crt key for CA certificates is also supported. Only one of server certificates and CA certificate or credentialName can be specified.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            subjectAltNames: {\n              description:\n                \"A list of alternate names to verify the subject identity in the certificate presented by the client.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            httpsRedirect: {\n              description:\n                \"If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.\",\n              type: \"boolean\",\n            },\n            serverCertificate: {\n              description:\n                \"REQUIRED if mode is `SIMPLE` or `MUTUAL`. The path to the file holding the server-side TLS certificate to use.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            verifyCertificateSpki: {\n              description:\n                \"An optional list of base64-encoded SHA-256 hashes of the SKPIs of authorized client certificates. Note: When both verify_certificate_hash and verify_certificate_spki are specified, a hash matching either value will result in the certificate being accepted.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            verifyCertificateHash: {\n              description:\n                \"An optional list of hex-encoded SHA-256 hashes of the authorized client certificates. Both simple and colon separated formats are acceptable. Note: When both verify_certificate_hash and verify_certificate_spki are specified, a hash matching either value will result in the certificate being accepted.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            minProtocolVersion: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ServerTLSSettings.TLSProtocol\",\n            },\n            maxProtocolVersion: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ServerTLSSettings.TLSProtocol\",\n            },\n            cipherSuites: {\n              description:\n                \"Optional: If specified, only support the specified cipher list. Otherwise default to the default cipher list supported by Envoy.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1beta1.ServerTLSSettings.TLSmode\": {\n          description: \"TLS modes enforced by the proxy\",\n          type: \"string\",\n          enum: [\n            \"PASSTHROUGH\",\n            \"SIMPLE\",\n            \"MUTUAL\",\n            \"AUTO_PASSTHROUGH\",\n            \"ISTIO_MUTUAL\",\n          ],\n        },\n        \"istio.networking.v1beta1.ServerTLSSettings.TLSProtocol\": {\n          description: \"TLS protocol versions.\",\n          type: \"string\",\n          enum: [\"TLS_AUTO\", \"TLSV1_0\", \"TLSV1_1\", \"TLSV1_2\", \"TLSV1_3\"],\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Configuration affecting VMs onboarded into the mesh.\",\n      version: \"v1beta1\",\n    },\n    components: {\n      schemas: {\n        \"istio.networking.v1beta1.WorkloadEntry\": {\n          description:\n            \"WorkloadEntry enables specifying the properties of a single non-Kubernetes workload such a VM or a bare metal services that can be referred to by service entries.\",\n          type: \"object\",\n          properties: {\n            labels: {\n              description: \"One or more labels associated with the endpoint.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            ports: {\n              description:\n                \"Set of ports associated with the endpoint. The ports must be associated with a port name that was declared as part of the service. Do not use for `unix://` addresses.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"integer\",\n              },\n            },\n            weight: {\n              description:\n                \"The load balancing weight associated with the endpoint. Endpoints with higher weights will receive proportionally higher traffic.\",\n              type: \"integer\",\n            },\n            address: {\n              description:\n                \"Address associated with the network endpoint without the port. Domain names can be used if and only if the resolution is set to DNS, and must be fully-qualified without wildcards. Use the form unix:///absolute/path/to/socket for Unix domain socket endpoints.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            network: {\n              description:\n                \"Network enables Istio to group endpoints resident in the same L3 domain/network. All endpoints in the same network are assumed to be directly reachable from one another. When endpoints in different networks cannot reach each other directly, an Istio Gateway can be used to establish connectivity (usually using the `AUTO_PASSTHROUGH` mode in a Gateway Server). This is an advanced configuration used typically for spanning an Istio mesh over multiple clusters.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            locality: {\n              description:\n                'The locality associated with the endpoint. A locality corresponds to a failure domain (e.g., country/region/zone). Arbitrary failure domain hierarchies can be represented by separating each encapsulating failure domain by /. For example, the locality of an an endpoint in US, in US-East-1 region, within availability zone az-1, in data center rack r11 can be represented as us/us-east-1/az-1/r11. Istio will configure the sidecar to route to endpoints within the same locality as the sidecar. If none of the endpoints in the locality are available, endpoints parent locality (but within the same network ID) will be chosen. For example, if there are two endpoints in same network (networkID \"n1\"), say e1 with locality us/us-east-1/az-1/r11 and e2 with locality us/us-east-1/az-2/r12, a sidecar from us/us-east-1/az-1/r11 locality will prefer e1 from the same locality over e2 from a different locality. Endpoint e2 could be the IP associated with a gateway (that bridges networks n1 and n2), or the IP associated with a standard service endpoint.',\n              type: \"string\",\n              format: \"string\",\n            },\n            serviceAccount: {\n              description:\n                \"The service account associated with the workload if a sidecar is present in the workload. The service account must be present in the same namespace as the configuration ( WorkloadEntry or a ServiceEntry)\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Configuration affecting label/content routing, sni routing, etc.\",\n      version: \"v1beta1\",\n    },\n    components: {\n      schemas: {\n        \"istio.networking.v1beta1.PortSelector\": {\n          description:\n            \"PortSelector specifies the number of a port to be used for matching or selection for final routing.\",\n          type: \"object\",\n          properties: {\n            number: {\n              description: \"Valid port number\",\n              type: \"integer\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.Destination\": {\n          description:\n            \"Destination indicates the network addressable service to which the request/connection will be sent after processing a routing rule. The destination.host should unambiguously refer to a service in the service registry. Istio's service registry is composed of all the services found in the platform's service registry (e.g., Kubernetes services, Consul services), as well as services declared through the [ServiceEntry](https://istio.io/docs/reference/config/networking/service-entry/#ServiceEntry) resource.\",\n          type: \"object\",\n          properties: {\n            host: {\n              description:\n                \"The name of a service from the service registry. Service names are looked up from the platform's service registry (e.g., Kubernetes services, Consul services, etc.) and from the hosts declared by [ServiceEntry](https://istio.io/docs/reference/config/networking/service-entry/#ServiceEntry). Traffic forwarded to destinations that are not found in either of the two, will be dropped.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            port: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.PortSelector\",\n            },\n            subset: {\n              description:\n                \"The name of a subset within the service. Applicable only to services within the mesh. The subset must be defined in a corresponding DestinationRule.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.VirtualService\": {\n          description: \"Configuration affecting traffic routing.\",\n          type: \"object\",\n          properties: {\n            exportTo: {\n              description:\n                \"A list of namespaces to which this virtual service is exported. Exporting a virtual service allows it to be used by sidecars and gateways defined in other namespaces. This feature provides a mechanism for service owners and mesh administrators to control the visibility of virtual services across namespace boundaries.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            tls: {\n              description:\n                \"An ordered list of route rule for non-terminated TLS \\u0026 HTTPS traffic. Routing is typically performed using the SNI value presented by the ClientHello message. TLS routes will be applied to platform service ports named 'https-*', 'tls-*', unterminated gateway ports using HTTPS/TLS protocols (i.e. with \\\"passthrough\\\" TLS mode) and service entry ports using HTTPS/TLS protocols. The first rule matching an incoming request is used. NOTE: Traffic 'https-*' or 'tls-*' ports without associated virtual service will be treated as opaque TCP traffic.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.networking.v1beta1.TLSRoute\",\n              },\n            },\n            tcp: {\n              description:\n                \"An ordered list of route rules for opaque TCP traffic. TCP routes will be applied to any port that is not a HTTP or TLS port. The first rule matching an incoming request is used.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.networking.v1beta1.TCPRoute\",\n              },\n            },\n            http: {\n              description:\n                \"An ordered list of route rules for HTTP traffic. HTTP routes will be applied to platform service ports named 'http-*'/'http2-*'/'grpc-*', gateway ports with protocol HTTP/HTTP2/GRPC/ TLS-terminated-HTTPS and service entry ports using HTTP/HTTP2/GRPC protocols. The first rule matching an incoming request is used.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.networking.v1beta1.HTTPRoute\",\n              },\n            },\n            hosts: {\n              description:\n                \"The destination hosts to which traffic is being sent. Could be a DNS name with wildcard prefix or an IP address. Depending on the platform, short-names can also be used instead of a FQDN (i.e. has no dots in the name). In such a scenario, the FQDN of the host would be derived based on the underlying platform.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            gateways: {\n              description:\n                \"The names of gateways and sidecars that should apply these routes. Gateways in other namespaces may be referred to by `\\u003cgateway namespace\\u003e/\\u003cgateway name\\u003e`; specifying a gateway with no namespace qualifier is the same as specifying the VirtualService's namespace. A single VirtualService is used for sidecars inside the mesh as well as for one or more gateways. The selection condition imposed by this field can be overridden using the source field in the match conditions of protocol-specific routes. The reserved word `mesh` is used to imply all the sidecars in the mesh. When this field is omitted, the default gateway (`mesh`) will be used, which would apply the rule to all sidecars in the mesh. If a list of gateway names is provided, the rules will apply only to the gateways. To apply the rules to both gateways and sidecars, specify `mesh` as one of the gateway names.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1beta1.HTTPRoute\": {\n          description:\n            \"Describes match conditions and actions for routing HTTP/1.1, HTTP2, and gRPC traffic. See VirtualService for usage examples.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"The name assigned to the route for debugging purposes. The route's name will be concatenated with the match's name and will be logged in the access logs for requests matching this route/match.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            match: {\n              description:\n                \"Match conditions to be satisfied for the rule to be activated. All conditions inside a single match block have AND semantics, while the list of match blocks have OR semantics. The rule is matched if any one of the match blocks succeed.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1beta1.HTTPMatchRequest\",\n              },\n            },\n            route: {\n              description:\n                \"A HTTP rule can either redirect or forward (default) traffic. The forwarding target can be one of several versions of a service (see glossary in beginning of document). Weights associated with the service version determine the proportion of traffic it receives.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1beta1.HTTPRouteDestination\",\n              },\n            },\n            redirect: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.HTTPRedirect\",\n            },\n            delegate: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.Delegate\",\n            },\n            rewrite: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.HTTPRewrite\",\n            },\n            timeout: {\n              description: \"Timeout for HTTP requests.\",\n              type: \"string\",\n            },\n            retries: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.HTTPRetry\",\n            },\n            fault: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.HTTPFaultInjection\",\n            },\n            mirror: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.Destination\",\n            },\n            mirrorPercent: {\n              description:\n                \"Percentage of the traffic to be mirrored by the `mirror` field. Use of integer `mirror_percent` value is deprecated. Use the double `mirror_percentage` field instead\",\n              type: \"integer\",\n              deprecated: true,\n              nullable: true,\n            },\n            mirrorPercentage: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.Percent\",\n            },\n            corsPolicy: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.CorsPolicy\",\n            },\n            headers: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.Headers\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.TLSRoute\": {\n          description:\n            'Describes match conditions and actions for routing unterminated TLS traffic (TLS/HTTPS) The following routing rule forwards unterminated TLS traffic arriving at port 443 of gateway called \"mygateway\" to internal services in the mesh based on the SNI value.',\n          type: \"object\",\n          properties: {\n            match: {\n              description:\n                \"Match conditions to be satisfied for the rule to be activated. All conditions inside a single match block have AND semantics, while the list of match blocks have OR semantics. The rule is matched if any one of the match blocks succeed.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1beta1.TLSMatchAttributes\",\n              },\n            },\n            route: {\n              description:\n                \"The destination to which the connection should be forwarded to.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1beta1.RouteDestination\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1beta1.TCPRoute\": {\n          description:\n            \"Describes match conditions and actions for routing TCP traffic. The following routing rule forwards traffic arriving at port 27017 for mongo.prod.svc.cluster.local to another Mongo server on port 5555.\",\n          type: \"object\",\n          properties: {\n            match: {\n              description:\n                \"Match conditions to be satisfied for the rule to be activated. All conditions inside a single match block have AND semantics, while the list of match blocks have OR semantics. The rule is matched if any one of the match blocks succeed.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1beta1.L4MatchAttributes\",\n              },\n            },\n            route: {\n              description:\n                \"The destination to which the connection should be forwarded to.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1beta1.RouteDestination\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1beta1.HTTPMatchRequest\": {\n          description:\n            \"HttpMatchRequest specifies a set of criterion to be met in order for the rule to be applied to the HTTP request. For example, the following restricts the rule to match only requests where the URL path starts with /ratings/v2/ and the request contains a custom `end-user` header with value `jason`.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"The name assigned to a match. The match's name will be concatenated with the parent route's name and will be logged in the access logs for requests matching this route.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            method: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.StringMatch\",\n            },\n            port: {\n              description:\n                \"Specifies the ports on the host that is being addressed. Many services only expose a single port or label ports with the protocols they support, in these cases it is not required to explicitly select the port.\",\n              type: \"integer\",\n            },\n            gateways: {\n              description:\n                \"Names of gateways where the rule should be applied. Gateway names in the top-level `gateways` field of the VirtualService (if any) are overridden. The gateway match is independent of sourceLabels.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            headers: {\n              description:\n                \"The header keys must be lowercase and use hyphen as the separator, e.g. _x-request-id_.\",\n              type: \"object\",\n              additionalProperties: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1beta1.StringMatch\",\n              },\n            },\n            uri: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.StringMatch\",\n            },\n            scheme: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.StringMatch\",\n            },\n            authority: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.StringMatch\",\n            },\n            sourceLabels: {\n              description:\n                \"One or more labels that constrain the applicability of a rule to workloads with the given labels. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it must include the reserved gateway `mesh` for this field to be applicable.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            queryParams: {\n              description: \"Query parameters for matching.\",\n              type: \"object\",\n              additionalProperties: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1beta1.StringMatch\",\n              },\n            },\n            ignoreUriCase: {\n              description:\n                \"Flag to specify whether the URI matching should be case-insensitive.\",\n              type: \"boolean\",\n            },\n            withoutHeaders: {\n              description:\n                \"withoutHeader has the same syntax with the header, but has opposite meaning. If a header is matched with a matching rule among withoutHeader, the traffic becomes not matched one.\",\n              type: \"object\",\n              additionalProperties: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1beta1.StringMatch\",\n              },\n            },\n            sourceNamespace: {\n              description:\n                \"Source namespace constraining the applicability of a rule to workloads in that namespace. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it must include the reserved gateway `mesh` for this field to be applicable.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.HTTPRouteDestination\": {\n          description:\n            'Each routing rule is associated with one or more service versions (see glossary in beginning of document). Weights associated with the version determine the proportion of traffic it receives. For example, the following rule will route 25% of traffic for the \"reviews\" service to instances with the \"v2\" tag and the remaining traffic (i.e., 75%) to \"v1\".',\n          type: \"object\",\n          properties: {\n            headers: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.Headers\",\n            },\n            destination: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.Destination\",\n            },\n            weight: {\n              description:\n                \"The proportion of traffic to be forwarded to the service version. (0-100). Sum of weights across destinations SHOULD BE == 100. If there is only one destination in a rule, the weight value is assumed to be 100.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.HTTPRedirect\": {\n          description:\n            \"HTTPRedirect can be used to send a 301 redirect response to the caller, where the Authority/Host and the URI in the response can be swapped with the specified values. For example, the following rule redirects requests for /v1/getProductRatings API on the ratings service to /v1/bookRatings provided by the bookratings service.\",\n          type: \"object\",\n          properties: {\n            uri: {\n              description:\n                \"On a redirect, overwrite the Path portion of the URL with this value. Note that the entire path will be replaced, irrespective of the request URI being matched as an exact path or prefix.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            authority: {\n              description:\n                \"On a redirect, overwrite the Authority/Host portion of the URL with this value.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            redirectCode: {\n              description:\n                \"On a redirect, Specifies the HTTP status code to use in the redirect response. The default response code is MOVED_PERMANENTLY (301).\",\n              type: \"integer\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.Delegate\": {\n          description:\n            \"Describes the delegate VirtualService. The following routing rules forward the traffic to `/productpage` by a delegate VirtualService named `productpage`, forward the traffic to `/reviews` by a delegate VirtualService named `reviews`.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"Name specifies the name of the delegate VirtualService.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            namespace: {\n              description:\n                \"Namespace specifies the namespace where the delegate VirtualService resides. By default, it is same to the root's.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.HTTPRewrite\": {\n          description:\n            \"HTTPRewrite can be used to rewrite specific parts of a HTTP request before forwarding the request to the destination. Rewrite primitive can be used only with HTTPRouteDestination. The following example demonstrates how to rewrite the URL prefix for api call (/ratings) to ratings service before making the actual API call.\",\n          type: \"object\",\n          properties: {\n            uri: {\n              description:\n                \"rewrite the path (or the prefix) portion of the URI with this value. If the original URI was matched based on prefix, the value provided in this field will replace the corresponding matched prefix.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            authority: {\n              description: \"rewrite the Authority/Host header with this value.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.HTTPRetry\": {\n          description:\n            \"Describes the retry policy to use when a HTTP request fails. For example, the following rule sets the maximum number of retries to 3 when calling ratings:v1 service, with a 2s timeout per retry attempt.\",\n          type: \"object\",\n          properties: {\n            attempts: {\n              description:\n                \"Number of retries for a given request. The interval between retries will be determined automatically (25ms+). Actual number of retries attempted depends on the request `timeout` of the [HTTP route](https://istio.io/docs/reference/config/networking/virtual-service/#HTTPRoute).\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            perTryTimeout: {\n              description:\n                \"Timeout per retry attempt for a given request. format: 1h/1m/1s/1ms. MUST BE \\u003e=1ms.\",\n              type: \"string\",\n            },\n            retryOn: {\n              description:\n                \"Specifies the conditions under which retry takes place. One or more policies can be specified using a ‘,’ delimited list. See the [retry policies](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on) and [gRPC retry policies](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-grpc-on) for more details.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            retryRemoteLocalities: {\n              description:\n                \"Flag to specify whether the retries should retry to other localities. See the [retry plugin configuration](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/http_connection_management#retry-plugin-configuration) for more details.\",\n              type: \"boolean\",\n              nullable: true,\n            },\n          },\n        },\n        \"istio.networking.v1beta1.HTTPFaultInjection\": {\n          description:\n            \"HTTPFaultInjection can be used to specify one or more faults to inject while forwarding HTTP requests to the destination specified in a route. Fault specification is part of a VirtualService rule. Faults include aborting the Http request from downstream service, and/or delaying proxying of requests. A fault rule MUST HAVE delay or abort or both.\",\n          type: \"object\",\n          properties: {\n            delay: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.HTTPFaultInjection.Delay\",\n            },\n            abort: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.HTTPFaultInjection.Abort\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.Percent\": {\n          description:\n            \"Percent specifies a percentage in the range of [0.0, 100.0].\",\n          type: \"object\",\n          properties: {\n            value: {\n              type: \"number\",\n              format: \"double\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.CorsPolicy\": {\n          description:\n            \"Describes the Cross-Origin Resource Sharing (CORS) policy, for a given service. Refer to [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS) for further details about cross origin resource sharing. For example, the following rule restricts cross origin requests to those originating from example.com domain using HTTP POST/GET, and sets the `Access-Control-Allow-Credentials` header to false. In addition, it only exposes `X-Foo-bar` header and sets an expiry period of 1 day.\",\n          type: \"object\",\n          properties: {\n            allowOrigin: {\n              description:\n                \"The list of origins that are allowed to perform CORS requests. The content will be serialized into the Access-Control-Allow-Origin header. Wildcard * will allow all origins. $hide_from_docs\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n              deprecated: true,\n            },\n            allowOrigins: {\n              description:\n                \"String patterns that match allowed origins. An origin is allowed if any of the string matchers match. If a match is found, then the outgoing Access-Control-Allow-Origin would be set to the origin as provided by the client.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1beta1.StringMatch\",\n              },\n            },\n            allowMethods: {\n              description:\n                \"List of HTTP methods allowed to access the resource. The content will be serialized into the Access-Control-Allow-Methods header.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            allowHeaders: {\n              description:\n                \"List of HTTP headers that can be used when requesting the resource. Serialized to Access-Control-Allow-Headers header.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            exposeHeaders: {\n              description:\n                \"A white list of HTTP headers that the browsers are allowed to access. Serialized into Access-Control-Expose-Headers header.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            maxAge: {\n              description:\n                \"Specifies how long the results of a preflight request can be cached. Translates to the `Access-Control-Max-Age` header.\",\n              type: \"string\",\n            },\n            allowCredentials: {\n              description:\n                \"Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials. Translates to `Access-Control-Allow-Credentials` header.\",\n              type: \"boolean\",\n              nullable: true,\n            },\n          },\n        },\n        \"istio.networking.v1beta1.Headers\": {\n          description:\n            \"Message headers can be manipulated when Envoy forwards requests to, or responses from, a destination service. Header manipulation rules can be specified for a specific route destination or for all destinations. The following VirtualService adds a `test` header with the value `true` to requests that are routed to any `reviews` service destination. It also romoves the `foo` response header, but only from responses coming from the `v1` subset (version) of the `reviews` service.\",\n          type: \"object\",\n          properties: {\n            response: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.Headers.HeaderOperations\",\n            },\n            request: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.Headers.HeaderOperations\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.Headers.HeaderOperations\": {\n          description:\n            \"HeaderOperations Describes the header manipulations to apply\",\n          type: \"object\",\n          properties: {\n            set: {\n              description:\n                \"Overwrite the headers specified by key with the given values\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            add: {\n              description:\n                \"Append the given values to the headers specified by keys (will create a comma-separated list of values)\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            remove: {\n              description: \"Remove a the specified headers\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1beta1.TLSMatchAttributes\": {\n          description: \"TLS connection match attributes.\",\n          type: \"object\",\n          properties: {\n            port: {\n              description:\n                \"Specifies the port on the host that is being addressed. Many services only expose a single port or label ports with the protocols they support, in these cases it is not required to explicitly select the port.\",\n              type: \"integer\",\n            },\n            gateways: {\n              description:\n                \"Names of gateways where the rule should be applied. Gateway names in the top-level `gateways` field of the VirtualService (if any) are overridden. The gateway match is independent of sourceLabels.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            sourceLabels: {\n              description:\n                \"One or more labels that constrain the applicability of a rule to workloads with the given labels. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it should include the reserved gateway `mesh` in order for this field to be applicable.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            sourceNamespace: {\n              description:\n                \"Source namespace constraining the applicability of a rule to workloads in that namespace. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it must include the reserved gateway `mesh` for this field to be applicable.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            destinationSubnets: {\n              description:\n                \"IPv4 or IPv6 ip addresses of destination with optional subnet. E.g., a.b.c.d/xx form or just a.b.c.d.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            sniHosts: {\n              description:\n                \"SNI (server name indicator) to match on. Wildcard prefixes can be used in the SNI value, e.g., *.com will match foo.example.com as well as example.com. An SNI value must be a subset (i.e., fall within the domain) of the corresponding virtual serivce's hosts.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1beta1.RouteDestination\": {\n          description: \"L4 routing rule weighted destination.\",\n          type: \"object\",\n          properties: {\n            destination: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.Destination\",\n            },\n            weight: {\n              description:\n                \"The proportion of traffic to be forwarded to the service version. If there is only one destination in a rule, all traffic will be routed to it irrespective of the weight.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.L4MatchAttributes\": {\n          description:\n            \"L4 connection match attributes. Note that L4 connection matching support is incomplete.\",\n          type: \"object\",\n          properties: {\n            port: {\n              description:\n                \"Specifies the port on the host that is being addressed. Many services only expose a single port or label ports with the protocols they support, in these cases it is not required to explicitly select the port.\",\n              type: \"integer\",\n            },\n            gateways: {\n              description:\n                \"Names of gateways where the rule should be applied. Gateway names in the top-level `gateways` field of the VirtualService (if any) are overridden. The gateway match is independent of sourceLabels.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            sourceLabels: {\n              description:\n                \"One or more labels that constrain the applicability of a rule to workloads with the given labels. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it should include the reserved gateway `mesh` in order for this field to be applicable.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            sourceNamespace: {\n              description:\n                \"Source namespace constraining the applicability of a rule to workloads in that namespace. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it must include the reserved gateway `mesh` for this field to be applicable.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            destinationSubnets: {\n              description:\n                \"IPv4 or IPv6 ip addresses of destination with optional subnet. E.g., a.b.c.d/xx form or just a.b.c.d.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            sourceSubnet: {\n              description:\n                \"IPv4 or IPv6 ip address of source with optional subnet. E.g., a.b.c.d/xx form or just a.b.c.d $hide_from_docs\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.StringMatch\": {\n          description:\n            \"Describes how to match a given string in HTTP headers. Match is case-sensitive.\",\n          type: \"object\",\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"exact\"],\n                    properties: {\n                      exact: {\n                        description: \"exact string match\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"prefix\"],\n                    properties: {\n                      prefix: {\n                        description: \"prefix-based match\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"regex\"],\n                    properties: {\n                      regex: {\n                        description:\n                          \"RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"exact\"],\n              properties: {\n                exact: {\n                  description: \"exact string match\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"prefix\"],\n              properties: {\n                prefix: {\n                  description: \"prefix-based match\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"regex\"],\n              properties: {\n                regex: {\n                  description:\n                    \"RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n          ],\n        },\n        \"istio.networking.v1beta1.HTTPFaultInjection.Delay\": {\n          description:\n            'Delay specification is used to inject latency into the request forwarding path. The following example will introduce a 5 second delay in 1 out of every 1000 requests to the \"v1\" version of the \"reviews\" service from all pods with label env: prod',\n          type: \"object\",\n          properties: {\n            percent: {\n              description:\n                \"Percentage of requests on which the delay will be injected (0-100). Use of integer `percent` value is deprecated. Use the double `percentage` field instead.\",\n              type: \"integer\",\n              format: \"int32\",\n              deprecated: true,\n            },\n            percentage: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.Percent\",\n            },\n          },\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"fixedDelay\"],\n                    properties: {\n                      fixedDelay: {\n                        description:\n                          \"Add a fixed delay before forwarding the request. Format: 1h/1m/1s/1ms. MUST be \\u003e=1ms.\",\n                        type: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"exponentialDelay\"],\n                    properties: {\n                      exponentialDelay: {\n                        type: \"string\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"fixedDelay\"],\n              properties: {\n                fixedDelay: {\n                  description:\n                    \"Add a fixed delay before forwarding the request. Format: 1h/1m/1s/1ms. MUST be \\u003e=1ms.\",\n                  type: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"exponentialDelay\"],\n              properties: {\n                exponentialDelay: {\n                  type: \"string\",\n                },\n              },\n            },\n          ],\n        },\n        \"istio.networking.v1beta1.HTTPFaultInjection.Abort\": {\n          description:\n            'Abort specification is used to prematurely abort a request with a pre-specified error code. The following example will return an HTTP 400 error code for 1 out of every 1000 requests to the \"ratings\" service \"v1\".',\n          type: \"object\",\n          properties: {\n            percentage: {\n              $ref: \"#/components/schemas/istio.networking.v1beta1.Percent\",\n            },\n          },\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"httpStatus\"],\n                    properties: {\n                      httpStatus: {\n                        description:\n                          \"HTTP status code to use to abort the Http request.\",\n                        type: \"integer\",\n                        format: \"int32\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"grpcStatus\"],\n                    properties: {\n                      grpcStatus: {\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"http2Error\"],\n                    properties: {\n                      http2Error: {\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"httpStatus\"],\n              properties: {\n                httpStatus: {\n                  description:\n                    \"HTTP status code to use to abort the Http request.\",\n                  type: \"integer\",\n                  format: \"int32\",\n                },\n              },\n            },\n            {\n              required: [\"grpcStatus\"],\n              properties: {\n                grpcStatus: {\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"http2Error\"],\n              properties: {\n                http2Error: {\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n          ],\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Configuration affecting load balancing, outlier detection, etc.\",\n      version: \"v1beta1\",\n    },\n    components: {\n      schemas: {\n        \"istio.networking.v1beta1.DestinationRule\": {\n          description:\n            \"DestinationRule defines policies that apply to traffic intended for a service after routing has occurred.\",\n          type: \"object\",\n          properties: {\n            host: {\n              description:\n                \"The name of a service from the service registry. Service names are looked up from the platform's service registry (e.g., Kubernetes services, Consul services, etc.) and from the hosts declared by [ServiceEntries](https://istio.io/docs/reference/config/networking/service-entry/#ServiceEntry). Rules defined for services that do not exist in the service registry will be ignored.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            trafficPolicy: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.TrafficPolicy\",\n            },\n            subsets: {\n              description:\n                \"One or more named sets that represent individual versions of a service. Traffic policies can be overridden at subset level.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.networking.v1beta1.Subset\",\n              },\n            },\n            exportTo: {\n              description:\n                \"A list of namespaces to which this destination rule is exported. The resolution of a destination rule to apply to a service occurs in the context of a hierarchy of namespaces. Exporting a destination rule allows it to be included in the resolution hierarchy for services in other namespaces. This feature provides a mechanism for service owners and mesh administrators to control the visibility of destination rules across namespace boundaries.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1beta1.TrafficPolicy\": {\n          description:\n            \"Traffic policies to apply for a specific destination, across all destination ports. See DestinationRule for examples.\",\n          type: \"object\",\n          properties: {\n            loadBalancer: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.LoadBalancerSettings\",\n            },\n            connectionPool: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ConnectionPoolSettings\",\n            },\n            outlierDetection: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.OutlierDetection\",\n            },\n            tls: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ClientTLSSettings\",\n            },\n            portLevelSettings: {\n              description:\n                \"Traffic policies specific to individual ports. Note that port level settings will override the destination-level settings. Traffic settings specified at the destination-level will not be inherited when overridden by port-level settings, i.e. default values will be applied to fields omitted in port-level traffic policies.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1beta1.TrafficPolicy.PortTrafficPolicy\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1beta1.Subset\": {\n          description:\n            \"A subset of endpoints of a service. Subsets can be used for scenarios like A/B testing, or routing to a specific version of a service. Refer to [VirtualService](https://istio.io/docs/reference/config/networking/virtual-service/#VirtualService) documentation for examples of using subsets in these scenarios. In addition, traffic policies defined at the service-level can be overridden at a subset-level. The following rule uses a round robin load balancing policy for all traffic going to a subset named testversion that is composed of endpoints (e.g., pods) with labels (version:v3).\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"Name of the subset. The service name and the subset name can be used for traffic splitting in a route rule.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            trafficPolicy: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.TrafficPolicy\",\n            },\n            labels: {\n              description:\n                \"Labels apply a filter over the endpoints of a service in the service registry. See route rules for examples of usage.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1beta1.LoadBalancerSettings\": {\n          description:\n            \"Load balancing policies to apply for a specific destination. See Envoy's load balancing [documentation](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/load_balancing) for more details.\",\n          type: \"object\",\n          properties: {\n            localityLbSetting: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.LocalityLoadBalancerSetting\",\n            },\n          },\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"simple\"],\n                    properties: {\n                      simple: {\n                        $ref:\n                          \"#/components/schemas/istio.networking.v1beta1.LoadBalancerSettings.SimpleLB\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"consistentHash\"],\n                    properties: {\n                      consistentHash: {\n                        $ref:\n                          \"#/components/schemas/istio.networking.v1beta1.LoadBalancerSettings.ConsistentHashLB\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"simple\"],\n              properties: {\n                simple: {\n                  $ref:\n                    \"#/components/schemas/istio.networking.v1beta1.LoadBalancerSettings.SimpleLB\",\n                },\n              },\n            },\n            {\n              required: [\"consistentHash\"],\n              properties: {\n                consistentHash: {\n                  $ref:\n                    \"#/components/schemas/istio.networking.v1beta1.LoadBalancerSettings.ConsistentHashLB\",\n                },\n              },\n            },\n          ],\n        },\n        \"istio.networking.v1beta1.ConnectionPoolSettings\": {\n          description:\n            \"Connection pool settings for an upstream host. The settings apply to each individual host in the upstream service. See Envoy's [circuit breaker](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/circuit_breaking) for more details. Connection pool settings can be applied at the TCP level as well as at HTTP level.\",\n          type: \"object\",\n          properties: {\n            tcp: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ConnectionPoolSettings.TCPSettings\",\n            },\n            http: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ConnectionPoolSettings.HTTPSettings\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.OutlierDetection\": {\n          description:\n            \"A Circuit breaker implementation that tracks the status of each individual host in the upstream service. Applicable to both HTTP and TCP services. For HTTP services, hosts that continually return 5xx errors for API calls are ejected from the pool for a pre-defined period of time. For TCP services, connection timeouts or connection failures to a given host counts as an error when measuring the consecutive errors metric. See Envoy's [outlier detection](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/outlier) for more details.\",\n          type: \"object\",\n          properties: {\n            interval: {\n              description:\n                \"Time interval between ejection sweep analysis. format: 1h/1m/1s/1ms. MUST BE \\u003e=1ms. Default is 10s.\",\n              type: \"string\",\n            },\n            consecutiveErrors: {\n              description:\n                \"Number of errors before a host is ejected from the connection pool. Defaults to 5. When the upstream host is accessed over HTTP, a 502, 503, or 504 return code qualifies as an error. When the upstream host is accessed over an opaque TCP connection, connect timeouts and connection error/failure events qualify as an error. $hide_from_docs\",\n              type: \"integer\",\n              format: \"int32\",\n              deprecated: true,\n            },\n            consecutiveGatewayErrors: {\n              description:\n                \"Number of gateway errors before a host is ejected from the connection pool. When the upstream host is accessed over HTTP, a 502, 503, or 504 return code qualifies as a gateway error. When the upstream host is accessed over an opaque TCP connection, connect timeouts and connection error/failure events qualify as a gateway error. This feature is disabled by default or when set to the value 0.\",\n              type: \"integer\",\n              nullable: true,\n            },\n            consecutive5xxErrors: {\n              description:\n                \"Number of 5xx errors before a host is ejected from the connection pool. When the upstream host is accessed over an opaque TCP connection, connect timeouts, connection error/failure and request failure events qualify as a 5xx error. This feature defaults to 5 but can be disabled by setting the value to 0.\",\n              type: \"integer\",\n              nullable: true,\n            },\n            baseEjectionTime: {\n              description:\n                \"Minimum ejection duration. A host will remain ejected for a period equal to the product of minimum ejection duration and the number of times the host has been ejected. This technique allows the system to automatically increase the ejection period for unhealthy upstream servers. format: 1h/1m/1s/1ms. MUST BE \\u003e=1ms. Default is 30s.\",\n              type: \"string\",\n            },\n            maxEjectionPercent: {\n              description:\n                \"Maximum % of hosts in the load balancing pool for the upstream service that can be ejected. Defaults to 10%.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            minHealthPercent: {\n              description:\n                \"Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode. When the percentage of healthy hosts in the load balancing pool drops below this threshold, outlier detection will be disabled and the proxy will load balance across all hosts in the pool (healthy and unhealthy). The threshold can be disabled by setting it to 0%. The default is 0% as it's not typically applicable in k8s environments with few pods per service.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.ClientTLSSettings\": {\n          description:\n            \"SSL/TLS related settings for upstream connections. See Envoy's [TLS context](https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/auth/cert.proto.html) for more details. These settings are common to both HTTP and TCP upstreams.\",\n          type: \"object\",\n          properties: {\n            mode: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ClientTLSSettings.TLSmode\",\n            },\n            clientCertificate: {\n              description:\n                \"REQUIRED if mode is `MUTUAL`. The path to the file holding the client-side TLS certificate to use. Should be empty if mode is `ISTIO_MUTUAL`.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            privateKey: {\n              description:\n                \"REQUIRED if mode is `MUTUAL`. The path to the file holding the client's private key. Should be empty if mode is `ISTIO_MUTUAL`.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            caCertificates: {\n              description:\n                \"OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate. If omitted, the proxy will not verify the server's certificate. Should be empty if mode is `ISTIO_MUTUAL`.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            credentialName: {\n              description:\n                \"The name of the secret that holds the TLS certs for the client including the CA certificates. Applicable only on Kubernetes. Secret must exist in the same namespace with the proxy using the certificates. The secret (of type `generic`)should contain the following keys and values: `key: \\u003cprivateKey\\u003e`, `cert: \\u003cserverCert\\u003e`, `cacert: \\u003cCACertificate\\u003e`. Secret of type tls for client certificates along with ca.crt key for CA certificates is also supported. Only one of client certificates and CA certificate or credentialName can be specified.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            subjectAltNames: {\n              description:\n                \"A list of alternate names to verify the subject identity in the certificate. If specified, the proxy will verify that the server certificate's subject alt name matches one of the specified values. If specified, this list overrides the value of subject_alt_names from the ServiceEntry.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            sni: {\n              description:\n                \"SNI string to present to the server during TLS handshake.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.TrafficPolicy.PortTrafficPolicy\": {\n          description:\n            \"Traffic policies that apply to specific ports of the service\",\n          type: \"object\",\n          properties: {\n            loadBalancer: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.LoadBalancerSettings\",\n            },\n            connectionPool: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ConnectionPoolSettings\",\n            },\n            outlierDetection: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.OutlierDetection\",\n            },\n            tls: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ClientTLSSettings\",\n            },\n            port: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.PortSelector\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.PortSelector\": {\n          description:\n            \"PortSelector specifies the number of a port to be used for matching or selection for final routing.\",\n          type: \"object\",\n          properties: {\n            number: {\n              description: \"Valid port number\",\n              type: \"integer\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.LocalityLoadBalancerSetting\": {\n          description:\n            \"Locality-weighted load balancing allows administrators to control the distribution of traffic to endpoints based on the localities of where the traffic originates and where it will terminate. These localities are specified using arbitrary labels that designate a hierarchy of localities in {region}/{zone}/{sub-zone} form. For additional detail refer to [Locality Weight](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/locality_weight) The following example shows how to setup locality weights mesh-wide.\",\n          type: \"object\",\n          properties: {\n            distribute: {\n              description:\n                \"Optional: only one of distribute or failover can be set. Explicitly specify loadbalancing weight across different zones and geographical locations. Refer to [Locality weighted load balancing](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/locality_weight) If empty, the locality weight is set according to the endpoints number within it.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1beta1.LocalityLoadBalancerSetting.Distribute\",\n              },\n            },\n            failover: {\n              description:\n                \"Optional: only failover or distribute can be set. Explicitly specify the region traffic will land on when endpoints in local region becomes unhealthy. Should be used together with OutlierDetection to detect unhealthy endpoints. Note: if no OutlierDetection specified, this will not take effect.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1beta1.LocalityLoadBalancerSetting.Failover\",\n              },\n            },\n            enabled: {\n              description:\n                \"enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety. e.g. true means that turn on locality load balancing for this DestinationRule no matter what mesh wide settings is.\",\n              type: \"boolean\",\n              nullable: true,\n            },\n          },\n        },\n        \"istio.networking.v1beta1.LoadBalancerSettings.SimpleLB\": {\n          description:\n            \"Standard load balancing algorithms that require no tuning.\",\n          type: \"string\",\n          enum: [\"ROUND_ROBIN\", \"LEAST_CONN\", \"RANDOM\", \"PASSTHROUGH\"],\n        },\n        \"istio.networking.v1beta1.LoadBalancerSettings.ConsistentHashLB\": {\n          description:\n            \"Consistent Hash-based load balancing can be used to provide soft session affinity based on HTTP headers, cookies or other properties. This load balancing policy is applicable only for HTTP connections. The affinity to a particular destination host will be lost when one or more hosts are added/removed from the destination service.\",\n          type: \"object\",\n          properties: {\n            minimumRingSize: {\n              description:\n                \"The minimum number of virtual nodes to use for the hash ring. Defaults to 1024. Larger ring sizes result in more granular load distributions. If the number of hosts in the load balancing pool is larger than the ring size, each host will be assigned a single virtual node.\",\n              type: \"integer\",\n            },\n          },\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"httpHeaderName\"],\n                    properties: {\n                      httpHeaderName: {\n                        description: \"Hash based on a specific HTTP header.\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"httpCookie\"],\n                    properties: {\n                      httpCookie: {\n                        $ref:\n                          \"#/components/schemas/istio.networking.v1beta1.LoadBalancerSettings.ConsistentHashLB.HTTPCookie\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"useSourceIp\"],\n                    properties: {\n                      useSourceIp: {\n                        description: \"Hash based on the source IP address.\",\n                        type: \"boolean\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"httpQueryParameterName\"],\n                    properties: {\n                      httpQueryParameterName: {\n                        description:\n                          \"Hash based on a specific HTTP query parameter.\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"httpHeaderName\"],\n              properties: {\n                httpHeaderName: {\n                  description: \"Hash based on a specific HTTP header.\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"httpCookie\"],\n              properties: {\n                httpCookie: {\n                  $ref:\n                    \"#/components/schemas/istio.networking.v1beta1.LoadBalancerSettings.ConsistentHashLB.HTTPCookie\",\n                },\n              },\n            },\n            {\n              required: [\"useSourceIp\"],\n              properties: {\n                useSourceIp: {\n                  description: \"Hash based on the source IP address.\",\n                  type: \"boolean\",\n                },\n              },\n            },\n            {\n              required: [\"httpQueryParameterName\"],\n              properties: {\n                httpQueryParameterName: {\n                  description: \"Hash based on a specific HTTP query parameter.\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n          ],\n        },\n        \"istio.networking.v1beta1.LoadBalancerSettings.ConsistentHashLB.HTTPCookie\": {\n          description:\n            \"Describes a HTTP cookie that will be used as the hash key for the Consistent Hash load balancer. If the cookie is not present, it will be generated.\",\n          type: \"object\",\n          properties: {\n            path: {\n              description: \"Path to set for the cookie.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            name: {\n              description: \"Name of the cookie.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            ttl: {\n              description: \"Lifetime of the cookie.\",\n              type: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.ConnectionPoolSettings.TCPSettings\": {\n          description:\n            \"Settings common to both HTTP and TCP upstream connections.\",\n          type: \"object\",\n          properties: {\n            maxConnections: {\n              description:\n                \"Maximum number of HTTP1 /TCP connections to a destination host. Default 2^32-1.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            connectTimeout: {\n              description: \"TCP connection timeout.\",\n              type: \"string\",\n            },\n            tcpKeepalive: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ConnectionPoolSettings.TCPSettings.TcpKeepalive\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.ConnectionPoolSettings.HTTPSettings\": {\n          description: \"Settings applicable to HTTP1.1/HTTP2/GRPC connections.\",\n          type: \"object\",\n          properties: {\n            http1MaxPendingRequests: {\n              description:\n                \"Maximum number of pending HTTP requests to a destination. Default 2^32-1.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            http2MaxRequests: {\n              description:\n                \"Maximum number of requests to a backend. Default 2^32-1.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            maxRequestsPerConnection: {\n              description:\n                'Maximum number of requests per connection to a backend. Setting this parameter to 1 disables keep alive. Default 0, meaning \"unlimited\", up to 2^29.',\n              type: \"integer\",\n              format: \"int32\",\n            },\n            maxRetries: {\n              description:\n                \"Maximum number of retries that can be outstanding to all hosts in a cluster at a given time. Defaults to 2^32-1.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            idleTimeout: {\n              description:\n                \"The idle timeout for upstream connection pool connections. The idle timeout is defined as the period in which there are no active requests. If not set, the default is 1 hour. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. Applies to both HTTP1.1 and HTTP2 connections.\",\n              type: \"string\",\n            },\n            h2UpgradePolicy: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1beta1.ConnectionPoolSettings.HTTPSettings.H2UpgradePolicy\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.ConnectionPoolSettings.TCPSettings.TcpKeepalive\": {\n          description: \"TCP keepalive.\",\n          type: \"object\",\n          properties: {\n            time: {\n              description:\n                \"The time duration a connection needs to be idle before keep-alive probes start being sent. Default is to use the OS level configuration (unless overridden, Linux defaults to 7200s (ie 2 hours.)\",\n              type: \"string\",\n            },\n            probes: {\n              description:\n                \"Maximum number of keepalive probes to send without response before deciding the connection is dead. Default is to use the OS level configuration (unless overridden, Linux defaults to 9.)\",\n              type: \"integer\",\n            },\n            interval: {\n              description:\n                \"The time duration between keep-alive probes. Default is to use the OS level configuration (unless overridden, Linux defaults to 75s.)\",\n              type: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1beta1.ConnectionPoolSettings.HTTPSettings.H2UpgradePolicy\": {\n          description: \"Policy for upgrading http1.1 connections to http2.\",\n          type: \"string\",\n          enum: [\"DEFAULT\", \"DO_NOT_UPGRADE\", \"UPGRADE\"],\n        },\n        \"istio.networking.v1beta1.ClientTLSSettings.TLSmode\": {\n          description: \"TLS connection mode\",\n          type: \"string\",\n          enum: [\"DISABLE\", \"SIMPLE\", \"MUTUAL\", \"ISTIO_MUTUAL\"],\n        },\n        \"istio.networking.v1beta1.LocalityLoadBalancerSetting.Distribute\": {\n          description:\n            \"Describes how traffic originating in the 'from' zone or sub-zone is distributed over a set of 'to' zones. Syntax for specifying a zone is {region}/{zone}/{sub-zone} and terminal wildcards are allowed on any segment of the specification. Examples: * - matches all localities us-west/* - all zones and sub-zones within the us-west region us-west/zone-1/* - all sub-zones within us-west/zone-1\",\n          type: \"object\",\n          properties: {\n            from: {\n              description:\n                \"Originating locality, '/' separated, e.g. 'region/zone/sub_zone'.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            to: {\n              description:\n                \"Map of upstream localities to traffic distribution weights. The sum of all weights should be == 100. Any locality not assigned a weight will receive no traffic.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"integer\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1beta1.LocalityLoadBalancerSetting.Failover\": {\n          description:\n            \"Specify the traffic failover policy across regions. Since zone and sub-zone failover is supported by default this only needs to be specified for regions when the operator needs to constrain traffic failover so that the default behavior of failing over to any endpoint globally does not apply. This is useful when failing over traffic across regions would not improve service health or may need to be restricted for other reasons like regulatory controls.\",\n          type: \"object\",\n          properties: {\n            from: {\n              description: \"Originating region.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            to: {\n              description:\n                \"Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Definition of a workload selector.\",\n      version: \"v1beta1\",\n    },\n    components: {\n      schemas: {\n        \"istio.type.v1beta1.WorkloadSelector\": {\n          description:\n            \"WorkloadSelector specifies the criteria used to determine if a policy can be applied to a proxy. The matching criteria includes the metadata associated with a proxy, workload instance info such as labels attached to the pod/VM, or any other info that the proxy provides to Istio during the initial handshake. If multiple conditions are specified, all conditions need to match in order for the workload instance to be selected. Currently, only label based selection mechanism is supported.\",\n          type: \"object\",\n          properties: {\n            matchLabels: {\n              description:\n                \"One or more labels that indicate a specific set of pods/VMs on which a policy should be applied. The scope of label search is restricted to the configuration namespace in which the resource is present.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Configuration affecting the service mesh as a whole.\",\n      version: \"v1alpha1\",\n    },\n    components: {\n      schemas: {\n        \"istio.mesh.v1alpha1.MeshConfig\": {\n          description:\n            \"MeshConfig defines mesh-wide variables shared by all Envoy instances in the Istio service mesh.\",\n          type: \"object\",\n          properties: {\n            localityLbSetting: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.LocalityLoadBalancerSetting\",\n            },\n            connectTimeout: {\n              description:\n                \"Connection timeout used by Envoy. (MUST BE \\u003e=1ms)\",\n              type: \"string\",\n            },\n            tcpKeepalive: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive\",\n            },\n            h2UpgradePolicy: {\n              $ref:\n                \"#/components/schemas/istio.mesh.v1alpha1.MeshConfig.H2UpgradePolicy\",\n            },\n            outboundTrafficPolicy: {\n              $ref:\n                \"#/components/schemas/istio.mesh.v1alpha1.MeshConfig.OutboundTrafficPolicy\",\n            },\n            mixerCheckServer: {\n              description:\n                \"Address of the server that will be used by the proxies for policy check calls. By using different names for mixerCheckServer and mixerReportServer, it is possible to have one set of Mixer servers handle policy check calls while another set of Mixer servers handle telemetry calls.\",\n              type: \"string\",\n              format: \"string\",\n              deprecated: true,\n            },\n            mixerReportServer: {\n              description:\n                \"Address of the server that will be used by the proxies for policy report calls.\",\n              type: \"string\",\n              format: \"string\",\n              deprecated: true,\n            },\n            disablePolicyChecks: {\n              description:\n                \"Disable policy checks by the Mixer service. Default is false, i.e. Mixer policy check is enabled by default.\",\n              type: \"boolean\",\n              deprecated: true,\n            },\n            disableMixerHttpReports: {\n              description:\n                \"Disable telemetry reporting by the Mixer service for HTTP traffic. Default is false (telemetry reporting via Mixer is enabled). This option provides a transition path for Istio extensibility v2.\",\n              type: \"boolean\",\n              deprecated: true,\n            },\n            policyCheckFailOpen: {\n              description:\n                \"Allow all traffic in cases when the Mixer policy service cannot be reached. Default is false which means the traffic is denied when the client is unable to connect to Mixer.\",\n              type: \"boolean\",\n              deprecated: true,\n            },\n            sidecarToTelemetrySessionAffinity: {\n              description:\n                \"Enable session affinity for Envoy Mixer reports so that calls from a proxy will always target the same Mixer instance.\",\n              type: \"boolean\",\n              deprecated: true,\n            },\n            proxyListenPort: {\n              description:\n                \"Port on which Envoy should listen for incoming connections from other services.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            proxyHttpPort: {\n              description:\n                \"Port on which Envoy should listen for HTTP PROXY requests if set.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            protocolDetectionTimeout: {\n              description:\n                \"Automatic protocol detection uses a set of heuristics to determine whether the connection is using TLS or not (on the server side), as well as the application protocol being used (e.g., http vs tcp). These heuristics rely on the client sending the first bits of data. For server first protocols like MySQL, MongoDB, etc., Envoy will timeout on the protocol detection after the specified period, defaulting to non mTLS plain TCP traffic. Set this field to tweak the period that Envoy will wait for the client to send the first bits of data. (MUST BE \\u003e=1ms or 0s to disable)\",\n              type: \"string\",\n            },\n            ingressClass: {\n              description:\n                'Class of ingress resources to be processed by Istio ingress controller. This corresponds to the value of \"kubernetes.io/ingress.class\" annotation.',\n              type: \"string\",\n              format: \"string\",\n            },\n            ingressService: {\n              description:\n                \"Name of the Kubernetes service used for the istio ingress controller.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            ingressControllerMode: {\n              $ref:\n                \"#/components/schemas/istio.mesh.v1alpha1.MeshConfig.IngressControllerMode\",\n            },\n            ingressSelector: {\n              description:\n                \"Defines which gateway deployment to use as the Ingress controller. This field corresponds to the Gateway.selector field, and will be set as `istio: INGRESS_SELECTOR`. By default, `ingressgateway` is used, which will select the default IngressGateway as it has the `istio: ingressgateway` labels. It is recommended that this is the same value as ingress_service.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            authPolicy: {\n              $ref:\n                \"#/components/schemas/istio.mesh.v1alpha1.MeshConfig.AuthPolicy\",\n              deprecated: true,\n            },\n            rdsRefreshDelay: {\n              type: \"string\",\n              deprecated: true,\n            },\n            enableTracing: {\n              description:\n                \"Flag to control generation of trace spans and request IDs. Requires a trace span collector defined in the proxy configuration.\",\n              type: \"boolean\",\n            },\n            accessLogFile: {\n              description:\n                \"File address for the proxy access log (e.g. /dev/stdout). Empty value disables access logging.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            accessLogFormat: {\n              description:\n                \"Format for the proxy access log Empty value results in proxy's default access log format\",\n              type: \"string\",\n              format: \"string\",\n            },\n            accessLogEncoding: {\n              $ref:\n                \"#/components/schemas/istio.mesh.v1alpha1.MeshConfig.AccessLogEncoding\",\n            },\n            enableEnvoyAccessLogService: {\n              description:\n                \"This flag enables Envoy's gRPC Access Log Service. See [Access Log Service](https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/accesslog/v2/als.proto) for details about Envoy's gRPC Access Log Service API.\",\n              type: \"boolean\",\n            },\n            defaultConfig: {\n              $ref: \"#/components/schemas/istio.mesh.v1alpha1.ProxyConfig\",\n            },\n            mixerAddress: {\n              type: \"string\",\n              format: \"string\",\n              deprecated: true,\n            },\n            enableClientSidePolicyCheck: {\n              description: \"Enables client side policy checks.\",\n              type: \"boolean\",\n            },\n            sdsUdsPath: {\n              description:\n                \"Unix Domain Socket through which Envoy communicates with NodeAgent SDS to get key/cert for mTLS. Use secret-mount files instead of SDS if set to empty. @deprecated - istio agent will detect and send the path to envoy.\",\n              type: \"string\",\n              format: \"string\",\n              deprecated: true,\n            },\n            sdsRefreshDelay: {\n              type: \"string\",\n              deprecated: true,\n            },\n            configSources: {\n              description:\n                \"ConfigSource describes a source of configuration data for networking rules, and other Istio configuration artifacts. Multiple data sources can be configured for a single control plane.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.mesh.v1alpha1.ConfigSource\",\n              },\n            },\n            enableAutoMtls: {\n              description:\n                \"This flag is used to enable mutual TLS automatically for service to service communication within the mesh, default true. If set to true, and a given service does not have a corresponding DestinationRule configured, or its DestinationRule does not have ClientTLSSettings specified, Istio configures client side TLS configuration appropriately. More specifically, If the upstream authentication policy is in STRICT mode, use Istio provisioned certificate for mutual TLS to connect to upstream. If upstream service is in plain text mode, use plain text. If the upstream authentication policy is in PERMISSIVE mode, Istio configures clients to use mutual TLS when server sides are capable of accepting mutual TLS traffic. If service DestinationRule exists and has ClientTLSSettings specified, that is always used instead.\",\n              type: \"boolean\",\n              nullable: true,\n            },\n            enableSdsTokenMount: {\n              description:\n                \"This flag is used by secret discovery service(SDS). If set to true ([prerequisite](https://kubernetes.io/docs/concepts/storage/volumes/#projected)), Istio will inject volumes mount for Kubernetes service account trustworthy JWT(which is available with Kubernetes 1.12 or higher), so that the Kubernetes API server mounts Kubernetes service account trustworthy JWT to the Envoy container, which will be used to request key/cert eventually. This isn't supported for non-Kubernetes cases.\",\n              type: \"boolean\",\n            },\n            sdsUseK8sSaJwt: {\n              description:\n                \"This flag is used by secret discovery service(SDS). If set to true, Envoy will fetch a normal Kubernetes service account JWT from '/var/run/secrets/kubernetes.io/serviceaccount/token' (https://kubernetes.io/docs/tasks/access-application-cluster/access-cluster/#accessing-the-api-from-a-pod) and pass to sds server, which will be used to request key/cert eventually. If both enable_sds_token_mount and sds_use_k8s_sa_jwt are set to true, enable_sds_token_mount(trustworthy jwt) takes precedence. This isn't supported for non-k8s case.\",\n              type: \"boolean\",\n            },\n            trustDomain: {\n              description:\n                \"The trust domain corresponds to the trust root of a system. Refer to [SPIFFE-ID](https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE-ID.md#21-trust-domain)\",\n              type: \"string\",\n              format: \"string\",\n            },\n            trustDomainAliases: {\n              description:\n                'The trust domain aliases represent the aliases of `trust_domain`. For example, if we have ```yaml trustDomain: td1 trustDomainAliases: [\"td2\", \"td3\"] ``` Any service with the identity `td1/ns/foo/sa/a-service-account`, `td2/ns/foo/sa/a-service-account`, or `td3/ns/foo/sa/a-service-account` will be treated the same in the Istio mesh.',\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            defaultServiceExportTo: {\n              description:\n                \"The default value for the ServiceEntry.export_to field and services imported through container registry integrations, e.g. this applies to Kubernetes Service resources. The value is a list of namespace names and reserved namespace aliases. The allowed namespace aliases are: * - All Namespaces . - Current Namespace ~ - No Namespace\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            defaultVirtualServiceExportTo: {\n              description:\n                \"The default value for the VirtualService.export_to field. Has the same syntax as 'default_service_export_to'.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            defaultDestinationRuleExportTo: {\n              description:\n                \"The default value for the DestinationRule.export_to field. Has the same syntax as 'default_service_export_to'.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            rootNamespace: {\n              description:\n                \"The namespace to treat as the administrative root namespace for Istio configuration. When processing a leaf namespace Istio will search for declarations in that namespace first and if none are found it will search in the root namespace. Any matching declaration found in the root namespace is processed as if it were declared in the leaf namespace.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            dnsRefreshRate: {\n              description:\n                \"Configures DNS refresh rate for Envoy clusters of type STRICT_DNS\",\n              type: \"string\",\n            },\n            disableReportBatch: {\n              description: \"The flag to disable report batch.\",\n              type: \"boolean\",\n              deprecated: true,\n            },\n            reportBatchMaxEntries: {\n              description:\n                \"When disable_report_batch is false, this value specifies the maximum number of requests that are batched in report. If left unspecified, the default value of report_batch_max_entries == 0 will use the hardcoded defaults of istio::mixerclient::ReportOptions.\",\n              type: \"integer\",\n              deprecated: true,\n            },\n            reportBatchMaxTime: {\n              description:\n                \"When disable_report_batch is false, this value specifies the maximum elapsed time a batched report will be sent after a user request is processed. If left unspecified, the default report_batch_max_time == 0 will use the hardcoded defaults of istio::mixerclient::ReportOptions.\",\n              type: \"string\",\n              deprecated: true,\n            },\n            inboundClusterStatName: {\n              description:\n                \"Name to be used while emitting statistics for inbound clusters. The same pattern is used while computing stat prefix for network filters like TCP and Redis. By default, Istio emits statistics with the pattern `inbound|\\u003cport\\u003e|\\u003cport-name\\u003e|\\u003cservice-FQDN\\u003e`. For example `inbound|7443|grpc-reviews|reviews.prod.svc.cluster.local`. This can be used to override that pattern.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            outboundClusterStatName: {\n              description:\n                \"Name to be used while emitting statistics for outbound clusters. The same pattern is used while computing stat prefix for network filters like TCP and Redis. By default, Istio emits statistics with the pattern `outbound|\\u003cport\\u003e|\\u003csubsetname\\u003e|\\u003cservice-FQDN\\u003e`. For example `outbound|8080|v2|reviews.prod.svc.cluster.local`. This can be used to override that pattern.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            certificates: {\n              description: \"Configure the provision of certificates.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.mesh.v1alpha1.Certificate\",\n              },\n            },\n            thriftConfig: {\n              $ref:\n                \"#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ThriftConfig\",\n            },\n            serviceSettings: {\n              description: \"Settings to be applied to select services.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ServiceSettings\",\n              },\n            },\n            enablePrometheusMerge: {\n              description:\n                'If enabled, Istio agent will merge metrics exposed by the application with metrics from Envoy and Istio agent. The sidecar injection will replace `prometheus.io` annotations present on the pod and redirect them towards Istio agent, which will then merge metrics of from the application with Istio metrics. This relies on the annotations `prometheus.io/scrape`, `prometheus.io/port`, and `prometheus.io/path` annotations. If you are running a separately managed Envoy with an Istio sidecar, this may cause issues, as the metrics will collide. In this case, it is recommended to disable aggregation on that deployment with the `prometheus.istio.io/merge-metrics: \"false\"` annotation. If not specified, this will be enabled by default.',\n              type: \"boolean\",\n              nullable: true,\n            },\n          },\n        },\n        \"istio.mesh.v1alpha1.MeshConfig.IngressControllerMode\": {\n          type: \"string\",\n          enum: [\"UNSPECIFIED\", \"OFF\", \"DEFAULT\", \"STRICT\"],\n        },\n        \"istio.mesh.v1alpha1.MeshConfig.AuthPolicy\": {\n          type: \"string\",\n          enum: [\"NONE\", \"MUTUAL_TLS\"],\n        },\n        \"istio.mesh.v1alpha1.MeshConfig.AccessLogEncoding\": {\n          type: \"string\",\n          enum: [\"TEXT\", \"JSON\"],\n        },\n        \"istio.mesh.v1alpha1.ProxyConfig\": {\n          description:\n            \"ProxyConfig defines variables for individual Envoy instances.\",\n          type: \"object\",\n          properties: {\n            configPath: {\n              description:\n                \"Path to the generated configuration file directory. Proxy agent generates the actual configuration and stores it in this directory.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            binaryPath: {\n              description: \"Path to the proxy binary\",\n              type: \"string\",\n              format: \"string\",\n            },\n            serviceCluster: {\n              description:\n                \"Service cluster defines the name for the service_cluster that is shared by all Envoy instances. This setting corresponds to _--service-cluster_ flag in Envoy. In a typical Envoy deployment, the _service-cluster_ flag is used to identify the caller, for source-based routing scenarios.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            drainDuration: {\n              description:\n                \"The time in seconds that Envoy will drain connections during a hot restart. MUST be \\u003e=1s (e.g., _1s/1m/1h_)\",\n              type: \"string\",\n            },\n            parentShutdownDuration: {\n              description:\n                \"The time in seconds that Envoy will wait before shutting down the parent process during a hot restart. MUST be \\u003e=1s (e.g., _1s/1m/1h_). MUST BE greater than _drain_duration_ parameter.\",\n              type: \"string\",\n            },\n            discoveryAddress: {\n              description:\n                \"Address of the discovery service exposing xDS with mTLS connection. The inject configuration may override this value.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            discoveryRefreshDelay: {\n              type: \"string\",\n              deprecated: true,\n            },\n            zipkinAddress: {\n              description:\n                \"Address of the Zipkin service (e.g. _zipkin:9411_). DEPRECATED: Use [tracing][istio.mesh.v1alpha1.ProxyConfig.tracing] instead.\",\n              type: \"string\",\n              format: \"string\",\n              deprecated: true,\n            },\n            statsdUdpAddress: {\n              description:\n                \"IP Address and Port of a statsd UDP listener (e.g. _10.75.241.127:9125_).\",\n              type: \"string\",\n              format: \"string\",\n            },\n            envoyMetricsServiceAddress: {\n              type: \"string\",\n              format: \"string\",\n              deprecated: true,\n            },\n            proxyAdminPort: {\n              description:\n                \"Port on which Envoy should listen for administrative commands.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            availabilityZone: {\n              type: \"string\",\n              format: \"string\",\n              deprecated: true,\n            },\n            controlPlaneAuthPolicy: {\n              $ref:\n                \"#/components/schemas/istio.mesh.v1alpha1.AuthenticationPolicy\",\n            },\n            customConfigFile: {\n              description:\n                \"File path of custom proxy configuration, currently used by proxies in front of Mixer and Pilot.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            statNameLength: {\n              description:\n                \"Maximum length of name field in Envoy's metrics. The length of the name field is determined by the length of a name field in a service and the set of labels that comprise a particular version of the service. The default value is set to 189 characters. Envoy's internal metrics take up 67 characters, for a total of 256 character name per metric. Increase the value of this field if you find that the metrics from Envoys are truncated.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            concurrency: {\n              description:\n                \"The number of worker threads to run. If unset, this will be automatically determined based on CPU requests/limits. If set to 0, all cores on the machine will be used.\",\n              type: \"integer\",\n              nullable: true,\n            },\n            proxyBootstrapTemplatePath: {\n              description: \"Path to the proxy bootstrap template file\",\n              type: \"string\",\n              format: \"string\",\n            },\n            interceptionMode: {\n              $ref:\n                \"#/components/schemas/istio.mesh.v1alpha1.ProxyConfig.InboundInterceptionMode\",\n            },\n            tracing: {\n              $ref: \"#/components/schemas/istio.mesh.v1alpha1.Tracing\",\n            },\n            sds: {\n              $ref: \"#/components/schemas/istio.mesh.v1alpha1.SDS\",\n            },\n            envoyAccessLogService: {\n              $ref: \"#/components/schemas/istio.mesh.v1alpha1.RemoteService\",\n            },\n            envoyMetricsService: {\n              $ref: \"#/components/schemas/istio.mesh.v1alpha1.RemoteService\",\n            },\n            proxyMetadata: {\n              description:\n                \"Additional env variables for the proxy. Names starting with ISTIO_META_ will be included in the generated bootstrap and sent to the XDS server.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            statusPort: {\n              description:\n                \"Port on which the agent should listen for administrative commands such as readiness probe.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            extraStatTags: {\n              description:\n                \"An additional list of tags to extract from the in-proxy Istio telemetry. These extra tags can be added by configuring the telemetry extension. Each additional tag needs to be present in this list. Extra tags emitted by the telemetry extensions must be listed here so that they can be processed and exposed as Prometheus metrics.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            gatewayTopology: {\n              $ref: \"#/components/schemas/istio.mesh.v1alpha1.Topology\",\n            },\n            terminationDrainDuration: {\n              description:\n                \"The amount of time allowed for connections to complete on proxy shutdown. On receiving SIGTERM or SIGINT, istio-agent tells the active Envoy to start draining, preventing any new connections and allowing existing connections to complete. It then sleeps for the termination_drain_duration and then kills any remaining active Envoy processes. If not set, a default of 5s will be applied.\",\n              type: \"string\",\n            },\n            meshId: {\n              description:\n                \"The unique identifier for the [service mesh](https://istio.io/latest/docs/reference/glossary/#service-mesh) All control planes running in the same service mesh should specify the same mesh ID. Mesh ID is used to label telemetry reports for cases where telemetry from multiple meshes is mixed together.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n          },\n        },\n        \"istio.mesh.v1alpha1.MeshConfig.OutboundTrafficPolicy\": {\n          type: \"object\",\n          properties: {\n            mode: {\n              $ref:\n                \"#/components/schemas/istio.mesh.v1alpha1.MeshConfig.OutboundTrafficPolicy.Mode\",\n            },\n          },\n        },\n        \"istio.mesh.v1alpha1.ConfigSource\": {\n          description:\n            \"ConfigSource describes information about a configuration store inside a mesh. A single control plane instance can interact with one or more data sources.\",\n          type: \"object\",\n          properties: {\n            address: {\n              description:\n                \"Address of the server implementing the Istio Mesh Configuration protocol (MCP). Can be IP address or a fully qualified DNS name. Use fs:/// to specify a file-based backend with absolute path to the directory.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            tlsSettings: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ClientTLSSettings\",\n            },\n            subscribedResources: {\n              description:\n                \"Describes the source of configuration, if nothing is specified default is MCP\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.mesh.v1alpha1.Resource\",\n              },\n            },\n          },\n        },\n        \"istio.mesh.v1alpha1.MeshConfig.H2UpgradePolicy\": {\n          description:\n            \"Default Policy for upgrading http1.1 connections to http2.\",\n          type: \"string\",\n          enum: [\"DO_NOT_UPGRADE\", \"UPGRADE\"],\n        },\n        \"istio.mesh.v1alpha1.Certificate\": {\n          description:\n            \"Certificate configures the provision of a certificate and its key. Example 1: key and cert stored in a secret { secretName: galley-cert secretNamespace: istio-system dnsNames: - galley.istio-system.svc - galley.mydomain.com } Example 2: key and cert stored in a directory { dnsNames: - pilot.istio-system - pilot.istio-system.svc - pilot.mydomain.com }\",\n          type: \"object\",\n          properties: {\n            secretName: {\n              description:\n                \"Name of the secret the certificate and its key will be stored into. If it is empty, it will not be stored into a secret. Instead, the certificate and its key will be stored into a hard-coded directory.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            dnsNames: {\n              description:\n                \"The DNS names for the certificate. A certificate may contain multiple DNS names.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.mesh.v1alpha1.MeshConfig.ThriftConfig\": {\n          type: \"object\",\n          properties: {\n            rateLimitUrl: {\n              description:\n                \"Specify thrift rate limit service URL. If pilot has thrift protocol support enabled, this will enable the rate limit service for destinations that have matching rate limit configurations.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            rateLimitTimeout: {\n              description:\n                \"Specify thrift rate limit service timeout, in milliseconds. Default is 50ms\",\n              type: \"string\",\n            },\n          },\n        },\n        \"istio.mesh.v1alpha1.MeshConfig.ServiceSettings\": {\n          description: \"Settings to be applied to select services.\",\n          type: \"object\",\n          properties: {\n            hosts: {\n              description:\n                \"The services to which the Settings should be applied. Services are selected using the hostname matching rules used by DestinationRule.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            settings: {\n              $ref:\n                \"#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ServiceSettings.Settings\",\n            },\n          },\n        },\n        \"istio.mesh.v1alpha1.MeshConfig.OutboundTrafficPolicy.Mode\": {\n          type: \"string\",\n          enum: [\"REGISTRY_ONLY\", \"ALLOW_ANY\"],\n        },\n        \"istio.mesh.v1alpha1.MeshConfig.ServiceSettings.Settings\": {\n          description: \"Settings for the selected services.\",\n          type: \"object\",\n          properties: {\n            clusterLocal: {\n              description:\n                \"If true, specifies that the client and service endpoints must reside in the same cluster. By default, in multi-cluster deployments, the Istio control plane assumes all service endpoints to be reachable from any client in any of the clusters which are part of the mesh. This configuration option limits the set of service endpoints visible to a client to be cluster scoped.\",\n              type: \"boolean\",\n            },\n          },\n        },\n        \"istio.mesh.v1alpha1.Resource\": {\n          description: \"Resource describes the source of configuration\",\n          type: \"string\",\n          enum: [\"SERVICE_REGISTRY\"],\n        },\n        \"istio.mesh.v1alpha1.Network\": {\n          description:\n            \"Network provides information about the endpoints in a routable L3 network. A single routable L3 network can have one or more service registries. Note that the network has no relation to the locality of the endpoint. The endpoint locality will be obtained from the service registry.\",\n          type: \"object\",\n          properties: {\n            endpoints: {\n              description:\n                \"The list of endpoints in the network (obtained through the constituent service registries or from CIDR ranges). All endpoints in the network are directly accessible to one another.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.mesh.v1alpha1.Network.NetworkEndpoints\",\n              },\n            },\n            gateways: {\n              description: \"Set of gateways associated with the network.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.mesh.v1alpha1.Network.IstioNetworkGateway\",\n              },\n            },\n          },\n        },\n        \"istio.mesh.v1alpha1.Network.NetworkEndpoints\": {\n          description:\n            \"NetworkEndpoints describes how the network associated with an endpoint should be inferred. An endpoint will be assigned to a network based on the following rules: 1. Implicitly: If the registry explicitly provides information about the network to which the endpoint belongs to. In some cases, its possible to indicate the network associated with the endpoint by adding the `ISTIO_META_NETWORK` environment variable to the sidecar.\",\n          type: \"object\",\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"fromCidr\"],\n                    properties: {\n                      fromCidr: {\n                        description:\n                          \"A CIDR range for the set of endpoints in this network. The CIDR ranges for endpoints from different networks must not overlap.\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"fromRegistry\"],\n                    properties: {\n                      fromRegistry: {\n                        description:\n                          \"Add all endpoints from the specified registry into this network. The names of the registries should correspond to the kubeconfig file name inside the secret that was used to configure the registry (Kubernetes multicluster) or supplied by MCP server.\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"fromCidr\"],\n              properties: {\n                fromCidr: {\n                  description:\n                    \"A CIDR range for the set of endpoints in this network. The CIDR ranges for endpoints from different networks must not overlap.\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"fromRegistry\"],\n              properties: {\n                fromRegistry: {\n                  description:\n                    \"Add all endpoints from the specified registry into this network. The names of the registries should correspond to the kubeconfig file name inside the secret that was used to configure the registry (Kubernetes multicluster) or supplied by MCP server.\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n          ],\n        },\n        \"istio.mesh.v1alpha1.Network.IstioNetworkGateway\": {\n          description:\n            \"The gateway associated with this network. Traffic from remote networks will arrive at the specified gateway:port. All incoming traffic must use mTLS.\",\n          type: \"object\",\n          properties: {\n            port: {\n              description: \"The port associated with the gateway.\",\n              type: \"integer\",\n            },\n            locality: {\n              description:\n                \"The locality associated with an explicitly specified gateway (i.e. ip)\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"registryServiceName\"],\n                    properties: {\n                      registryServiceName: {\n                        description:\n                          \"A fully qualified domain name of the gateway service. Pilot will lookup the service from the service registries in the network and obtain the endpoint IPs of the gateway from the service registry. Note that while the service name is a fully qualified domain name, it need not be resolvable outside the orchestration platform for the registry. e.g., this could be istio-ingressgateway.istio-system.svc.cluster.local.\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"address\"],\n                    properties: {\n                      address: {\n                        description:\n                          \"IP address or externally resolvable DNS address associated with the gateway.\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"registryServiceName\"],\n              properties: {\n                registryServiceName: {\n                  description:\n                    \"A fully qualified domain name of the gateway service. Pilot will lookup the service from the service registries in the network and obtain the endpoint IPs of the gateway from the service registry. Note that while the service name is a fully qualified domain name, it need not be resolvable outside the orchestration platform for the registry. e.g., this could be istio-ingressgateway.istio-system.svc.cluster.local.\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"address\"],\n              properties: {\n                address: {\n                  description:\n                    \"IP address or externally resolvable DNS address associated with the gateway.\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n          ],\n        },\n        \"istio.mesh.v1alpha1.MeshNetworks\": {\n          description:\n            \"MeshNetworks (config map) provides information about the set of networks inside a mesh and how to route to endpoints in each network. For example\",\n          type: \"object\",\n          properties: {\n            networks: {\n              description:\n                \"The set of networks inside this mesh. Each network should have a unique name and information about how to infer the endpoints in the network as well as the gateways associated with the network.\",\n              type: \"object\",\n              additionalProperties: {\n                $ref: \"#/components/schemas/istio.mesh.v1alpha1.Network\",\n              },\n            },\n          },\n        },\n        \"istio.mesh.v1alpha1.AuthenticationPolicy\": {\n          description:\n            \"AuthenticationPolicy defines authentication policy. It can be set for different scopes (mesh, service …), and the most narrow scope with non-INHERIT value will be used. Mesh policy cannot be INHERIT.\",\n          type: \"string\",\n          enum: [\"NONE\", \"MUTUAL_TLS\", \"INHERIT\"],\n        },\n        \"istio.mesh.v1alpha1.Tracing\": {\n          description:\n            \"Tracing defines configuration for the tracing performed by Envoy instances.\",\n          type: \"object\",\n          properties: {\n            tlsSettings: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ClientTLSSettings\",\n            },\n            customTags: {\n              description:\n                \"Configures the custom tags to be added to active span by all proxies (i.e. sidecars and gateways). The key represents the name of the tag. Ex: ```yaml custom_tags: new_tag_name: header: name: custom-http-header-name default_value: defaulted-value-from-custom-header ``` $hide_from_docs\",\n              type: \"object\",\n              additionalProperties: {\n                $ref:\n                  \"#/components/schemas/istio.mesh.v1alpha1.Tracing.CustomTag\",\n              },\n            },\n            maxPathTagLength: {\n              description:\n                \"Configures the maximum length of the request path to extract and include in the HttpUrl tag. Used to truncate length request paths to meet the needs of tracing backend. If not set, then a length of 256 will be used. $hide_from_docs\",\n              type: \"integer\",\n            },\n            sampling: {\n              description:\n                \"The percentage of requests (0.0 - 100.0) that will be randomly selected for trace generation, if not requested by the client or not forced. Default is 100. $hide_from_docs\",\n              type: \"number\",\n              format: \"double\",\n            },\n          },\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"zipkin\"],\n                    properties: {\n                      zipkin: {\n                        $ref:\n                          \"#/components/schemas/istio.mesh.v1alpha1.Tracing.Zipkin\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"lightstep\"],\n                    properties: {\n                      lightstep: {\n                        $ref:\n                          \"#/components/schemas/istio.mesh.v1alpha1.Tracing.Lightstep\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"datadog\"],\n                    properties: {\n                      datadog: {\n                        $ref:\n                          \"#/components/schemas/istio.mesh.v1alpha1.Tracing.Datadog\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"stackdriver\"],\n                    properties: {\n                      stackdriver: {\n                        $ref:\n                          \"#/components/schemas/istio.mesh.v1alpha1.Tracing.Stackdriver\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"zipkin\"],\n              properties: {\n                zipkin: {\n                  $ref:\n                    \"#/components/schemas/istio.mesh.v1alpha1.Tracing.Zipkin\",\n                },\n              },\n            },\n            {\n              required: [\"lightstep\"],\n              properties: {\n                lightstep: {\n                  $ref:\n                    \"#/components/schemas/istio.mesh.v1alpha1.Tracing.Lightstep\",\n                },\n              },\n            },\n            {\n              required: [\"datadog\"],\n              properties: {\n                datadog: {\n                  $ref:\n                    \"#/components/schemas/istio.mesh.v1alpha1.Tracing.Datadog\",\n                },\n              },\n            },\n            {\n              required: [\"stackdriver\"],\n              properties: {\n                stackdriver: {\n                  $ref:\n                    \"#/components/schemas/istio.mesh.v1alpha1.Tracing.Stackdriver\",\n                },\n              },\n            },\n          ],\n        },\n        \"istio.mesh.v1alpha1.Tracing.CustomTag\": {\n          description:\n            \"Configure custom tags that will be added to any active span. Tags can be generated via literals, environment variables or an incoming request header. $hide_from_docs\",\n          type: \"object\",\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"literal\"],\n                    properties: {\n                      literal: {\n                        $ref:\n                          \"#/components/schemas/istio.mesh.v1alpha1.Tracing.Literal\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"environment\"],\n                    properties: {\n                      environment: {\n                        $ref:\n                          \"#/components/schemas/istio.mesh.v1alpha1.Tracing.Environment\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"header\"],\n                    properties: {\n                      header: {\n                        $ref:\n                          \"#/components/schemas/istio.mesh.v1alpha1.Tracing.RequestHeader\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"literal\"],\n              properties: {\n                literal: {\n                  $ref:\n                    \"#/components/schemas/istio.mesh.v1alpha1.Tracing.Literal\",\n                },\n              },\n            },\n            {\n              required: [\"environment\"],\n              properties: {\n                environment: {\n                  $ref:\n                    \"#/components/schemas/istio.mesh.v1alpha1.Tracing.Environment\",\n                },\n              },\n            },\n            {\n              required: [\"header\"],\n              properties: {\n                header: {\n                  $ref:\n                    \"#/components/schemas/istio.mesh.v1alpha1.Tracing.RequestHeader\",\n                },\n              },\n            },\n          ],\n        },\n        \"istio.mesh.v1alpha1.Tracing.Zipkin\": {\n          description: \"Zipkin defines configuration for a Zipkin tracer.\",\n          type: \"object\",\n          properties: {\n            address: {\n              description:\n                \"Address of the Zipkin service (e.g. _zipkin:9411_).\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.mesh.v1alpha1.Tracing.Lightstep\": {\n          description: \"Defines configuration for a Lightstep tracer.\",\n          type: \"object\",\n          properties: {\n            address: {\n              description: \"Address of the Lightstep Satellite pool.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            accessToken: {\n              description: \"The Lightstep access token.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.mesh.v1alpha1.Tracing.Datadog\": {\n          description: \"Datadog defines configuration for a Datadog tracer.\",\n          type: \"object\",\n          properties: {\n            address: {\n              description: \"Address of the Datadog Agent.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.mesh.v1alpha1.Tracing.Stackdriver\": {\n          description:\n            \"Stackdriver defines configuration for a Stackdriver tracer. See [Opencensus trace config](https://github.com/census-instrumentation/opencensus-proto/blob/master/src/opencensus/proto/trace/v1/trace_config.proto) for details.\",\n          type: \"object\",\n          properties: {\n            debug: {\n              description:\n                \"debug enables trace output to stdout. $hide_from_docs\",\n              type: \"boolean\",\n            },\n            maxNumberOfAttributes: {\n              description:\n                \"The global default max number of attributes per span. default is 200. $hide_from_docs\",\n              type: \"integer\",\n              nullable: true,\n            },\n            maxNumberOfAnnotations: {\n              description:\n                \"The global default max number of annotation events per span. default is 200. $hide_from_docs\",\n              type: \"integer\",\n              nullable: true,\n            },\n            maxNumberOfMessageEvents: {\n              description:\n                \"The global default max number of message events per span. default is 200. $hide_from_docs\",\n              type: \"integer\",\n              nullable: true,\n            },\n          },\n        },\n        \"istio.mesh.v1alpha1.Tracing.Literal\": {\n          description:\n            \"Literal type represents a static value. $hide_from_docs\",\n          type: \"object\",\n          properties: {\n            value: {\n              description:\n                \"Static literal value used to populate the tag value.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.mesh.v1alpha1.Tracing.Environment\": {\n          description:\n            \"Environment is the proxy's environment variable to be used for populating the custom span tag. $hide_from_docs\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"Name of the environment variable used to populate the tag's value\",\n              type: \"string\",\n              format: \"string\",\n            },\n            defaultValue: {\n              description:\n                \"When the environment variable is not found, the tag's value will be populated with this default value if specified, otherwise the tag will not be populated.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.mesh.v1alpha1.Tracing.RequestHeader\": {\n          description:\n            \"RequestHeader is the HTTP request header which will be used to populate the span tag. A default value can be configured if the header does not exist. $hide_from_docs\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"HTTP header name used to obtain the value from to populate the tag value.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            defaultValue: {\n              description:\n                \"Default value to be used for the tag when the named HTTP header does not exist. The tag will be skipped if no default value is provided.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.mesh.v1alpha1.SDS\": {\n          description:\n            \"SDS defines secret discovery service(SDS) configuration to be used by the proxy. For workload, its values are set in sidecar injector(passed as arguments to istio-proxy container). For pilot/mixer, it's passed as arguments to istio-proxy container in pilot/mixer deployment yaml files directly.\",\n          type: \"object\",\n          properties: {\n            enabled: {\n              description: \"True if SDS is enabled.\",\n              type: \"boolean\",\n            },\n            k8sSaJwtPath: {\n              description: \"Path of k8s service account JWT path.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.mesh.v1alpha1.Topology\": {\n          description:\n            \"Topology describes the configuration for relative location of a proxy with respect to intermediate trusted proxies and the client. These settings control how the client attributes are retrieved from the incoming traffic by the gateway proxy and propagated to the upstream services in the cluster.\",\n          type: \"object\",\n          properties: {\n            numTrustedProxies: {\n              description:\n                \"Number of trusted proxies deployed in front of the Istio gateway proxy. When this option is set to value N greater than zero, the trusted client address is assumed to be the Nth address from the right end of the X-Forwarded-For (XFF) header from the incoming request. If the X-Forwarded-For (XFF) header is missing or has fewer than N addresses, the gateway proxy falls back to using the immediate downstream connection's source address as the trusted client address. Note that the gateway proxy will append the downstream connection's source address to the X-Forwarded-For (XFF) address and set the X-Envoy-External-Address header to the trusted client address before forwarding it to the upstream services in the cluster. The default value of num_trusted_proxies is 0. See [Envoy XFF] (https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#config-http-conn-man-headers-x-forwarded-for) header handling for more details.\",\n              type: \"integer\",\n            },\n            forwardClientCertDetails: {\n              $ref:\n                \"#/components/schemas/istio.mesh.v1alpha1.Topology.ForwardClientCertDetails\",\n            },\n          },\n        },\n        \"istio.mesh.v1alpha1.Topology.ForwardClientCertDetails\": {\n          description:\n            \"ForwardClientCertDetails controls how the x-forwarded-client-cert (XFCC) header is handled by the gateway proxy. See [Envoy XFCC](https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/filter/network/http_connection_manager/v2/http_connection_manager.proto#envoy-api-enum-config-filter-network-http-connection-manager-v2-httpconnectionmanager-forwardclientcertdetails) header handling for more details.\",\n          type: \"string\",\n          enum: [\n            \"UNDEFINED\",\n            \"SANITIZE\",\n            \"FORWARD_ONLY\",\n            \"APPEND_FORWARD\",\n            \"SANITIZE_SET\",\n            \"ALWAYS_FORWARD_ONLY\",\n          ],\n        },\n        \"istio.mesh.v1alpha1.ProxyConfig.InboundInterceptionMode\": {\n          description:\n            \"The mode used to redirect inbound traffic to Envoy. This setting has no effect on outbound traffic: iptables REDIRECT is always used for outbound connections.\",\n          type: \"string\",\n          enum: [\"REDIRECT\", \"TPROXY\"],\n        },\n        \"istio.mesh.v1alpha1.RemoteService\": {\n          type: \"object\",\n          properties: {\n            tcpKeepalive: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive\",\n            },\n            address: {\n              description:\n                \"Address of a remove service used for various purposes (access log receiver, metrics receiver, etc.). Can be IP address or a fully qualified DNS name.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            tlsSettings: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ClientTLSSettings\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.ClientTLSSettings\": {\n          description:\n            \"Use the tls_settings to specify the tls mode to use. If the remote service uses Istio mutual TLS and shares the root CA with Pilot, specify the TLS mode as `ISTIO_MUTUAL`.\",\n          type: \"object\",\n          properties: {\n            mode: {\n              $ref:\n                \"#/components/schemas/istio.networking.v1alpha3.ClientTLSSettings.TLSmode\",\n            },\n            clientCertificate: {\n              description:\n                \"REQUIRED if mode is `MUTUAL`. The path to the file holding the client-side TLS certificate to use. Should be empty if mode is `ISTIO_MUTUAL`.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            privateKey: {\n              description:\n                \"REQUIRED if mode is `MUTUAL`. The path to the file holding the client's private key. Should be empty if mode is `ISTIO_MUTUAL`.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            caCertificates: {\n              description:\n                \"OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate. If omitted, the proxy will not verify the server's certificate. Should be empty if mode is `ISTIO_MUTUAL`.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            credentialName: {\n              description:\n                \"The name of the secret that holds the TLS certs for the client including the CA certificates. Applicable only on Kubernetes. Secret must exist in the same namespace with the proxy using the certificates. The secret (of type `generic`)should contain the following keys and values: `key: \\u003cprivateKey\\u003e`, `cert: \\u003cserverCert\\u003e`, `cacert: \\u003cCACertificate\\u003e`. Secret of type tls for client certificates along with ca.crt key for CA certificates is also supported. Only one of client certificates and CA certificate or credentialName can be specified.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            subjectAltNames: {\n              description:\n                \"A list of alternate names to verify the subject identity in the certificate. If specified, the proxy will verify that the server certificate's subject alt name matches one of the specified values. If specified, this list overrides the value of subject_alt_names from the ServiceEntry.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            sni: {\n              description:\n                \"SNI string to present to the server during TLS handshake.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive\": {\n          description:\n            \"If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.\",\n          type: \"object\",\n          properties: {\n            time: {\n              description:\n                \"The time duration a connection needs to be idle before keep-alive probes start being sent. Default is to use the OS level configuration (unless overridden, Linux defaults to 7200s (ie 2 hours.)\",\n              type: \"string\",\n            },\n            probes: {\n              description:\n                \"Maximum number of keepalive probes to send without response before deciding the connection is dead. Default is to use the OS level configuration (unless overridden, Linux defaults to 9.)\",\n              type: \"integer\",\n            },\n            interval: {\n              description:\n                \"The time duration between keep-alive probes. Default is to use the OS level configuration (unless overridden, Linux defaults to 75s.)\",\n              type: \"string\",\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.LocalityLoadBalancerSetting\": {\n          description:\n            \"Locality based load balancing distribution or failover settings.\",\n          type: \"object\",\n          properties: {\n            distribute: {\n              description:\n                \"Optional: only one of distribute or failover can be set. Explicitly specify loadbalancing weight across different zones and geographical locations. Refer to [Locality weighted load balancing](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/locality_weight) If empty, the locality weight is set according to the endpoints number within it.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1alpha3.LocalityLoadBalancerSetting.Distribute\",\n              },\n            },\n            failover: {\n              description:\n                \"Optional: only failover or distribute can be set. Explicitly specify the region traffic will land on when endpoints in local region becomes unhealthy. Should be used together with OutlierDetection to detect unhealthy endpoints. Note: if no OutlierDetection specified, this will not take effect.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.networking.v1alpha3.LocalityLoadBalancerSetting.Failover\",\n              },\n            },\n            enabled: {\n              description:\n                \"enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety. e.g. true means that turn on locality load balancing for this DestinationRule no matter what mesh wide settings is.\",\n              type: \"boolean\",\n              nullable: true,\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.ClientTLSSettings.TLSmode\": {\n          description:\n            \"Indicates whether connections to this port should be secured using TLS. The value of this field determines how TLS is enforced.\",\n          type: \"string\",\n          enum: [\"DISABLE\", \"SIMPLE\", \"MUTUAL\", \"ISTIO_MUTUAL\"],\n        },\n        \"istio.networking.v1alpha3.LocalityLoadBalancerSetting.Distribute\": {\n          type: \"object\",\n          properties: {\n            from: {\n              description:\n                \"Originating locality, '/' separated, e.g. 'region/zone/sub_zone'.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            to: {\n              description:\n                \"Map of upstream localities to traffic distribution weights. The sum of all weights should be == 100. Any locality not assigned a weight will receive no traffic.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"integer\",\n              },\n            },\n          },\n        },\n        \"istio.networking.v1alpha3.LocalityLoadBalancerSetting.Failover\": {\n          type: \"object\",\n          properties: {\n            from: {\n              description: \"Originating region.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            to: {\n              description:\n                \"Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"\",\n      version: \"v1alpha1\",\n    },\n    components: {\n      schemas: {\n        \"istio.authentication.v1alpha1.StringMatch\": {\n          description:\n            \"Describes how to match a given string. Match is case-sensitive.\",\n          type: \"object\",\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"exact\"],\n                    properties: {\n                      exact: {\n                        description: \"exact string match.\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"prefix\"],\n                    properties: {\n                      prefix: {\n                        description: \"prefix-based match.\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"suffix\"],\n                    properties: {\n                      suffix: {\n                        description: \"suffix-based match.\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"regex\"],\n                    properties: {\n                      regex: {\n                        description:\n                          \"RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"exact\"],\n              properties: {\n                exact: {\n                  description: \"exact string match.\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"prefix\"],\n              properties: {\n                prefix: {\n                  description: \"prefix-based match.\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"suffix\"],\n              properties: {\n                suffix: {\n                  description: \"suffix-based match.\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"regex\"],\n              properties: {\n                regex: {\n                  description:\n                    \"RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n          ],\n        },\n        \"istio.authentication.v1alpha1.MutualTls\": {\n          description:\n            \"Deprecated. Please use security/v1beta1/PeerAuthentication instead. TLS authentication params.\",\n          type: \"object\",\n          properties: {\n            allowTls: {\n              description:\n                \"Deprecated. Please use mode = PERMISSIVE instead. If set, will translate to `TLS_PERMISSIVE` mode. Set this flag to true to allow regular TLS (i.e without client x509 certificate). If request carries client certificate, identity will be extracted and used (set to peer identity). Otherwise, peer identity will be left unset. When the flag is false (default), request must have client certificate.\",\n              type: \"boolean\",\n              deprecated: true,\n            },\n            mode: {\n              $ref:\n                \"#/components/schemas/istio.authentication.v1alpha1.MutualTls.Mode\",\n            },\n          },\n        },\n        \"istio.authentication.v1alpha1.MutualTls.Mode\": {\n          description: \"Defines the acceptable connection TLS mode.\",\n          type: \"string\",\n          enum: [\"STRICT\", \"PERMISSIVE\"],\n        },\n        \"istio.authentication.v1alpha1.Jwt\": {\n          description:\n            \"Deprecated. Please use security/v1beta1/RequestAuthentication instead. JSON Web Token (JWT) token format for authentication as defined by [RFC 7519](https://tools.ietf.org/html/rfc7519). See [OAuth 2.0](https://tools.ietf.org/html/rfc6749) and [OIDC 1.0](http://openid.net/connect) for how this is used in the whole authentication flow.\",\n          type: \"object\",\n          properties: {\n            issuer: {\n              description:\n                \"Identifies the issuer that issued the JWT. See [issuer](https://tools.ietf.org/html/rfc7519#section-4.1.1) Usually a URL or an email address.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            audiences: {\n              description:\n                \"The list of JWT [audiences](https://tools.ietf.org/html/rfc7519#section-4.1.3). that are allowed to access. A JWT containing any of these audiences will be accepted.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            jwksUri: {\n              description:\n                \"URL of the provider's public key set to validate signature of the JWT. See [OpenID Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\",\n              type: \"string\",\n              format: \"string\",\n            },\n            jwks: {\n              description:\n                \"JSON Web Key Set of public keys to validate signature of the JWT. See https://auth0.com/docs/jwks.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            jwtHeaders: {\n              description:\n                \"JWT is sent in a request header. `header` represents the header name.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            jwtParams: {\n              description:\n                \"JWT is sent in a query parameter. `query` represents the query parameter name.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            triggerRules: {\n              description:\n                \"List of trigger rules to decide if this JWT should be used to validate the request. The JWT validation happens if any one of the rules matched. If the list is not empty and none of the rules matched, authentication will skip the JWT validation. Leave this empty to always trigger the JWT validation.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.authentication.v1alpha1.Jwt.TriggerRule\",\n              },\n            },\n          },\n        },\n        \"istio.authentication.v1alpha1.Jwt.TriggerRule\": {\n          description:\n            \"Trigger rule to match against a request. The trigger rule is satisfied if and only if both rules, excluded_paths and include_paths are satisfied.\",\n          type: \"object\",\n          properties: {\n            excludedPaths: {\n              description:\n                \"List of paths to be excluded from the request. The rule is satisfied if request path does not match to any of the path in this list.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.authentication.v1alpha1.StringMatch\",\n              },\n            },\n            includedPaths: {\n              description:\n                \"List of paths that the request must include. If the list is not empty, the rule is satisfied if request path matches at least one of the path in the list. If the list is empty, the rule is ignored, in other words the rule is always satisfied.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.authentication.v1alpha1.StringMatch\",\n              },\n            },\n          },\n        },\n        \"istio.authentication.v1alpha1.PeerAuthenticationMethod\": {\n          description:\n            'Deprecated. Please use security/v1beta1/PeerAuthentication instead. PeerAuthenticationMethod defines one particular type of authentication. Only mTLS is supported at the moment. The type can be progammatically determine by checking the type of the \"params\" field.',\n          type: \"object\",\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"mtls\"],\n                    properties: {\n                      mtls: {\n                        $ref:\n                          \"#/components/schemas/istio.authentication.v1alpha1.MutualTls\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"jwt\"],\n                    properties: {\n                      jwt: {\n                        $ref:\n                          \"#/components/schemas/istio.authentication.v1alpha1.Jwt\",\n                        deprecated: true,\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"mtls\"],\n              properties: {\n                mtls: {\n                  $ref:\n                    \"#/components/schemas/istio.authentication.v1alpha1.MutualTls\",\n                },\n              },\n            },\n            {\n              required: [\"jwt\"],\n              properties: {\n                jwt: {\n                  $ref:\n                    \"#/components/schemas/istio.authentication.v1alpha1.Jwt\",\n                  deprecated: true,\n                },\n              },\n            },\n          ],\n        },\n        \"istio.authentication.v1alpha1.OriginAuthenticationMethod\": {\n          description:\n            \"Deprecated. Please use security/v1beta1/RequestAuthentication instead. OriginAuthenticationMethod defines authentication method/params for origin authentication. Origin could be end-user, device, delegate service etc. Currently, only JWT is supported for origin authentication.\",\n          type: \"object\",\n          properties: {\n            jwt: {\n              $ref: \"#/components/schemas/istio.authentication.v1alpha1.Jwt\",\n            },\n          },\n        },\n        \"istio.authentication.v1alpha1.PrincipalBinding\": {\n          description:\n            \"Deprecated. When using security/v1beta1/RequestAuthentication, the request principal always comes from request authentication (i.e JWT). Associates authentication with request principal.\",\n          type: \"string\",\n          enum: [\"USE_PEER\", \"USE_ORIGIN\"],\n        },\n        \"istio.authentication.v1alpha1.Policy\": {\n          description:\n            \"Policy defines what authentication methods can be accepted on workload(s), and if authenticated, which method/certificate will set the request principal (i.e request.auth.principal attribute).\",\n          type: \"object\",\n          properties: {\n            targets: {\n              description:\n                \"Deprecated. Only mesh-level and namespace-level policies are supported. List rules to select workloads that the policy should be applied on. If empty, policy will be used on all workloads in the same namespace.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.authentication.v1alpha1.TargetSelector\",\n              },\n              deprecated: true,\n            },\n            peers: {\n              description:\n                \"Deprecated. Please use security/v1beta1/PeerAuthentication instead. List of authentication methods that can be used for peer authentication. They will be evaluated in order; the first validate one will be used to set peer identity (source.user) and other peer attributes. If none of these methods pass, request will be rejected with authentication failed error (401). Leave the list empty if peer authentication is not required\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.authentication.v1alpha1.PeerAuthenticationMethod\",\n              },\n            },\n            peerIsOptional: {\n              description:\n                \"Deprecated. Should set mTLS to PERMISSIVE instead. Set this flag to true to accept request (for peer authentication perspective), even when none of the peer authentication methods defined above satisfied. Typically, this is used to delay the rejection decision to next layer (e.g authorization). This flag is ignored if no authentication defined for peer (peers field is empty).\",\n              type: \"boolean\",\n              deprecated: true,\n            },\n            origins: {\n              description:\n                \"Deprecated. Please use security/v1beta1/RequestAuthentication instead. List of authentication methods that can be used for origin authentication. Similar to peers, these will be evaluated in order; the first validate one will be used to set origin identity and attributes (i.e request.auth.user, request.auth.issuer etc). If none of these methods pass, request will be rejected with authentication failed error (401). A method may be skipped, depends on its trigger rule. If all of these methods are skipped, origin authentication will be ignored, as if it is not defined. Leave the list empty if origin authentication is not required.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.authentication.v1alpha1.OriginAuthenticationMethod\",\n              },\n              deprecated: true,\n            },\n            originIsOptional: {\n              description:\n                \"Deprecated. Please use security/v1beta1/RequestAuthentication instead. Set this flag to true to accept request (for origin authentication perspective), even when none of the origin authentication methods defined above satisfied. Typically, this is used to delay the rejection decision to next layer (e.g authorization). This flag is ignored if no authentication defined for origin (origins field is empty).\",\n              type: \"boolean\",\n              deprecated: true,\n            },\n            principalBinding: {\n              $ref:\n                \"#/components/schemas/istio.authentication.v1alpha1.PrincipalBinding\",\n              deprecated: true,\n            },\n          },\n        },\n        \"istio.authentication.v1alpha1.TargetSelector\": {\n          description:\n            \"Deprecated. Only support mesh and namespace level policy in the future. TargetSelector defines a matching rule to a workload. A workload is selected if it is associated with the service name and service port(s) specified in the selector rule.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"The name must be a short name from the service registry. The fully qualified domain name will be resolved in a platform specific manner.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            ports: {\n              description:\n                \"Specifies the ports. Note that this is the port(s) exposed by the service, not workload instance ports. For example, if a service is defined as below, then `8000` should be used, not `9000`. ```yaml kind: Service metadata: ... spec: ports: - name: http port: 8000 targetPort: 9000 selector: app: backend ``` Leave empty to match all ports that are exposed.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.authentication.v1alpha1.PortSelector\",\n              },\n            },\n          },\n        },\n        \"istio.authentication.v1alpha1.PortSelector\": {\n          description:\n            \"Deprecated. Only support mesh and namespace level policy in the future. PortSelector specifies the name or number of a port to be used for matching targets for authentication policy. This is copied from networking API to avoid dependency.\",\n          type: \"object\",\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"number\"],\n                    properties: {\n                      number: {\n                        description: \"Valid port number\",\n                        type: \"integer\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"name\"],\n                    properties: {\n                      name: {\n                        description: \"Port name\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"number\"],\n              properties: {\n                number: {\n                  description: \"Valid port number\",\n                  type: \"integer\",\n                },\n              },\n            },\n            {\n              required: [\"name\"],\n              properties: {\n                name: {\n                  description: \"Port name\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n          ],\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title:\n        \"Describes the rules used to configure Mixer's policy and telemetry features.\",\n      version: \"v1beta1\",\n    },\n    components: {\n      schemas: {\n        \"istio.policy.v1beta1.Duration\": {\n          description:\n            \"An instance field of type Duration denotes that the expression for the field must evaluate to [ValueType.DURATION][istio.policy.v1beta1.ValueType.DURATION]\",\n          type: \"object\",\n          properties: {\n            value: {\n              description: \"Duration encoded as google.protobuf.Duration.\",\n              type: \"string\",\n            },\n          },\n        },\n        \"istio.policy.v1beta1.Value\": {\n          description:\n            'An instance field of type Value denotes that the expression for the field is of dynamic type and can evaluate to any [ValueType][istio.policy.v1beta1.ValueType] enum values. For example, when authoring an instance configuration for a template that has a field `data` of type `istio.policy.v1beta1.Value`, both of the following expressions are valid `data: source.ip | ip(\"0.0.0.0\")`, `data: request.id | \"\"`; the resulting type is either ValueType.IP_ADDRESS or ValueType.STRING for the two cases respectively.',\n          type: \"object\",\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"stringValue\"],\n                    properties: {\n                      stringValue: {\n                        description: \"Used for values of type STRING\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"int64Value\"],\n                    properties: {\n                      int64Value: {\n                        description: \"Used for values of type INT64\",\n                        type: \"integer\",\n                        format: \"int64\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"doubleValue\"],\n                    properties: {\n                      doubleValue: {\n                        description: \"Used for values of type DOUBLE\",\n                        type: \"number\",\n                        format: \"double\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"boolValue\"],\n                    properties: {\n                      boolValue: {\n                        description: \"Used for values of type BOOL\",\n                        type: \"boolean\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"ipAddressValue\"],\n                    properties: {\n                      ipAddressValue: {\n                        $ref:\n                          \"#/components/schemas/istio.policy.v1beta1.IPAddress\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"timestampValue\"],\n                    properties: {\n                      timestampValue: {\n                        $ref:\n                          \"#/components/schemas/istio.policy.v1beta1.TimeStamp\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"durationValue\"],\n                    properties: {\n                      durationValue: {\n                        $ref:\n                          \"#/components/schemas/istio.policy.v1beta1.Duration\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"emailAddressValue\"],\n                    properties: {\n                      emailAddressValue: {\n                        $ref:\n                          \"#/components/schemas/istio.policy.v1beta1.EmailAddress\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"dnsNameValue\"],\n                    properties: {\n                      dnsNameValue: {\n                        $ref:\n                          \"#/components/schemas/istio.policy.v1beta1.DNSName\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"uriValue\"],\n                    properties: {\n                      uriValue: {\n                        $ref: \"#/components/schemas/istio.policy.v1beta1.Uri\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"stringMapValue\"],\n                    properties: {\n                      stringMapValue: {\n                        $ref:\n                          \"#/components/schemas/istio.policy.v1beta1.StringMap\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"stringValue\"],\n              properties: {\n                stringValue: {\n                  description: \"Used for values of type STRING\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"int64Value\"],\n              properties: {\n                int64Value: {\n                  description: \"Used for values of type INT64\",\n                  type: \"integer\",\n                  format: \"int64\",\n                },\n              },\n            },\n            {\n              required: [\"doubleValue\"],\n              properties: {\n                doubleValue: {\n                  description: \"Used for values of type DOUBLE\",\n                  type: \"number\",\n                  format: \"double\",\n                },\n              },\n            },\n            {\n              required: [\"boolValue\"],\n              properties: {\n                boolValue: {\n                  description: \"Used for values of type BOOL\",\n                  type: \"boolean\",\n                },\n              },\n            },\n            {\n              required: [\"ipAddressValue\"],\n              properties: {\n                ipAddressValue: {\n                  $ref: \"#/components/schemas/istio.policy.v1beta1.IPAddress\",\n                },\n              },\n            },\n            {\n              required: [\"timestampValue\"],\n              properties: {\n                timestampValue: {\n                  $ref: \"#/components/schemas/istio.policy.v1beta1.TimeStamp\",\n                },\n              },\n            },\n            {\n              required: [\"durationValue\"],\n              properties: {\n                durationValue: {\n                  $ref: \"#/components/schemas/istio.policy.v1beta1.Duration\",\n                },\n              },\n            },\n            {\n              required: [\"emailAddressValue\"],\n              properties: {\n                emailAddressValue: {\n                  $ref:\n                    \"#/components/schemas/istio.policy.v1beta1.EmailAddress\",\n                },\n              },\n            },\n            {\n              required: [\"dnsNameValue\"],\n              properties: {\n                dnsNameValue: {\n                  $ref: \"#/components/schemas/istio.policy.v1beta1.DNSName\",\n                },\n              },\n            },\n            {\n              required: [\"uriValue\"],\n              properties: {\n                uriValue: {\n                  $ref: \"#/components/schemas/istio.policy.v1beta1.Uri\",\n                },\n              },\n            },\n            {\n              required: [\"stringMapValue\"],\n              properties: {\n                stringMapValue: {\n                  $ref: \"#/components/schemas/istio.policy.v1beta1.StringMap\",\n                },\n              },\n            },\n          ],\n        },\n        \"istio.policy.v1beta1.AttributeManifest\": {\n          description:\n            \"AttributeManifest describes a set of Attributes produced by some component of an Istio deployment.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"Name of the component producing these attributes. This can be the proxy (with the canonical name `istio-proxy`) or the name of an `attributes` kind adapter in Mixer.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            revision: {\n              description: \"The revision of this document. Assigned by server.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            attributes: {\n              description:\n                \"The set of attributes this Istio component will be responsible for producing at runtime. We map from attribute name to the attribute's specification. The name of an attribute, which is how attributes are referred to in aspect configuration, must conform to: Name = IDENT { SEPARATOR IDENT };\",\n              type: \"object\",\n              additionalProperties: {\n                $ref:\n                  \"#/components/schemas/istio.policy.v1beta1.AttributeManifest.AttributeInfo\",\n              },\n            },\n          },\n        },\n        \"istio.policy.v1beta1.AttributeManifest.AttributeInfo\": {\n          description:\n            \"AttributeInfo describes the schema of an Istio `Attribute`.\",\n          type: \"object\",\n          properties: {\n            description: {\n              description:\n                \"A human-readable description of the attribute's purpose.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            valueType: {\n              $ref: \"#/components/schemas/istio.policy.v1beta1.ValueType\",\n            },\n          },\n        },\n        \"istio.policy.v1beta1.ValueType\": {\n          description:\n            \"ValueType describes the types that values in the Istio system can take. These are used to describe the type of Attributes at run time, describe the type of the result of evaluating an expression, and to describe the runtime type of fields of other descriptors.\",\n          type: \"string\",\n          enum: [\n            \"VALUE_TYPE_UNSPECIFIED\",\n            \"STRING\",\n            \"INT64\",\n            \"DOUBLE\",\n            \"BOOL\",\n            \"TIMESTAMP\",\n            \"IP_ADDRESS\",\n            \"EMAIL_ADDRESS\",\n            \"URI\",\n            \"DNS_NAME\",\n            \"DURATION\",\n            \"STRING_MAP\",\n          ],\n        },\n        \"istio.policy.v1beta1.Rule\": {\n          description:\n            \"A Rule is a selector and a set of intentions to be executed when the selector is `true`\",\n          type: \"object\",\n          properties: {\n            match: {\n              description:\n                \"Match is an attribute based predicate. When Mixer receives a request it evaluates the match expression and executes all the associated `actions` if the match evaluates to true.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            actions: {\n              description:\n                \"The actions that will be executed when match evaluates to `true`.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.policy.v1beta1.Action\",\n              },\n            },\n            requestHeaderOperations: {\n              description:\n                \"Templatized operations on the request headers using values produced by the rule actions. Require the check action result to be OK.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.policy.v1beta1.Rule.HeaderOperationTemplate\",\n              },\n            },\n            responseHeaderOperations: {\n              description:\n                \"Templatized operations on the response headers using values produced by the rule actions. Require the check action result to be OK.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.policy.v1beta1.Rule.HeaderOperationTemplate\",\n              },\n            },\n            sampling: {\n              $ref: \"#/components/schemas/istio.policy.v1beta1.Sampling\",\n            },\n          },\n        },\n        \"istio.policy.v1beta1.Action\": {\n          description:\n            \"Action describes which [Handler][istio.policy.v1beta1.Handler] to invoke and what data to pass to it for processing.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description: \"A handle to refer to the results of the action.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            handler: {\n              description:\n                \"Fully qualified name of the handler to invoke. Must match the `name` of a [Handler][istio.policy.v1beta1.Handler.name].\",\n              type: \"string\",\n              format: \"string\",\n            },\n            instances: {\n              description:\n                \"Each value must match the fully qualified name of the [Instance][istio.policy.v1beta1.Instance.name]s. Referenced instances are evaluated by resolving the attributes/literals for all the fields. The constructed objects are then passed to the `handler` referenced within this action.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.policy.v1beta1.Rule.HeaderOperationTemplate\": {\n          description:\n            \"A template for an HTTP header manipulation. Values in the template are expressions that may reference action outputs by name. For example, if an action `x` produces an output with a field `f`, then the header value expressions may use attribute `x.output.f` to reference the field value: ```yaml request_header_operations: - name: x-istio-header values: - x.output.f ```\",\n          type: \"object\",\n          properties: {\n            name: {\n              description: \"Header name literal value.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            values: {\n              description: \"Header value expressions.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            operation: {\n              $ref:\n                \"#/components/schemas/istio.policy.v1beta1.Rule.HeaderOperationTemplate.Operation\",\n            },\n          },\n        },\n        \"istio.policy.v1beta1.Sampling\": {\n          description:\n            \"Sampling provides configuration of sampling strategies for Rule actions. Multiple sampling strategies are supported. When multiple strategies are configured, a request must be selected by all configured sampling strategies.\",\n          type: \"object\",\n          properties: {\n            random: {\n              $ref: \"#/components/schemas/istio.policy.v1beta1.RandomSampling\",\n            },\n            rateLimit: {\n              $ref:\n                \"#/components/schemas/istio.policy.v1beta1.RateLimitSampling\",\n            },\n          },\n        },\n        \"istio.policy.v1beta1.Rule.HeaderOperationTemplate.Operation\": {\n          description: \"Header operation type.\",\n          type: \"string\",\n          enum: [\"REPLACE\", \"REMOVE\", \"APPEND\"],\n        },\n        \"istio.policy.v1beta1.Instance\": {\n          description:\n            \"An Instance tells Mixer how to create instances for particular template.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description: \"The name of this instance\",\n              type: \"string\",\n              format: \"string\",\n            },\n            compiledTemplate: {\n              description:\n                \"The name of the compiled in template this instance creates instances for. For referencing non compiled-in templates, use the `template` field instead.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            template: {\n              description:\n                \"The name of the template this instance creates instances for. For referencing compiled-in templates, use the `compiled_template` field instead.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            params: {\n              description:\n                \"Depends on referenced template. Struct representation of a proto defined by the template; this varies depending on the value of field `template`.\",\n              type: \"object\",\n            },\n            attributeBindings: {\n              description:\n                'Defines attribute bindings to map the output of attribute-producing adapters back into the attribute space. The variable `output` refers to the output template instance produced by the adapter. The following example derives `source.namespace` from `source.uid` in the context of Kubernetes: ```yaml params: # Pass the required attribute data to the adapter source_uid: source.uid | \"\" attribute_bindings: # Fill the new attributes from the adapter produced output source.namespace: output.source_namespace ```',\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.policy.v1beta1.Handler\": {\n          description:\n            \"Handler allows the operator to configure a specific adapter implementation. Each adapter implementation defines its own `params` proto.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"Must be unique in the entire Mixer configuration. Used by [Actions][istio.policy.v1beta1.Action.handler] to refer to this handler.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            params: {\n              description:\n                \"Depends on adapter implementation. Struct representation of a proto defined by the adapter implementation; this varies depending on the value of field `adapter`.\",\n              type: \"object\",\n            },\n            compiledAdapter: {\n              description:\n                \"The name of the compiled in adapter this handler instantiates. For referencing non compiled-in adapters, use the `adapter` field instead.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            adapter: {\n              description:\n                \"The name of a specific adapter implementation. For referencing compiled-in adapters, use the `compiled_adapter` field instead.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            connection: {\n              $ref: \"#/components/schemas/istio.policy.v1beta1.Connection\",\n            },\n          },\n        },\n        \"istio.policy.v1beta1.Connection\": {\n          description:\n            \"Connection allows the operator to specify the endpoint for out-of-process infrastructure backend. Connection is part of the handler custom resource and is specified alongside adapter specific configuration.\",\n          type: \"object\",\n          properties: {\n            address: {\n              description: \"The address of the backend.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            timeout: {\n              description: \"Timeout for remote calls to the backend.\",\n              type: \"string\",\n            },\n            authentication: {\n              $ref: \"#/components/schemas/istio.policy.v1beta1.Authentication\",\n            },\n          },\n        },\n        \"istio.policy.v1beta1.Authentication\": {\n          description:\n            \"Authentication allows the operator to specify the authentication of connections to out-of-process infrastructure backend.\",\n          type: \"object\",\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"tls\"],\n                    properties: {\n                      tls: {\n                        $ref: \"#/components/schemas/istio.policy.v1beta1.Tls\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"mutual\"],\n                    properties: {\n                      mutual: {\n                        $ref:\n                          \"#/components/schemas/istio.policy.v1beta1.Mutual\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"tls\"],\n              properties: {\n                tls: {\n                  $ref: \"#/components/schemas/istio.policy.v1beta1.Tls\",\n                },\n              },\n            },\n            {\n              required: [\"mutual\"],\n              properties: {\n                mutual: {\n                  $ref: \"#/components/schemas/istio.policy.v1beta1.Mutual\",\n                },\n              },\n            },\n          ],\n        },\n        \"istio.policy.v1beta1.RandomSampling\": {\n          description:\n            \"RandomSampling will filter based on the comparison of a randomly-generated value against the threshold provided.\",\n          type: \"object\",\n          properties: {\n            attributeExpression: {\n              description:\n                \"Specifies an attribute expression to use to override the numerator in the `percent_sampled` field. If this value is set, but no value is found OR if that value is not a numeric value, then the derived sampling rate will be 0 (meaning no `Action`s are executed for a `Rule`).\",\n              type: \"string\",\n              format: \"string\",\n            },\n            percentSampled: {\n              $ref:\n                \"#/components/schemas/istio.policy.v1beta1.FractionalPercent\",\n            },\n            useIndependentRandomness: {\n              description:\n                \"By default sampling will be based on the value of the request header `x-request-id`. This behavior will cause consistent sampling across `Rule`s and for the full trace of a request through a mesh (across hosts). If that value is not present and/or `use_independent_randomness` is set to true, the sampling will be done based on the value of attribute specified in `attribute_epxression`. If that attribute does not exist, the system will behave as if the sampling rate was 0 (meaning no `Action`s are executed for a `Rule`).\",\n              type: \"boolean\",\n            },\n          },\n        },\n        \"istio.policy.v1beta1.RateLimitSampling\": {\n          description:\n            \"RateLimitSampling provides the ability to limit the number of Rule action executions that occur over a period of time.\",\n          type: \"object\",\n          properties: {\n            samplingDuration: {\n              description: \"Window in which to enforce the sampling rate.\",\n              type: \"string\",\n            },\n            maxUnsampledEntries: {\n              description:\n                \"Number of entries to allow during the `sampling_duration` before sampling is enforced.\",\n              type: \"integer\",\n              format: \"int64\",\n            },\n            samplingRate: {\n              description:\n                \"The rate at which to sample entries once the unsampled limit has been reached. Sampling will be enforced as 1 per every `sampling_rate` entries allowed.\",\n              type: \"integer\",\n              format: \"int64\",\n            },\n          },\n        },\n        \"istio.policy.v1beta1.FractionalPercent\": {\n          description:\n            \"A fractional percentage is used in cases in which for performance reasons performing floating point to integer conversions during randomness calculations is undesirable. The message includes both a numerator and denominator that together determine the final fractional value.\",\n          type: \"object\",\n          properties: {\n            numerator: {\n              description: \"Specifies the numerator. Defaults to 0.\",\n              type: \"integer\",\n            },\n            denominator: {\n              $ref:\n                \"#/components/schemas/istio.policy.v1beta1.FractionalPercent.DenominatorType\",\n            },\n          },\n        },\n        \"istio.policy.v1beta1.FractionalPercent.DenominatorType\": {\n          description:\n            \"Fraction percentages support several fixed denominator values.\",\n          type: \"string\",\n          enum: [\"HUNDRED\", \"TEN_THOUSAND\"],\n        },\n        \"istio.policy.v1beta1.Tls\": {\n          description:\n            \"Tls let operator specify client authentication setting when TLS is used for connection to the backend.\",\n          type: \"object\",\n          properties: {\n            caCertificates: {\n              description:\n                \"The path to the file holding additional CA certificates to well known public certs.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            serverName: {\n              description:\n                \"Used to configure mixer TLS client to verify the hostname on the returned certificates. It is also included in the client's handshake to support SNI.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n          allOf: [\n            {\n              oneOf: [\n                {\n                  not: {\n                    anyOf: [\n                      {\n                        required: [\"tokenPath\"],\n                        properties: {\n                          tokenPath: {\n                            description:\n                              \"The path to the file holding the auth token (password, jwt token, api key, etc).\",\n                            type: \"string\",\n                            format: \"string\",\n                          },\n                        },\n                      },\n                      {\n                        required: [\"oauth\"],\n                        properties: {\n                          oauth: {\n                            $ref:\n                              \"#/components/schemas/istio.policy.v1beta1.OAuth\",\n                          },\n                        },\n                      },\n                    ],\n                  },\n                },\n                {\n                  required: [\"tokenPath\"],\n                  properties: {\n                    tokenPath: {\n                      description:\n                        \"The path to the file holding the auth token (password, jwt token, api key, etc).\",\n                      type: \"string\",\n                      format: \"string\",\n                    },\n                  },\n                },\n                {\n                  required: [\"oauth\"],\n                  properties: {\n                    oauth: {\n                      $ref: \"#/components/schemas/istio.policy.v1beta1.OAuth\",\n                    },\n                  },\n                },\n              ],\n            },\n            {\n              oneOf: [\n                {\n                  not: {\n                    anyOf: [\n                      {\n                        required: [\"authHeader\"],\n                        properties: {\n                          authHeader: {\n                            $ref:\n                              \"#/components/schemas/istio.policy.v1beta1.Tls.AuthHeader\",\n                          },\n                        },\n                      },\n                      {\n                        required: [\"customHeader\"],\n                        properties: {\n                          customHeader: {\n                            description:\n                              \"Customized header key to hold access token, e.g. x-api-key. Token will be passed as what it is.\",\n                            type: \"string\",\n                            format: \"string\",\n                          },\n                        },\n                      },\n                    ],\n                  },\n                },\n                {\n                  required: [\"authHeader\"],\n                  properties: {\n                    authHeader: {\n                      $ref:\n                        \"#/components/schemas/istio.policy.v1beta1.Tls.AuthHeader\",\n                    },\n                  },\n                },\n                {\n                  required: [\"customHeader\"],\n                  properties: {\n                    customHeader: {\n                      description:\n                        \"Customized header key to hold access token, e.g. x-api-key. Token will be passed as what it is.\",\n                      type: \"string\",\n                      format: \"string\",\n                    },\n                  },\n                },\n              ],\n            },\n          ],\n        },\n        \"istio.policy.v1beta1.Mutual\": {\n          description:\n            \"Mutual let operator specify TLS configuration for Mixer as client if mutual TLS is used to secure connection to adapter backend.\",\n          type: \"object\",\n          properties: {\n            caCertificates: {\n              description:\n                \"The path to the file holding additional CA certificates that are needed to verify the presented adapter certificates. By default Mixer should already include Istio CA certificates and system certificates in cert pool.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            serverName: {\n              description:\n                \"Used to configure mixer mutual TLS client to supply server name for SNI. It is not used to verify the hostname of the peer certificate, since Istio verifies whitelisted SAN fields in mutual TLS.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            privateKey: {\n              description:\n                \"The path to the file holding the private key for mutual TLS. If omitted, the default Mixer private key will be used.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            clientCertificate: {\n              description:\n                \"The path to the file holding client certificate for mutual TLS. If omitted, the default Mixer certificates will be used.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.policy.v1beta1.OAuth\": {\n          description:\n            \"OAuth let operator specify config to fetch access token via oauth when using TLS for connection to the backend.\",\n          type: \"object\",\n          properties: {\n            clientId: {\n              description: \"OAuth client id for mixer.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            clientSecret: {\n              description:\n                \"The path to the file holding the client secret for oauth.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            tokenUrl: {\n              description: \"The Resource server's token endpoint URL.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            scopes: {\n              description: \"List of requested permissions.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            endpointParams: {\n              description:\n                \"Additional parameters for requests to the token endpoint.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.policy.v1beta1.Tls.AuthHeader\": {\n          description:\n            \"AuthHeader specifies how to pass access token with authorization header.\",\n          type: \"string\",\n          enum: [\"PLAIN\", \"BEARER\"],\n        },\n        \"istio.policy.v1beta1.DirectHttpResponse\": {\n          description:\n            \"Direct HTTP response for a client-facing error message which can be attached to an RPC error.\",\n          type: \"object\",\n          properties: {\n            body: {\n              description: \"HTTP response body.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            code: {\n              $ref: \"#/components/schemas/istio.policy.v1beta1.HttpStatusCode\",\n            },\n            headers: {\n              description: \"HTTP response headers.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.policy.v1beta1.HttpStatusCode\": {\n          description:\n            \"HTTP response codes. For more details: http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\",\n          type: \"string\",\n          enum: [\n            \"Empty\",\n            \"Continue\",\n            \"OK\",\n            \"Created\",\n            \"Accepted\",\n            \"NonAuthoritativeInformation\",\n            \"NoContent\",\n            \"ResetContent\",\n            \"PartialContent\",\n            \"MultiStatus\",\n            \"AlreadyReported\",\n            \"IMUsed\",\n            \"MultipleChoices\",\n            \"MovedPermanently\",\n            \"Found\",\n            \"SeeOther\",\n            \"NotModified\",\n            \"UseProxy\",\n            \"TemporaryRedirect\",\n            \"PermanentRedirect\",\n            \"BadRequest\",\n            \"Unauthorized\",\n            \"PaymentRequired\",\n            \"Forbidden\",\n            \"NotFound\",\n            \"MethodNotAllowed\",\n            \"NotAcceptable\",\n            \"ProxyAuthenticationRequired\",\n            \"RequestTimeout\",\n            \"Conflict\",\n            \"Gone\",\n            \"LengthRequired\",\n            \"PreconditionFailed\",\n            \"PayloadTooLarge\",\n            \"URITooLong\",\n            \"UnsupportedMediaType\",\n            \"RangeNotSatisfiable\",\n            \"ExpectationFailed\",\n            \"MisdirectedRequest\",\n            \"UnprocessableEntity\",\n            \"Locked\",\n            \"FailedDependency\",\n            \"UpgradeRequired\",\n            \"PreconditionRequired\",\n            \"TooManyRequests\",\n            \"RequestHeaderFieldsTooLarge\",\n            \"InternalServerError\",\n            \"NotImplemented\",\n            \"BadGateway\",\n            \"ServiceUnavailable\",\n            \"GatewayTimeout\",\n            \"HTTPVersionNotSupported\",\n            \"VariantAlsoNegotiates\",\n            \"InsufficientStorage\",\n            \"LoopDetected\",\n            \"NotExtended\",\n            \"NetworkAuthenticationRequired\",\n          ],\n        },\n        \"istio.policy.v1beta1.IPAddress\": {\n          description:\n            \"An instance field of type IPAddress denotes that the expression for the field must evaluate to [ValueType.IP_ADDRESS][istio.policy.v1beta1.ValueType.IP_ADDRESS]\",\n          type: \"object\",\n          properties: {\n            value: {\n              description: \"IPAddress encoded as bytes.\",\n              type: \"string\",\n              format: \"binary\",\n            },\n          },\n        },\n        \"istio.policy.v1beta1.TimeStamp\": {\n          description:\n            \"An instance field of type TimeStamp denotes that the expression for the field must evaluate to [ValueType.TIMESTAMP][istio.policy.v1beta1.ValueType.TIMESTAMP]\",\n          type: \"object\",\n          properties: {\n            value: {\n              description: \"TimeStamp encoded as google.protobuf.Timestamp.\",\n              type: \"string\",\n              format: \"dateTime\",\n            },\n          },\n        },\n        \"istio.policy.v1beta1.EmailAddress\": {\n          description:\n            \"DO NOT USE !! Under Development An instance field of type EmailAddress denotes that the expression for the field must evaluate to [ValueType.EMAIL_ADDRESS][istio.policy.v1beta1.ValueType.EMAIL_ADDRESS]\",\n          type: \"object\",\n          properties: {\n            value: {\n              description: \"EmailAddress encoded as string.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.policy.v1beta1.DNSName\": {\n          description:\n            \"An instance field of type DNSName denotes that the expression for the field must evaluate to [ValueType.DNS_NAME][istio.policy.v1beta1.ValueType.DNS_NAME]\",\n          type: \"object\",\n          properties: {\n            value: {\n              description: \"DNSName encoded as string.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.policy.v1beta1.Uri\": {\n          description:\n            \"DO NOT USE !! Under Development An instance field of type Uri denotes that the expression for the field must evaluate to [ValueType.URI][istio.policy.v1beta1.ValueType.URI]\",\n          type: \"object\",\n          properties: {\n            value: {\n              description: \"Uri encoded as string.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.policy.v1beta1.StringMap\": {\n          description:\n            \"An instance field of type StringMap denotes that the expression for the field must evaluate to [ValueType.STRING_MAP][istio.policy.v1beta1.ValueType.STRING_MAP]\",\n          type: \"object\",\n          properties: {\n            value: {\n              description: \"StringMap encoded as a map of strings\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Configuration for access control on workloads.\",\n      version: \"v1beta1\",\n    },\n    components: {\n      schemas: {\n        \"istio.security.v1beta1.AuthorizationPolicy\": {\n          description:\n            \"AuthorizationPolicy enables access control on workloads.\",\n          type: \"object\",\n          properties: {\n            selector: {\n              $ref: \"#/components/schemas/istio.type.v1beta1.WorkloadSelector\",\n            },\n            rules: {\n              description:\n                \"Optional. A list of rules to match the request. A match occurs when at least one rule matches the request.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.security.v1beta1.Rule\",\n              },\n            },\n            action: {\n              $ref:\n                \"#/components/schemas/istio.security.v1beta1.AuthorizationPolicy.Action\",\n            },\n          },\n        },\n        \"istio.security.v1beta1.Rule\": {\n          description:\n            \"Rule matches requests from a list of sources that perform a list of operations subject to a list of conditions. A match occurs when at least one source, operation and condition matches the request. An empty rule is always matched.\",\n          type: \"object\",\n          properties: {\n            from: {\n              description: \"Optional. from specifies the source of a request.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.security.v1beta1.Rule.From\",\n              },\n            },\n            to: {\n              description: \"Optional. to specifies the operation of a request.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.security.v1beta1.Rule.To\",\n              },\n            },\n            when: {\n              description:\n                \"Optional. when specifies a list of additional conditions of a request.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.security.v1beta1.Condition\",\n              },\n            },\n          },\n        },\n        \"istio.security.v1beta1.AuthorizationPolicy.Action\": {\n          description: \"Action specifies the operation to take.\",\n          type: \"string\",\n          enum: [\"ALLOW\", \"DENY\"],\n        },\n        \"istio.security.v1beta1.Rule.From\": {\n          description: \"From includes a list or sources.\",\n          type: \"object\",\n          properties: {\n            source: {\n              $ref: \"#/components/schemas/istio.security.v1beta1.Source\",\n            },\n          },\n        },\n        \"istio.security.v1beta1.Rule.To\": {\n          description: \"To includes a list or operations.\",\n          type: \"object\",\n          properties: {\n            operation: {\n              $ref: \"#/components/schemas/istio.security.v1beta1.Operation\",\n            },\n          },\n        },\n        \"istio.security.v1beta1.Condition\": {\n          description: \"Condition specifies additional required attributes.\",\n          type: \"object\",\n          properties: {\n            key: {\n              description:\n                \"The name of an Istio attribute. See the [full list of supported attributes](https://istio.io/docs/reference/config/security/conditions/).\",\n              type: \"string\",\n              format: \"string\",\n            },\n            values: {\n              description:\n                \"Optional. A list of allowed values for the attribute. Note: at least one of values or not_values must be set.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            notValues: {\n              description:\n                \"Optional. A list of negative match of values for the attribute. Note: at least one of values or not_values must be set.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.security.v1beta1.Source\": {\n          description:\n            \"Source specifies the source identities of a request. Fields in the source are ANDed together.\",\n          type: \"object\",\n          properties: {\n            principals: {\n              description:\n                'Optional. A list of source peer identities (i.e. service account), which matches to the \"source.principal\" attribute. This field requires mTLS enabled.',\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            notPrincipals: {\n              description:\n                \"Optional. A list of negative match of source peer identities.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            requestPrincipals: {\n              description:\n                'Optional. A list of request identities (i.e. \"iss/sub\" claims), which matches to the \"request.auth.principal\" attribute.',\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            notRequestPrincipals: {\n              description:\n                \"Optional. A list of negative match of request identities.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            namespaces: {\n              description:\n                'Optional. A list of namespaces, which matches to the \"source.namespace\" attribute. This field requires mTLS enabled.',\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            notNamespaces: {\n              description: \"Optional. A list of negative match of namespaces.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            ipBlocks: {\n              description:\n                'Optional. A list of IP blocks, which matches to the \"source.ip\" attribute. Single IP (e.g. \"1.2.3.4\") and CIDR (e.g. \"1.2.3.0/24\") are supported.',\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            notIpBlocks: {\n              description: \"Optional. A list of negative match of IP blocks.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.security.v1beta1.Operation\": {\n          description:\n            \"Operation specifies the operations of a request. Fields in the operation are ANDed together.\",\n          type: \"object\",\n          properties: {\n            hosts: {\n              description:\n                'Optional. A list of hosts, which matches to the \"request.host\" attribute.',\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            notHosts: {\n              description: \"Optional. A list of negative match of hosts.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            ports: {\n              description:\n                'Optional. A list of ports, which matches to the \"destination.port\" attribute.',\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            notPorts: {\n              description: \"Optional. A list of negative match of ports.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            methods: {\n              description:\n                'Optional. A list of methods, which matches to the \"request.method\" attribute. For gRPC service, this will always be \"POST\".',\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            notMethods: {\n              description: \"Optional. A list of negative match of methods.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            paths: {\n              description:\n                'Optional. A list of paths, which matches to the \"request.url_path\" attribute. For gRPC service, this will be the fully-qualified name in the form of \"/package.service/method\".',\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            notPaths: {\n              description: \"Optional. A list of negative match of paths.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.type.v1beta1.WorkloadSelector\": {\n          description:\n            \"The selector determines the workloads to apply the RequestAuthentication on. If not set, the policy will be applied to all workloads in the same namespace as the policy.\",\n          type: \"object\",\n          properties: {\n            matchLabels: {\n              description:\n                \"One or more labels that indicate a specific set of pods/VMs on which a policy should be applied. The scope of label search is restricted to the configuration namespace in which the resource is present.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Configuration to validate JWT.\",\n      version: \"v1beta1\",\n    },\n    components: {\n      schemas: {\n        \"istio.security.v1beta1.JWTRule\": {\n          description:\n            \"JSON Web Token (JWT) token format for authentication as defined by [RFC 7519](https://tools.ietf.org/html/rfc7519). See [OAuth 2.0](https://tools.ietf.org/html/rfc6749) and [OIDC 1.0](http://openid.net/connect) for how this is used in the whole authentication flow.\",\n          type: \"object\",\n          properties: {\n            issuer: {\n              description:\n                \"Identifies the issuer that issued the JWT. See [issuer](https://tools.ietf.org/html/rfc7519#section-4.1.1) A JWT with different `iss` claim will be rejected.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            audiences: {\n              description:\n                \"The list of JWT [audiences](https://tools.ietf.org/html/rfc7519#section-4.1.3). that are allowed to access. A JWT containing any of these audiences will be accepted.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            jwksUri: {\n              description:\n                \"URL of the provider's public key set to validate signature of the JWT. See [OpenID Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\",\n              type: \"string\",\n              format: \"string\",\n            },\n            jwks: {\n              description:\n                \"JSON Web Key Set of public keys to validate signature of the JWT. See https://auth0.com/docs/jwks.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            fromHeaders: {\n              description:\n                'List of header locations from which JWT is expected. For example, below is the location spec if JWT is expected to be found in `x-jwt-assertion` header, and have \"Bearer \" prefix: ``` fromHeaders: - name: x-jwt-assertion prefix: \"Bearer \" ```',\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.security.v1beta1.JWTHeader\",\n              },\n            },\n            fromParams: {\n              description:\n                'List of query parameters from which JWT is expected. For example, if JWT is provided via query parameter `my_token` (e.g /path?my_token=\\u003cJWT\\u003e), the config is: ``` fromParams: - \"my_token\" ```',\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            outputPayloadToHeader: {\n              description:\n                \"This field specifies the header name to output a successfully verified JWT payload to the backend. The forwarded data is `base64_encoded(jwt_payload_in_JSON)`. If it is not specified, the payload will not be emitted.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            forwardOriginalToken: {\n              description:\n                \"If set to true, the orginal token will be kept for the ustream request. Default is false.\",\n              type: \"boolean\",\n            },\n          },\n        },\n        \"istio.security.v1beta1.JWTHeader\": {\n          description:\n            \"This message specifies a header location to extract JWT token.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description: \"The HTTP header name.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            prefix: {\n              description:\n                'The prefix that should be stripped before decoding the token. For example, for \"Authorization: Bearer \\u003ctoken\\u003e\", prefix=\"Bearer \" with a space at the end. If the header doesn\\'t have this exact prefix, it is considerred invalid.',\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Request authentication configuration for workloads.\",\n      version: \"v1beta1\",\n    },\n    components: {\n      schemas: {\n        \"istio.security.v1beta1.JWTRule\": {\n          description:\n            \"JSON Web Token (JWT) token format for authentication as defined by [RFC 7519](https://tools.ietf.org/html/rfc7519). See [OAuth 2.0](https://tools.ietf.org/html/rfc6749) and [OIDC 1.0](http://openid.net/connect) for how this is used in the whole authentication flow.\",\n          type: \"object\",\n          properties: {\n            issuer: {\n              description:\n                \"Identifies the issuer that issued the JWT. See [issuer](https://tools.ietf.org/html/rfc7519#section-4.1.1) A JWT with different `iss` claim will be rejected.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            audiences: {\n              description:\n                \"The list of JWT [audiences](https://tools.ietf.org/html/rfc7519#section-4.1.3). that are allowed to access. A JWT containing any of these audiences will be accepted.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            jwksUri: {\n              description:\n                \"URL of the provider's public key set to validate signature of the JWT. See [OpenID Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\",\n              type: \"string\",\n              format: \"string\",\n            },\n            jwks: {\n              description:\n                \"JSON Web Key Set of public keys to validate signature of the JWT. See https://auth0.com/docs/jwks.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            fromHeaders: {\n              description:\n                'List of header locations from which JWT is expected. For example, below is the location spec if JWT is expected to be found in `x-jwt-assertion` header, and have \"Bearer \" prefix: ``` fromHeaders: - name: x-jwt-assertion prefix: \"Bearer \" ```',\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.security.v1beta1.JWTHeader\",\n              },\n            },\n            fromParams: {\n              description:\n                'List of query parameters from which JWT is expected. For example, if JWT is provided via query parameter `my_token` (e.g /path?my_token=\\u003cJWT\\u003e), the config is: ``` fromParams: - \"my_token\" ```',\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            outputPayloadToHeader: {\n              description:\n                \"This field specifies the header name to output a successfully verified JWT payload to the backend. The forwarded data is `base64_encoded(jwt_payload_in_JSON)`. If it is not specified, the payload will not be emitted.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            forwardOriginalToken: {\n              description:\n                \"If set to true, the orginal token will be kept for the ustream request. Default is false.\",\n              type: \"boolean\",\n            },\n          },\n        },\n        \"istio.security.v1beta1.JWTHeader\": {\n          description:\n            \"This message specifies a header location to extract JWT token.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description: \"The HTTP header name.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            prefix: {\n              description:\n                'The prefix that should be stripped before decoding the token. For example, for \"Authorization: Bearer \\u003ctoken\\u003e\", prefix=\"Bearer \" with a space at the end. If the header doesn\\'t have this exact prefix, it is considerred invalid.',\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.security.v1beta1.RequestAuthentication\": {\n          description:\n            \"RequestAuthentication defines what request authentication methods are supported by a workload. If will reject a request if the request contains invalid authentication information, based on the configured authentication rules. A request that does not contain any authentication credentials will be accepted but will not have any authenticated identity. To restrict access to authenticated requests only, this should be accompanied by an authorization rule. Examples: - Require JWT for all request for workloads that have label `app:httpbin`\",\n          type: \"object\",\n          properties: {\n            selector: {\n              $ref: \"#/components/schemas/istio.type.v1beta1.WorkloadSelector\",\n            },\n            jwtRules: {\n              description:\n                \"Define the list of JWTs that can be validated at the selected workloads' proxy. A valid token will be used to extract the authenticated identity. Each rule will be activated only when a token is presented at the location recorgnized by the rule. The token will be validated based on the JWT rule config. If validation fails, the request will be rejected. Note: if more than one token is presented (at different locations), the output principal is nondeterministic.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.security.v1beta1.JWTRule\",\n              },\n            },\n          },\n        },\n        \"istio.type.v1beta1.WorkloadSelector\": {\n          description:\n            \"The selector determines the workloads to apply the RequestAuthentication on. If not set, the policy will be applied to all workloads in the same namespace as the policy.\",\n          type: \"object\",\n          properties: {\n            matchLabels: {\n              description:\n                \"One or more labels that indicate a specific set of pods/VMs on which a policy should be applied. The scope of label search is restricted to the configuration namespace in which the resource is present.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Peer authentication configuration for workloads.\",\n      version: \"v1beta1\",\n    },\n    components: {\n      schemas: {\n        \"istio.security.v1beta1.PeerAuthentication\": {\n          description:\n            \"PeerAuthentication defines how traffic will be tunneled (or not) to the sidecar.\",\n          type: \"object\",\n          properties: {\n            selector: {\n              $ref: \"#/components/schemas/istio.type.v1beta1.WorkloadSelector\",\n            },\n            mtls: {\n              $ref:\n                \"#/components/schemas/istio.security.v1beta1.PeerAuthentication.MutualTLS\",\n            },\n            portLevelMtls: {\n              description: \"Port specific mutual TLS settings.\",\n              type: \"object\",\n              additionalProperties: {\n                $ref:\n                  \"#/components/schemas/istio.security.v1beta1.PeerAuthentication.MutualTLS\",\n              },\n            },\n          },\n        },\n        \"istio.security.v1beta1.PeerAuthentication.MutualTLS\": {\n          description: \"Mutual TLS settings.\",\n          type: \"object\",\n          properties: {\n            mode: {\n              $ref:\n                \"#/components/schemas/istio.security.v1beta1.PeerAuthentication.MutualTLS.Mode\",\n            },\n          },\n        },\n        \"istio.security.v1beta1.PeerAuthentication.MutualTLS.Mode\": {\n          type: \"string\",\n          enum: [\"UNSET\", \"DISABLE\", \"PERMISSIVE\", \"STRICT\"],\n        },\n        \"istio.type.v1beta1.WorkloadSelector\": {\n          description:\n            \"The selector determines the workloads to apply the RequestAuthentication on. If not set, the policy will be applied to all workloads in the same namespace as the policy.\",\n          type: \"object\",\n          properties: {\n            matchLabels: {\n              description:\n                \"One or more labels that indicate a specific set of pods/VMs on which a policy should be applied. The scope of label search is restricted to the configuration namespace in which the resource is present.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title:\n        \"This package defines the Mixer API that the sidecar proxy uses to perform precondition checks, manage quotas, and report telemetry.\",\n      version: \"v1\",\n    },\n    components: {\n      schemas: {\n        \"istio.mixer.v1.Attributes\": {\n          description:\n            \"Attributes represents a set of typed name/value pairs. Many of Mixer's API either consume and/or return attributes.\",\n          type: \"object\",\n          properties: {\n            attributes: {\n              description: \"A map of attribute name to its value.\",\n              type: \"object\",\n              additionalProperties: {\n                $ref:\n                  \"#/components/schemas/istio.mixer.v1.Attributes.AttributeValue\",\n              },\n            },\n          },\n        },\n        \"istio.mixer.v1.Attributes.AttributeValue\": {\n          description: \"Specifies one attribute value with different type.\",\n          type: \"object\",\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"stringValue\"],\n                    properties: {\n                      stringValue: {\n                        description:\n                          \"Used for values of type STRING, DNS_NAME, EMAIL_ADDRESS, and URI\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"int64Value\"],\n                    properties: {\n                      int64Value: {\n                        description: \"Used for values of type INT64\",\n                        type: \"integer\",\n                        format: \"int64\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"doubleValue\"],\n                    properties: {\n                      doubleValue: {\n                        description: \"Used for values of type DOUBLE\",\n                        type: \"number\",\n                        format: \"double\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"boolValue\"],\n                    properties: {\n                      boolValue: {\n                        description: \"Used for values of type BOOL\",\n                        type: \"boolean\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"bytesValue\"],\n                    properties: {\n                      bytesValue: {\n                        description: \"Used for values of type BYTES\",\n                        type: \"string\",\n                        format: \"binary\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"timestampValue\"],\n                    properties: {\n                      timestampValue: {\n                        description: \"Used for values of type TIMESTAMP\",\n                        type: \"string\",\n                        format: \"dateTime\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"durationValue\"],\n                    properties: {\n                      durationValue: {\n                        description: \"Used for values of type DURATION\",\n                        type: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"stringMapValue\"],\n                    properties: {\n                      stringMapValue: {\n                        $ref:\n                          \"#/components/schemas/istio.mixer.v1.Attributes.StringMap\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"stringValue\"],\n              properties: {\n                stringValue: {\n                  description:\n                    \"Used for values of type STRING, DNS_NAME, EMAIL_ADDRESS, and URI\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"int64Value\"],\n              properties: {\n                int64Value: {\n                  description: \"Used for values of type INT64\",\n                  type: \"integer\",\n                  format: \"int64\",\n                },\n              },\n            },\n            {\n              required: [\"doubleValue\"],\n              properties: {\n                doubleValue: {\n                  description: \"Used for values of type DOUBLE\",\n                  type: \"number\",\n                  format: \"double\",\n                },\n              },\n            },\n            {\n              required: [\"boolValue\"],\n              properties: {\n                boolValue: {\n                  description: \"Used for values of type BOOL\",\n                  type: \"boolean\",\n                },\n              },\n            },\n            {\n              required: [\"bytesValue\"],\n              properties: {\n                bytesValue: {\n                  description: \"Used for values of type BYTES\",\n                  type: \"string\",\n                  format: \"binary\",\n                },\n              },\n            },\n            {\n              required: [\"timestampValue\"],\n              properties: {\n                timestampValue: {\n                  description: \"Used for values of type TIMESTAMP\",\n                  type: \"string\",\n                  format: \"dateTime\",\n                },\n              },\n            },\n            {\n              required: [\"durationValue\"],\n              properties: {\n                durationValue: {\n                  description: \"Used for values of type DURATION\",\n                  type: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"stringMapValue\"],\n              properties: {\n                stringMapValue: {\n                  $ref:\n                    \"#/components/schemas/istio.mixer.v1.Attributes.StringMap\",\n                },\n              },\n            },\n          ],\n        },\n        \"istio.mixer.v1.Attributes.StringMap\": {\n          description: \"Defines a string map.\",\n          type: \"object\",\n          properties: {\n            entries: {\n              description: \"Holds a set of name/value pairs.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.mixer.v1.CompressedAttributes\": {\n          description:\n            \"Defines a list of attributes in compressed format optimized for transport. Within this message, strings are referenced using integer indices into one of two string dictionaries. Positive integers index into the global deployment-wide dictionary, whereas negative integers index into the message-level dictionary instead. The message-level dictionary is carried by the `words` field of this message, the deployment-wide dictionary is determined via configuration.\",\n          type: \"object\",\n          properties: {\n            strings: {\n              description:\n                \"Holds attributes of type STRING, DNS_NAME, EMAIL_ADDRESS, URI\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"integer\",\n                format: \"int32\",\n              },\n            },\n            bytes: {\n              description: \"Holds attributes of type BYTES\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"binary\",\n              },\n            },\n            words: {\n              description: \"The message-level dictionary.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            int64s: {\n              description: \"Holds attributes of type INT64\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"integer\",\n                format: \"int64\",\n              },\n            },\n            doubles: {\n              description: \"Holds attributes of type DOUBLE\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"number\",\n                format: \"double\",\n              },\n            },\n            bools: {\n              description: \"Holds attributes of type BOOL\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"boolean\",\n              },\n            },\n            timestamps: {\n              description: \"Holds attributes of type TIMESTAMP\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"dateTime\",\n              },\n            },\n            durations: {\n              description: \"Holds attributes of type DURATION\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n              },\n            },\n            stringMaps: {\n              description: \"Holds attributes of type STRING_MAP\",\n              type: \"object\",\n              additionalProperties: {\n                $ref: \"#/components/schemas/istio.mixer.v1.StringMap\",\n              },\n            },\n          },\n        },\n        \"istio.mixer.v1.StringMap\": {\n          description:\n            \"A map of string to string. The keys and values in this map are dictionary indices (see the [Attributes][istio.mixer.v1.CompressedAttributes] message for an explanation)\",\n          type: \"object\",\n          properties: {\n            entries: {\n              description: \"Holds a set of name/value pairs.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"integer\",\n                format: \"int32\",\n              },\n            },\n          },\n        },\n        \"istio.mixer.v1.CheckRequest\": {\n          description:\n            \"Used to get a thumbs-up/thumbs-down before performing an action.\",\n          type: \"object\",\n          properties: {\n            attributes: {\n              $ref: \"#/components/schemas/istio.mixer.v1.CompressedAttributes\",\n            },\n            globalWordCount: {\n              description:\n                \"The number of words in the global dictionary, used with to populate the attributes. This value is used as a quick way to determine whether the client is using a dictionary that the server understands.\",\n              type: \"integer\",\n            },\n            deduplicationId: {\n              description:\n                \"Used for deduplicating `Check` calls in the case of failed RPCs and retries. This should be a UUID per call, where the same UUID is used for retries of the same call.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            quotas: {\n              description: \"The individual quotas to allocate\",\n              type: \"object\",\n              additionalProperties: {\n                $ref:\n                  \"#/components/schemas/istio.mixer.v1.CheckRequest.QuotaParams\",\n              },\n            },\n          },\n        },\n        \"istio.mixer.v1.CheckRequest.QuotaParams\": {\n          description: \"parameters for a quota allocation\",\n          type: \"object\",\n          properties: {\n            amount: {\n              description: \"Amount of quota to allocate\",\n              type: \"integer\",\n              format: \"int64\",\n            },\n            bestEffort: {\n              description:\n                \"When true, supports returning less quota than what was requested.\",\n              type: \"boolean\",\n            },\n          },\n        },\n        \"istio.mixer.v1.CheckResponse\": {\n          description: \"The response generated by the Check method.\",\n          type: \"object\",\n          properties: {\n            quotas: {\n              description:\n                \"The resulting quota, one entry per requested quota.\",\n              type: \"object\",\n              additionalProperties: {\n                $ref:\n                  \"#/components/schemas/istio.mixer.v1.CheckResponse.QuotaResult\",\n              },\n            },\n            precondition: {\n              $ref:\n                \"#/components/schemas/istio.mixer.v1.CheckResponse.PreconditionResult\",\n            },\n          },\n        },\n        \"istio.mixer.v1.CheckResponse.PreconditionResult\": {\n          description: \"Expresses the result of a precondition check.\",\n          type: \"object\",\n          properties: {\n            status: {\n              $ref: \"#/components/schemas/google.rpc.Status\",\n            },\n            validDuration: {\n              description:\n                \"The amount of time for which this result can be considered valid.\",\n              type: \"string\",\n            },\n            validUseCount: {\n              description:\n                \"The number of uses for which this result can be considered valid.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            referencedAttributes: {\n              $ref: \"#/components/schemas/istio.mixer.v1.ReferencedAttributes\",\n            },\n            routeDirective: {\n              $ref: \"#/components/schemas/istio.mixer.v1.RouteDirective\",\n            },\n          },\n        },\n        \"istio.mixer.v1.CheckResponse.QuotaResult\": {\n          description: \"Expresses the result of a quota allocation.\",\n          type: \"object\",\n          properties: {\n            status: {\n              $ref: \"#/components/schemas/google.rpc.Status\",\n            },\n            validDuration: {\n              description:\n                \"The amount of time for which this result can be considered valid.\",\n              type: \"string\",\n            },\n            referencedAttributes: {\n              $ref: \"#/components/schemas/istio.mixer.v1.ReferencedAttributes\",\n            },\n            grantedAmount: {\n              description:\n                \"The amount of granted quota. When `QuotaParams.best_effort` is true, this will be \\u003e= 0. If `QuotaParams.best_effort` is false, this will be either 0 or \\u003e= `QuotaParams.amount`.\",\n              type: \"integer\",\n              format: \"int64\",\n            },\n          },\n        },\n        \"istio.mixer.v1.ReferencedAttributes\": {\n          description:\n            \"Describes the attributes that were used to determine the response. This can be used to construct a response cache.\",\n          type: \"object\",\n          properties: {\n            words: {\n              description:\n                \"The message-level dictionary. Refer to [CompressedAttributes][istio.mixer.v1.CompressedAttributes] for information on using dictionaries.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            attributeMatches: {\n              description: \"Describes a set of attributes.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.mixer.v1.ReferencedAttributes.AttributeMatch\",\n              },\n            },\n          },\n        },\n        \"istio.mixer.v1.RouteDirective\": {\n          description:\n            \"Expresses the routing manipulation actions to be performed on behalf of Mixer in response to a precondition check.\",\n          type: \"object\",\n          properties: {\n            requestHeaderOperations: {\n              description: \"Operations on the request headers.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.mixer.v1.HeaderOperation\",\n              },\n            },\n            responseHeaderOperations: {\n              description: \"Operations on the response headers.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.mixer.v1.HeaderOperation\",\n              },\n            },\n            directResponseCode: {\n              description:\n                \"If set, enables a direct response without proxying the request to the routing destination. Required to be a value in the 2xx or 3xx range.\",\n              type: \"integer\",\n            },\n            directResponseBody: {\n              description:\n                \"Supplies the response body for the direct response. If this setting is omitted, no body is included in the generated response.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.mixer.v1.ReferencedAttributes.AttributeMatch\": {\n          description: \"Describes a single attribute match.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"The name of the attribute. This is a dictionary index encoded in a manner identical to all strings in the [CompressedAttributes][istio.mixer.v1.CompressedAttributes] message.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            condition: {\n              $ref:\n                \"#/components/schemas/istio.mixer.v1.ReferencedAttributes.Condition\",\n            },\n            regex: {\n              description:\n                \"If a REGEX condition is provided for a STRING_MAP attribute, clients should use the regex value to match against map keys. RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\",\n              type: \"string\",\n              format: \"string\",\n            },\n            mapKey: {\n              description:\n                \"A key in a STRING_MAP. When multiple keys from a STRING_MAP attribute were referenced, there will be multiple AttributeMatch messages with different map_key values. Values for map_key SHOULD be ignored for attributes that are not STRING_MAP.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n          },\n        },\n        \"istio.mixer.v1.ReferencedAttributes.Condition\": {\n          description: \"How an attribute's value was matched\",\n          type: \"string\",\n          enum: [\"CONDITION_UNSPECIFIED\", \"ABSENCE\", \"EXACT\", \"REGEX\"],\n        },\n        \"istio.mixer.v1.HeaderOperation\": {\n          description:\n            'Operation on HTTP headers to replace, append, or remove a header. Header names are normalized to lower-case with dashes, e.g. \"x-request-id\". Pseudo-headers \":path\", \":authority\", and \":method\" are supported to modify the request headers.',\n          type: \"object\",\n          properties: {\n            name: {\n              description: \"Header name.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            value: {\n              description: \"Header value.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            operation: {\n              $ref:\n                \"#/components/schemas/istio.mixer.v1.HeaderOperation.Operation\",\n            },\n          },\n        },\n        \"istio.mixer.v1.HeaderOperation.Operation\": {\n          description: \"Operation type.\",\n          type: \"string\",\n          enum: [\"REPLACE\", \"REMOVE\", \"APPEND\"],\n        },\n        \"istio.mixer.v1.ReportRequest\": {\n          description:\n            \"Used to report telemetry after performing one or more actions.\",\n          type: \"object\",\n          properties: {\n            attributes: {\n              description: \"next value: 5\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.mixer.v1.CompressedAttributes\",\n              },\n            },\n            globalWordCount: {\n              description:\n                \"The number of words in the global dictionary. To detect global dictionary out of sync between client and server.\",\n              type: \"integer\",\n            },\n            repeatedAttributesSemantics: {\n              $ref:\n                \"#/components/schemas/istio.mixer.v1.ReportRequest.RepeatedAttributesSemantics\",\n            },\n            defaultWords: {\n              description:\n                \"The default message-level dictionary for all the attributes. Individual attribute messages can have their own dictionaries, but if they don't then this set of words, if it is provided, is used instead.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.mixer.v1.ReportRequest.RepeatedAttributesSemantics\": {\n          description:\n            \"Used to signal how the sets of compressed attributes should be reconstituted server-side.\",\n          type: \"string\",\n          enum: [\"DELTA_ENCODING\", \"INDEPENDENT_ENCODING\"],\n        },\n        \"istio.mixer.v1.ReportResponse\": {\n          description: \"Used to carry responses to telemetry reports\",\n          type: \"object\",\n        },\n        \"google.rpc.Status\": {\n          description:\n            \"A status code of OK indicates quota was fetched successfully. Any other code indicates error in fetching quota.\",\n          type: \"object\",\n          properties: {\n            code: {\n              description:\n                \"The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            message: {\n              description:\n                \"A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            details: {\n              description:\n                \"A list of messages that carry the error details. There is a common set of message types for APIs to use.\",\n              type: \"array\",\n              items: {\n                type: \"object\",\n                required: [\"@type\"],\n                properties: {\n                  \"@type\": {\n                    description:\n                      'A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\\'s path must represent the fully qualified name of the type (as in `type.googleapis.com/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). The remaining fields of this object correspond to fields of the proto messsage. If the embedded message is well-known and has a custom JSON representation, that representation is assigned to the \\'value\\' field.',\n                    type: \"string\",\n                    format: \"string\",\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Configuration state for the Mixer client library.\",\n      version: \"client\",\n    },\n    components: {\n      schemas: {\n        \"istio.mixer.v1.config.client.HTTPAPISpec\": {\n          description:\n            \"HTTPAPISpec defines the canonical configuration for generating API-related attributes from HTTP requests based on the method and uri templated path matches. It is sufficient for defining the API surface of a service for the purposes of API attribute generation. It is not intended to represent auth, quota, documentation, or other information commonly found in other API specifications, e.g. OpenAPI.\",\n          type: \"object\",\n          properties: {\n            attributes: {\n              $ref: \"#/components/schemas/istio.mixer.v1.Attributes\",\n            },\n            patterns: {\n              description: \"List of HTTP patterns to match.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.mixer.v1.config.client.HTTPAPISpecPattern\",\n              },\n            },\n            apiKeys: {\n              description:\n                \"List of APIKey that describes how to extract an API-KEY from an HTTP request. The first API-Key match found in the list is used, i.e. 'OR' semantics.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.mixer.v1.config.client.APIKey\",\n              },\n            },\n          },\n        },\n        \"istio.mixer.v1.config.client.HTTPAPISpecPattern\": {\n          description:\n            \"HTTPAPISpecPattern defines a single pattern to match against incoming HTTP requests. The per-pattern list of attributes is generated if both the http_method and uri_template match. In addition, the top-level list of attributes in the HTTPAPISpec is also generated.\",\n          type: \"object\",\n          properties: {\n            attributes: {\n              $ref: \"#/components/schemas/istio.mixer.v1.Attributes\",\n            },\n            httpMethod: {\n              description:\n                \"HTTP request method to match against as defined by [rfc7231](https://tools.ietf.org/html/rfc7231#page-21). For example: GET, HEAD, POST, PUT, DELETE.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"uriTemplate\"],\n                    properties: {\n                      uriTemplate: {\n                        description:\n                          \"URI template to match against as defined by [rfc6570](https://tools.ietf.org/html/rfc6570). For example, the following are valid URI templates: /pets /pets/{id} /dictionary/{term:1}/{term} /search{?q*,lang}\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"regex\"],\n                    properties: {\n                      regex: {\n                        description:\n                          \"RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax)\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"uriTemplate\"],\n              properties: {\n                uriTemplate: {\n                  description:\n                    \"URI template to match against as defined by [rfc6570](https://tools.ietf.org/html/rfc6570). For example, the following are valid URI templates: /pets /pets/{id} /dictionary/{term:1}/{term} /search{?q*,lang}\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"regex\"],\n              properties: {\n                regex: {\n                  description:\n                    \"RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax)\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n          ],\n        },\n        \"istio.mixer.v1.config.client.APIKey\": {\n          description:\n            \"APIKey defines the explicit configuration for generating the `request.api_key` attribute from HTTP requests.\",\n          type: \"object\",\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"query\"],\n                    properties: {\n                      query: {\n                        description:\n                          \"API Key is sent as a query parameter. `query` represents the query string parameter name.\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"header\"],\n                    properties: {\n                      header: {\n                        description:\n                          \"API key is sent in a request header. `header` represents the header name.\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"cookie\"],\n                    properties: {\n                      cookie: {\n                        description:\n                          \"API key is sent in a [cookie](https://swagger.io/docs/specification/authentication/cookie-authentication),\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"query\"],\n              properties: {\n                query: {\n                  description:\n                    \"API Key is sent as a query parameter. `query` represents the query string parameter name.\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"header\"],\n              properties: {\n                header: {\n                  description:\n                    \"API key is sent in a request header. `header` represents the header name.\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"cookie\"],\n              properties: {\n                cookie: {\n                  description:\n                    \"API key is sent in a [cookie](https://swagger.io/docs/specification/authentication/cookie-authentication),\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n          ],\n        },\n        \"istio.mixer.v1.config.client.HTTPAPISpecReference\": {\n          description:\n            \"HTTPAPISpecReference defines a reference to an HTTPAPISpec. This is typically used for establishing bindings between an HTTPAPISpec and an IstioService. For example, the following defines an HTTPAPISpecReference for service `foo` in namespace `bar`.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"The short name of the HTTPAPISpec. This is the resource name defined by the metadata name field.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            namespace: {\n              description:\n                \"Optional namespace of the HTTPAPISpec. Defaults to the encompassing HTTPAPISpecBinding's metadata namespace field.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.mixer.v1.config.client.HTTPAPISpecBinding\": {\n          description:\n            \"HTTPAPISpecBinding defines the binding between HTTPAPISpecs and one or more IstioService. For example, the following establishes a binding between the HTTPAPISpec `petstore` and service `foo` in namespace `bar`.\",\n          type: \"object\",\n          properties: {\n            services: {\n              description:\n                \"One or more services to map the listed HTTPAPISpec onto.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.mixer.v1.config.client.IstioService\",\n              },\n            },\n            apiSpecs: {\n              description:\n                \"One or more HTTPAPISpec references that should be mapped to the specified service(s). The aggregate collection of match conditions defined in the HTTPAPISpecs should not overlap.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.mixer.v1.config.client.HTTPAPISpecReference\",\n              },\n            },\n          },\n        },\n        \"istio.mixer.v1.config.client.IstioService\": {\n          description:\n            'IstioService identifies a service and optionally service version. The FQDN of the service is composed from the name, namespace, and implementation-specific domain suffix (e.g. on Kubernetes, \"reviews\" + \"default\" + \"svc.cluster.local\" -\\u003e \"reviews.default.svc.cluster.local\").',\n          type: \"object\",\n          properties: {\n            name: {\n              description: 'The short name of the service such as \"foo\".',\n              type: \"string\",\n              format: \"string\",\n            },\n            namespace: {\n              description:\n                \"Optional namespace of the service. Defaults to value of metadata namespace field.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            domain: {\n              description:\n                \"Domain suffix used to construct the service FQDN in implementations that support such specification.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            service: {\n              description: \"The service FQDN.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            labels: {\n              description:\n                \"Optional one or more labels that uniquely identify the service version.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.mixer.v1.config.client.NetworkFailPolicy\": {\n          description:\n            \"Specifies the behavior when the client is unable to connect to Mixer.\",\n          type: \"object\",\n          properties: {\n            policy: {\n              $ref:\n                \"#/components/schemas/istio.mixer.v1.config.client.NetworkFailPolicy.FailPolicy\",\n            },\n            maxRetry: {\n              description: \"Max retries on transport error.\",\n              type: \"integer\",\n            },\n            baseRetryWait: {\n              description:\n                \"Base time to wait between retries. Will be adjusted by exponential backoff and jitter.\",\n              type: \"string\",\n            },\n            maxRetryWait: {\n              description: \"Max time to wait between retries.\",\n              type: \"string\",\n            },\n          },\n        },\n        \"istio.mixer.v1.config.client.NetworkFailPolicy.FailPolicy\": {\n          description: \"Describes the policy.\",\n          type: \"string\",\n          enum: [\"FAIL_OPEN\", \"FAIL_CLOSE\"],\n        },\n        \"istio.mixer.v1.config.client.ServiceConfig\": {\n          description: \"Defines the per-service client configuration.\",\n          type: \"object\",\n          properties: {\n            disableCheckCalls: {\n              description: \"If true, do not call Mixer Check.\",\n              type: \"boolean\",\n            },\n            disableReportCalls: {\n              description: \"If true, do not call Mixer Report.\",\n              type: \"boolean\",\n            },\n            mixerAttributes: {\n              $ref: \"#/components/schemas/istio.mixer.v1.Attributes\",\n            },\n            httpApiSpec: {\n              description:\n                \"HTTP API specifications to generate API attributes.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.mixer.v1.config.client.HTTPAPISpec\",\n              },\n            },\n            quotaSpec: {\n              description:\n                \"Quota specifications to generate quota requirements.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.mixer.v1.config.client.QuotaSpec\",\n              },\n            },\n            networkFailPolicy: {\n              $ref:\n                \"#/components/schemas/istio.mixer.v1.config.client.NetworkFailPolicy\",\n            },\n            forwardAttributes: {\n              $ref: \"#/components/schemas/istio.mixer.v1.Attributes\",\n            },\n          },\n        },\n        \"istio.mixer.v1.config.client.QuotaSpec\": {\n          description: \"Determines the quotas used for individual requests.\",\n          type: \"object\",\n          properties: {\n            rules: {\n              description: \"A list of Quota rules.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.mixer.v1.config.client.QuotaRule\",\n              },\n            },\n          },\n        },\n        \"istio.mixer.v1.config.client.TransportConfig\": {\n          description: \"Defines the transport config on how to call Mixer.\",\n          type: \"object\",\n          properties: {\n            networkFailPolicy: {\n              $ref:\n                \"#/components/schemas/istio.mixer.v1.config.client.NetworkFailPolicy\",\n            },\n            disableCheckCache: {\n              description: \"The flag to disable check cache.\",\n              type: \"boolean\",\n            },\n            disableQuotaCache: {\n              description: \"The flag to disable quota cache.\",\n              type: \"boolean\",\n            },\n            disableReportBatch: {\n              description: \"The flag to disable report batch.\",\n              type: \"boolean\",\n            },\n            statsUpdateInterval: {\n              description:\n                \"Specify refresh interval to write Mixer client statistics to Envoy share memory. If not specified, the interval is 10 seconds.\",\n              type: \"string\",\n            },\n            checkCluster: {\n              description:\n                'Name of the cluster that will forward check calls to a pool of mixer servers. Defaults to \"mixer_server\". By using different names for checkCluster and reportCluster, it is possible to have one set of Mixer servers handle check calls, while another set of Mixer servers handle report calls.',\n              type: \"string\",\n              format: \"string\",\n            },\n            reportCluster: {\n              description:\n                'Name of the cluster that will forward report calls to a pool of mixer servers. Defaults to \"mixer_server\". By using different names for checkCluster and reportCluster, it is possible to have one set of Mixer servers handle check calls, while another set of Mixer servers handle report calls.',\n              type: \"string\",\n              format: \"string\",\n            },\n            attributesForMixerProxy: {\n              $ref: \"#/components/schemas/istio.mixer.v1.Attributes\",\n            },\n            reportBatchMaxEntries: {\n              description:\n                \"When disable_report_batch is false, this value specifies the maximum number of requests that are batched in report. If left unspecified, the default value of report_batch_max_entries == 0 will use the hardcoded defaults of istio::mixerclient::ReportOptions.\",\n              type: \"integer\",\n            },\n            reportBatchMaxTime: {\n              description:\n                \"When disable_report_batch is false, this value specifies the maximum elapsed time a batched report will be sent after a user request is processed. If left unspecified, the default report_batch_max_time == 0 will use the hardcoded defaults of istio::mixerclient::ReportOptions.\",\n              type: \"string\",\n            },\n          },\n        },\n        \"istio.mixer.v1.config.client.HttpClientConfig\": {\n          description: \"Defines the client config for HTTP.\",\n          type: \"object\",\n          properties: {\n            mixerAttributes: {\n              $ref: \"#/components/schemas/istio.mixer.v1.Attributes\",\n            },\n            forwardAttributes: {\n              $ref: \"#/components/schemas/istio.mixer.v1.Attributes\",\n            },\n            transport: {\n              $ref:\n                \"#/components/schemas/istio.mixer.v1.config.client.TransportConfig\",\n            },\n            serviceConfigs: {\n              description:\n                \"Map of control configuration indexed by destination.service. This is used to support per-service configuration for cases where a mixerclient serves multiple services.\",\n              type: \"object\",\n              additionalProperties: {\n                $ref:\n                  \"#/components/schemas/istio.mixer.v1.config.client.ServiceConfig\",\n              },\n            },\n            defaultDestinationService: {\n              description:\n                \"Default destination service name if none was specified in the client request.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            ignoreForwardedAttributes: {\n              description:\n                'Whether or not to use attributes forwarded in the request headers to create the attribute bag to send to mixer. For intra-mesh traffic, this should be set to \"false\". For ingress/egress gateways, this should be set to \"true\".',\n              type: \"boolean\",\n            },\n          },\n        },\n        \"istio.mixer.v1.config.client.TcpClientConfig\": {\n          description: \"Defines the client config for TCP.\",\n          type: \"object\",\n          properties: {\n            disableCheckCalls: {\n              description: \"If set to true, disables Mixer check calls.\",\n              type: \"boolean\",\n            },\n            disableReportCalls: {\n              description: \"If set to true, disables Mixer check calls.\",\n              type: \"boolean\",\n            },\n            mixerAttributes: {\n              $ref: \"#/components/schemas/istio.mixer.v1.Attributes\",\n            },\n            transport: {\n              $ref:\n                \"#/components/schemas/istio.mixer.v1.config.client.TransportConfig\",\n            },\n            connectionQuotaSpec: {\n              $ref:\n                \"#/components/schemas/istio.mixer.v1.config.client.QuotaSpec\",\n            },\n            reportInterval: {\n              description:\n                \"Specify report interval to send periodical reports for long TCP connections. If not specified, the interval is 10 seconds. This interval should not be less than 1 second, otherwise it will be reset to 1 second.\",\n              type: \"string\",\n            },\n          },\n        },\n        \"istio.mixer.v1.config.client.QuotaRule\": {\n          description:\n            \"Specifies a rule with list of matches and list of quotas. If any clause matched, the list of quotas will be used.\",\n          type: \"object\",\n          properties: {\n            quotas: {\n              description: \"The list of quotas to charge.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.mixer.v1.config.client.Quota\",\n              },\n            },\n            match: {\n              description:\n                \"If empty, match all request. If any of match is true, it is matched.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.mixer.v1.config.client.AttributeMatch\",\n              },\n            },\n          },\n        },\n        \"istio.mixer.v1.config.client.AttributeMatch\": {\n          description: \"Specifies a match clause to match Istio attributes\",\n          type: \"object\",\n          properties: {\n            clause: {\n              description:\n                \"Map of attribute names to StringMatch type. Each map element specifies one condition to match.\",\n              type: \"object\",\n              additionalProperties: {\n                $ref:\n                  \"#/components/schemas/istio.mixer.v1.config.client.StringMatch\",\n              },\n            },\n          },\n        },\n        \"istio.mixer.v1.config.client.Quota\": {\n          description: \"Specifies a quota to use with quota name and amount.\",\n          type: \"object\",\n          properties: {\n            quota: {\n              description: \"The quota name to charge\",\n              type: \"string\",\n              format: \"string\",\n            },\n            charge: {\n              description: \"The quota amount to charge\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n          },\n        },\n        \"istio.mixer.v1.config.client.StringMatch\": {\n          description:\n            \"Describes how to match a given string in HTTP headers. Match is case-sensitive.\",\n          type: \"object\",\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"exact\"],\n                    properties: {\n                      exact: {\n                        description: \"exact string match\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"prefix\"],\n                    properties: {\n                      prefix: {\n                        description: \"prefix-based match\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"regex\"],\n                    properties: {\n                      regex: {\n                        description:\n                          \"RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"exact\"],\n              properties: {\n                exact: {\n                  description: \"exact string match\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"prefix\"],\n              properties: {\n                prefix: {\n                  description: \"prefix-based match\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"regex\"],\n              properties: {\n                regex: {\n                  description:\n                    \"RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n          ],\n        },\n        \"istio.mixer.v1.config.client.QuotaSpecBinding\": {\n          description:\n            \"QuotaSpecBinding defines the binding between QuotaSpecs and one or more IstioService.\",\n          type: \"object\",\n          properties: {\n            services: {\n              description:\n                \"One or more services to map the listed QuotaSpec onto.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.mixer.v1.config.client.IstioService\",\n              },\n            },\n            quotaSpecs: {\n              description:\n                \"One or more QuotaSpec references that should be mapped to the specified service(s). The aggregate collection of match conditions defined in the QuotaSpecs should not overlap.\",\n              type: \"array\",\n              items: {\n                $ref:\n                  \"#/components/schemas/istio.mixer.v1.config.client.QuotaSpecBinding.QuotaSpecReference\",\n              },\n            },\n          },\n        },\n        \"istio.mixer.v1.config.client.QuotaSpecBinding.QuotaSpecReference\": {\n          description:\n            \"QuotaSpecReference uniquely identifies the QuotaSpec used in the Binding.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"The short name of the QuotaSpec. This is the resource name defined by the metadata name field.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            namespace: {\n              description:\n                \"Optional namespace of the QuotaSpec. Defaults to the value of the metadata namespace field.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.mixer.v1.Attributes\": {\n          description:\n            'Default attributes to send to Mixer in both Check and Report. This typically includes \"destination.ip\" and \"destination.uid\" attributes.',\n          type: \"object\",\n          properties: {\n            attributes: {\n              description: \"A map of attribute name to its value.\",\n              type: \"object\",\n              additionalProperties: {\n                $ref:\n                  \"#/components/schemas/istio.mixer.v1.Attributes.AttributeValue\",\n              },\n            },\n          },\n        },\n        \"istio.mixer.v1.Attributes.AttributeValue\": {\n          type: \"object\",\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"stringValue\"],\n                    properties: {\n                      stringValue: {\n                        description:\n                          \"Used for values of type STRING, DNS_NAME, EMAIL_ADDRESS, and URI\",\n                        type: \"string\",\n                        format: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"int64Value\"],\n                    properties: {\n                      int64Value: {\n                        description: \"Used for values of type INT64\",\n                        type: \"integer\",\n                        format: \"int64\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"doubleValue\"],\n                    properties: {\n                      doubleValue: {\n                        description: \"Used for values of type DOUBLE\",\n                        type: \"number\",\n                        format: \"double\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"boolValue\"],\n                    properties: {\n                      boolValue: {\n                        description: \"Used for values of type BOOL\",\n                        type: \"boolean\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"bytesValue\"],\n                    properties: {\n                      bytesValue: {\n                        description: \"Used for values of type BYTES\",\n                        type: \"string\",\n                        format: \"binary\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"timestampValue\"],\n                    properties: {\n                      timestampValue: {\n                        description: \"Used for values of type TIMESTAMP\",\n                        type: \"string\",\n                        format: \"dateTime\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"durationValue\"],\n                    properties: {\n                      durationValue: {\n                        description: \"Used for values of type DURATION\",\n                        type: \"string\",\n                      },\n                    },\n                  },\n                  {\n                    required: [\"stringMapValue\"],\n                    properties: {\n                      stringMapValue: {\n                        $ref:\n                          \"#/components/schemas/istio.mixer.v1.Attributes.StringMap\",\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"stringValue\"],\n              properties: {\n                stringValue: {\n                  description:\n                    \"Used for values of type STRING, DNS_NAME, EMAIL_ADDRESS, and URI\",\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"int64Value\"],\n              properties: {\n                int64Value: {\n                  description: \"Used for values of type INT64\",\n                  type: \"integer\",\n                  format: \"int64\",\n                },\n              },\n            },\n            {\n              required: [\"doubleValue\"],\n              properties: {\n                doubleValue: {\n                  description: \"Used for values of type DOUBLE\",\n                  type: \"number\",\n                  format: \"double\",\n                },\n              },\n            },\n            {\n              required: [\"boolValue\"],\n              properties: {\n                boolValue: {\n                  description: \"Used for values of type BOOL\",\n                  type: \"boolean\",\n                },\n              },\n            },\n            {\n              required: [\"bytesValue\"],\n              properties: {\n                bytesValue: {\n                  description: \"Used for values of type BYTES\",\n                  type: \"string\",\n                  format: \"binary\",\n                },\n              },\n            },\n            {\n              required: [\"timestampValue\"],\n              properties: {\n                timestampValue: {\n                  description: \"Used for values of type TIMESTAMP\",\n                  type: \"string\",\n                  format: \"dateTime\",\n                },\n              },\n            },\n            {\n              required: [\"durationValue\"],\n              properties: {\n                durationValue: {\n                  description: \"Used for values of type DURATION\",\n                  type: \"string\",\n                },\n              },\n            },\n            {\n              required: [\"stringMapValue\"],\n              properties: {\n                stringMapValue: {\n                  $ref:\n                    \"#/components/schemas/istio.mixer.v1.Attributes.StringMap\",\n                },\n              },\n            },\n          ],\n        },\n        \"istio.mixer.v1.Attributes.StringMap\": {\n          description: \"Used for values of type STRING_MAP\",\n          type: \"object\",\n          properties: {\n            entries: {\n              description: \"Holds a set of name/value pairs.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Definitions used to create adapters and templates.\",\n      version: \"v1beta1\",\n    },\n    components: {\n      schemas: {\n        \"istio.mixer.adapter.model.v1beta1.CheckResult\": {\n          description: \"Expresses the result of a precondition check.\",\n          type: \"object\",\n          properties: {\n            status: {\n              $ref: \"#/components/schemas/google.rpc.Status\",\n            },\n            validDuration: {\n              description:\n                \"The amount of time for which this result can be considered valid.\",\n              type: \"string\",\n            },\n            validUseCount: {\n              description:\n                \"The number of uses for which this result can be considered valid.\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n          },\n        },\n        \"istio.mixer.adapter.model.v1beta1.TemplateVariety\": {\n          description:\n            \"The available varieties of templates, controlling the semantics of what an adapter does with each instance.\",\n          type: \"string\",\n          enum: [\n            \"TEMPLATE_VARIETY_CHECK\",\n            \"TEMPLATE_VARIETY_REPORT\",\n            \"TEMPLATE_VARIETY_QUOTA\",\n            \"TEMPLATE_VARIETY_ATTRIBUTE_GENERATOR\",\n            \"TEMPLATE_VARIETY_CHECK_WITH_OUTPUT\",\n          ],\n        },\n        \"istio.mixer.adapter.model.v1beta1.Info\": {\n          description:\n            \"Info describes an adapter or a backend that wants to provide telemetry and policy functionality to Mixer as an out of process adapter.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"Name of the adapter. It must be an RFC 1035 compatible DNS label matching the `^[a-z]([-a-z0-9]*[a-z0-9])?$` regular expression. Name is used in Istio configuration, therefore it should be descriptive but short. example: denier Vendor adapters should use a vendor prefix. example: mycompany-denier\",\n              type: \"string\",\n              format: \"string\",\n            },\n            description: {\n              description: \"User-friendly description of the adapter.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            templates: {\n              description: \"Names of the templates the adapter supports.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            config: {\n              description:\n                \"Base64 encoded proto descriptor of the adapter configuration.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            sessionBased: {\n              description:\n                \"True if backend has implemented the [InfrastructureBackend](https://github.com/istio/api/blob/master/mixer/adapter/model/v1beta1/infrastructure_backend.proto) service; false otherwise.\",\n              type: \"boolean\",\n            },\n          },\n        },\n        \"istio.mixer.adapter.model.v1beta1.CreateSessionRequest\": {\n          description: \"Request message for `CreateSession` method.\",\n          type: \"object\",\n          properties: {\n            adapterConfig: {\n              description: \"Adapter specific configuration.\",\n              type: \"object\",\n              required: [\"@type\"],\n              properties: {\n                \"@type\": {\n                  description:\n                    'A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\\'s path must represent the fully qualified name of the type (as in `type.googleapis.com/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). The remaining fields of this object correspond to fields of the proto messsage. If the embedded message is well-known and has a custom JSON representation, that representation is assigned to the \\'value\\' field.',\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            inferredTypes: {\n              description:\n                \"Map of instance names to their template-specific inferred type.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"object\",\n                required: [\"@type\"],\n                properties: {\n                  \"@type\": {\n                    description:\n                      'A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\\'s path must represent the fully qualified name of the type (as in `type.googleapis.com/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). The remaining fields of this object correspond to fields of the proto messsage. If the embedded message is well-known and has a custom JSON representation, that representation is assigned to the \\'value\\' field.',\n                    type: \"string\",\n                    format: \"string\",\n                  },\n                },\n              },\n            },\n          },\n        },\n        \"istio.mixer.adapter.model.v1beta1.CreateSessionResponse\": {\n          description: \"Response message for `CreateSession` method.\",\n          type: \"object\",\n          properties: {\n            status: {\n              $ref: \"#/components/schemas/google.rpc.Status\",\n            },\n            sessionId: {\n              description: \"Id of the created session.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.mixer.adapter.model.v1beta1.ValidateRequest\": {\n          description: \"Request message for `Validate` method.\",\n          type: \"object\",\n          properties: {\n            adapterConfig: {\n              description: \"Adapter specific configuration.\",\n              type: \"object\",\n              required: [\"@type\"],\n              properties: {\n                \"@type\": {\n                  description:\n                    'A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\\'s path must represent the fully qualified name of the type (as in `type.googleapis.com/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). The remaining fields of this object correspond to fields of the proto messsage. If the embedded message is well-known and has a custom JSON representation, that representation is assigned to the \\'value\\' field.',\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            inferredTypes: {\n              description:\n                \"Map of instance names to their template-specific inferred type.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"object\",\n                required: [\"@type\"],\n                properties: {\n                  \"@type\": {\n                    description:\n                      'A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\\'s path must represent the fully qualified name of the type (as in `type.googleapis.com/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). The remaining fields of this object correspond to fields of the proto messsage. If the embedded message is well-known and has a custom JSON representation, that representation is assigned to the \\'value\\' field.',\n                    type: \"string\",\n                    format: \"string\",\n                  },\n                },\n              },\n            },\n          },\n        },\n        \"istio.mixer.adapter.model.v1beta1.ValidateResponse\": {\n          description: \"Response message for `Validate` method.\",\n          type: \"object\",\n          properties: {\n            status: {\n              $ref: \"#/components/schemas/google.rpc.Status\",\n            },\n          },\n        },\n        \"istio.mixer.adapter.model.v1beta1.CloseSessionRequest\": {\n          description: \"Request message for `CloseSession` method.\",\n          type: \"object\",\n          properties: {\n            sessionId: {\n              description: \"Id of the session to be closed.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.mixer.adapter.model.v1beta1.CloseSessionResponse\": {\n          description: \"Response message for `CloseSession` method.\",\n          type: \"object\",\n          properties: {\n            status: {\n              $ref: \"#/components/schemas/google.rpc.Status\",\n            },\n          },\n        },\n        \"istio.mixer.adapter.model.v1beta1.QuotaRequest\": {\n          description: \"Expresses the quota allocation request.\",\n          type: \"object\",\n          properties: {\n            quotas: {\n              description: \"The individual quotas to allocate\",\n              type: \"object\",\n              additionalProperties: {\n                $ref:\n                  \"#/components/schemas/istio.mixer.adapter.model.v1beta1.QuotaRequest.QuotaParams\",\n              },\n            },\n          },\n        },\n        \"istio.mixer.adapter.model.v1beta1.QuotaRequest.QuotaParams\": {\n          description: \"parameters for a quota allocation\",\n          type: \"object\",\n          properties: {\n            amount: {\n              description: \"Amount of quota to allocate\",\n              type: \"integer\",\n              format: \"int64\",\n            },\n            bestEffort: {\n              description:\n                \"When true, supports returning less quota than what was requested.\",\n              type: \"boolean\",\n            },\n          },\n        },\n        \"istio.mixer.adapter.model.v1beta1.QuotaResult\": {\n          description: \"Expresses the result of multiple quota allocations.\",\n          type: \"object\",\n          properties: {\n            quotas: {\n              description:\n                \"The resulting quota, one entry per requested quota.\",\n              type: \"object\",\n              additionalProperties: {\n                $ref:\n                  \"#/components/schemas/istio.mixer.adapter.model.v1beta1.QuotaResult.Result\",\n              },\n            },\n          },\n        },\n        \"istio.mixer.adapter.model.v1beta1.QuotaResult.Result\": {\n          description: \"Expresses the result of a quota allocation.\",\n          type: \"object\",\n          properties: {\n            status: {\n              $ref: \"#/components/schemas/google.rpc.Status\",\n            },\n            validDuration: {\n              description:\n                \"The amount of time for which this result can be considered valid.\",\n              type: \"string\",\n            },\n            grantedAmount: {\n              description:\n                \"The amount of granted quota. When `QuotaParams.best_effort` is true, this will be \\u003e= 0. If `QuotaParams.best_effort` is false, this will be either 0 or \\u003e= `QuotaParams.amount`.\",\n              type: \"integer\",\n              format: \"int64\",\n            },\n          },\n        },\n        \"istio.mixer.adapter.model.v1beta1.ReportResult\": {\n          description: \"Expresses the result of a report call.\",\n          type: \"object\",\n        },\n        \"istio.mixer.adapter.model.v1beta1.Template\": {\n          description: \"Template provides the details of a Mixer template.\",\n          type: \"object\",\n          properties: {\n            descriptor: {\n              description: \"Base64 encoded proto descriptor of the template.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"google.rpc.Status\": {\n          description:\n            \"A status code of OK indicates quota was fetched successfully. Any other code indicates error in fetching quota.\",\n          type: \"object\",\n          properties: {\n            code: {\n              description:\n                \"The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            message: {\n              description:\n                \"A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            details: {\n              description:\n                \"A list of messages that carry the error details. There is a common set of message types for APIs to use.\",\n              type: \"array\",\n              items: {\n                type: \"object\",\n                required: [\"@type\"],\n                properties: {\n                  \"@type\": {\n                    description:\n                      'A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\\'s path must represent the fully qualified name of the type (as in `type.googleapis.com/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). The remaining fields of this object correspond to fields of the proto messsage. If the embedded message is well-known and has a custom JSON representation, that representation is assigned to the \\'value\\' field.',\n                    type: \"string\",\n                    format: \"string\",\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n    },\n  },\n  {\n    openapi: \"3.0.0\",\n    info: {\n      title:\n        \"This package defines the common, core types used by the Mesh Configuration Protocol.\",\n      version: \"v1alpha1\",\n    },\n    components: {\n      schemas: {\n        \"istio.mcp.v1alpha1.SinkNode\": {\n          description:\n            \"Identifies a specific MCP sink node instance. The node identifier is presented to the resource source, which may use this identifier to distinguish per sink configuration for serving. This information is not authoritative. Authoritative identity should come from the underlying transport layer (e.g. rpc credentials).\",\n          type: \"object\",\n          properties: {\n            id: {\n              description: \"An opaque identifier for the MCP node.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            annotations: {\n              description: \"Opaque annotations extending the node identifier.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.mcp.v1alpha1.MeshConfigRequest\": {\n          description:\n            \"A MeshConfigRequest requests a set of versioned resources of the same type for a given client.\",\n          type: \"object\",\n          properties: {\n            versionInfo: {\n              description:\n                \"The version_info provided in the request messages will be the version_info received with the most recent successfully processed response or empty on the first request. It is expected that no new request is sent after a response is received until the client instance is ready to ACK/NACK the new configuration. ACK/NACK takes place by returning the new API config version as applied or the previous API config version respectively. Each type_url (see below) has an independent version associated with it.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            sinkNode: {\n              $ref: \"#/components/schemas/istio.mcp.v1alpha1.SinkNode\",\n            },\n            typeUrl: {\n              description:\n                'Type of the resource that is being requested, e.g. \"type.googleapis.com/istio.io.networking.v1alpha3.VirtualService\".',\n              type: \"string\",\n              format: \"string\",\n            },\n            responseNonce: {\n              description:\n                \"The nonce corresponding to MeshConfigResponse being ACK/NACKed. See above discussion on version_info and the MeshConfigResponse nonce comment. This may be empty if no nonce is available, e.g. at startup.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            errorDetail: {\n              $ref: \"#/components/schemas/google.rpc.Status\",\n            },\n          },\n        },\n        \"istio.mcp.v1alpha1.MeshConfigResponse\": {\n          description:\n            \"A MeshConfigResponse delivers a set of versioned resources of the same type in response to a MeshConfigRequest.\",\n          type: \"object\",\n          properties: {\n            versionInfo: {\n              description: \"The version of the response data.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            typeUrl: {\n              description:\n                \"Type URL for resources wrapped in the provided resources(s). This must be consistent with the type_url in the wrapper messages if resources is non-empty.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            resources: {\n              description:\n                \"The response resources wrapped in the common MCP *Resource* message.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.mcp.v1alpha1.Resource\",\n              },\n            },\n            nonce: {\n              description:\n                \"The nonce provides a way to explicitly ack a specific MeshConfigResponse in a following MeshConfigRequest. Additional messages may have been sent by client to the management server for the previous version on the stream prior to this MeshConfigResponse, that were unprocessed at response send time. The nonce allows the management server to ignore any further MeshConfigRequests for the previous version until a MeshConfigRequest bearing the nonce.\",\n              type: \"string\",\n              format: \"string\",\n            },\n          },\n        },\n        \"istio.mcp.v1alpha1.Resource\": {\n          description:\n            \"Resource as transferred via the Mesh Configuration Protocol. Each resource is made up of common metadata, and a type-specific resource payload.\",\n          type: \"object\",\n          properties: {\n            body: {\n              description: \"The primary payload for the resource.\",\n              type: \"object\",\n              required: [\"@type\"],\n              properties: {\n                \"@type\": {\n                  description:\n                    'A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\\'s path must represent the fully qualified name of the type (as in `type.googleapis.com/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). The remaining fields of this object correspond to fields of the proto messsage. If the embedded message is well-known and has a custom JSON representation, that representation is assigned to the \\'value\\' field.',\n                  type: \"string\",\n                  format: \"string\",\n                },\n              },\n            },\n            metadata: {\n              $ref: \"#/components/schemas/istio.mcp.v1alpha1.Metadata\",\n            },\n          },\n        },\n        \"istio.mcp.v1alpha1.IncrementalMeshConfigRequest\": {\n          description:\n            \"IncrementalMeshConfigRequest are be sent in 2 situations: 1. Initial message in a MCP bidirectional gRPC stream.\",\n          type: \"object\",\n          properties: {\n            sinkNode: {\n              $ref: \"#/components/schemas/istio.mcp.v1alpha1.SinkNode\",\n            },\n            typeUrl: {\n              description:\n                'Type of the resource that is being requested, e.g. \"type.googleapis.com/istio.io.networking.v1alpha3.VirtualService\".',\n              type: \"string\",\n              format: \"string\",\n            },\n            responseNonce: {\n              description:\n                \"When the IncrementalMeshConfigRequest is a ACK or NACK message in response to a previous IncrementalMeshConfigResponse, the response_nonce must be the nonce in the IncrementalMeshConfigResponse. Otherwise response_nonce must be omitted.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            errorDetail: {\n              $ref: \"#/components/schemas/google.rpc.Status\",\n            },\n            initialResourceVersions: {\n              description:\n                \"When the IncrementalMeshConfigRequest is the first in a stream, the initial_resource_versions must be populated. Otherwise, initial_resource_versions must be omitted. The keys are the resources names of the MCP resources known to the MCP client. The values in the map are the associated resource level version info.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.mcp.v1alpha1.IncrementalMeshConfigResponse\": {\n          description:\n            \"IncrementalMeshConfigResponses do not need to include a full snapshot of the tracked resources. Instead they are a diff to the state of a MCP client. Per resource versions allow servers and clients to track state at the resource granularity. An MCP incremental session is always in the context of a gRPC bidirectional stream. This allows the MCP server to keep track of the state of MCP clients connected to it.\",\n          type: \"object\",\n          properties: {\n            resources: {\n              description:\n                \"The response resources wrapped in the common MCP *Resource* message. These are typed resources that match the type url in the IncrementalMeshConfigRequest.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.mcp.v1alpha1.Resource\",\n              },\n            },\n            nonce: {\n              description:\n                \"The nonce provides a way for IncrementalMeshConfigRequests to uniquely reference an IncrementalMeshConfigResponse. The nonce is required.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            systemVersionInfo: {\n              description:\n                \"The version of the response data (used for debugging).\",\n              type: \"string\",\n              format: \"string\",\n            },\n            removedResources: {\n              description:\n                \"Resources names of resources that have be deleted and to be removed from the MCP Client. Removed resources for missing resources can be ignored.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"istio.mcp.v1alpha1.RequestResources\": {\n          description:\n            \"A RequestResource can be sent in two situations: Initial message in an MCP bidirectional change stream as an ACK or NACK response to a previous Resources. In this case the response_nonce is set to the nonce value in the Resources. ACK/NACK is determined by the presence of error_detail.\",\n          type: \"object\",\n          properties: {\n            sinkNode: {\n              $ref: \"#/components/schemas/istio.mcp.v1alpha1.SinkNode\",\n            },\n            responseNonce: {\n              description:\n                \"When the RequestResources is an ACK or NACK message in response to a previous RequestResources, the response_nonce must be the nonce in the RequestResources. Otherwise response_nonce must be omitted.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            errorDetail: {\n              $ref: \"#/components/schemas/google.rpc.Status\",\n            },\n            initialResourceVersions: {\n              description:\n                \"When the RequestResources is the first in a stream, the initial_resource_versions must be populated. Otherwise, initial_resource_versions must be omitted. The keys are the resources names of the MCP resources known to the MCP client. The values in the map are the associated resource level version info.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            collection: {\n              description:\n                \"Type of resource collection that is being requested, e.g.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            incremental: {\n              description:\n                \"Request an incremental update for the specified collection. The source may choose to honor this request or ignore and and provide a full-state update in the corresponding `Resource` response.\",\n              type: \"boolean\",\n            },\n          },\n        },\n        \"istio.mcp.v1alpha1.Resources\": {\n          description:\n            \"Resources do not need to include a full snapshot of the tracked resources. Instead they are a diff to the state of a MCP client. Per resource versions allow sources and sinks to track state at the resource granularity. An MCP incremental session is always in the context of a gRPC bidirectional stream. This allows the MCP source to keep track of the state of MCP sink connected to it.\",\n          type: \"object\",\n          properties: {\n            resources: {\n              description:\n                \"The response resources wrapped in the common MCP *Resource* message. These are typed resources that match the type url in the RequestResources message.\",\n              type: \"array\",\n              items: {\n                $ref: \"#/components/schemas/istio.mcp.v1alpha1.Resource\",\n              },\n            },\n            nonce: {\n              description:\n                \"Required. The nonce provides a way for RequestChange to uniquely reference a RequestResources.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            systemVersionInfo: {\n              description:\n                \"The version of the response data (used for debugging).\",\n              type: \"string\",\n              format: \"string\",\n            },\n            removedResources: {\n              description:\n                \"Names of resources that have been deleted and to be removed from the MCP sink node. Removed resources for missing resources can be ignored.\",\n              type: \"array\",\n              items: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            collection: {\n              description:\n                \"Type of resource collection that is being requested, e.g.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            incremental: {\n              description:\n                \"This resource response is an incremental update. The source should only send incremental updates if the sink requested them.\",\n              type: \"boolean\",\n            },\n          },\n        },\n        \"istio.mcp.v1alpha1.Metadata\": {\n          description:\n            \"Metadata information that all resources within the Mesh Configuration Protocol must have.\",\n          type: \"object\",\n          properties: {\n            name: {\n              description:\n                \"Fully qualified name of the resource. Unique in context of a collection.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            annotations: {\n              description:\n                \"Map of string keys and values that can be used by source and sink to communicate arbitrary metadata about this resource.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n            createTime: {\n              description: \"The creation timestamp of the resource.\",\n              type: \"string\",\n              format: \"dateTime\",\n            },\n            version: {\n              description:\n                \"Resource version. This is used to determine when resources change across resource updates. It should be treated as opaque by consumers/sinks.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            labels: {\n              description:\n                \"Map of string keys and values that can be used to organize and categorize resources within a collection.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n                format: \"string\",\n              },\n            },\n          },\n        },\n        \"google.rpc.Status\": {\n          description:\n            \"This is populated when the previously received resources could not be applied The *message* field in *error_details* provides the source internal error related to the failure.\",\n          type: \"object\",\n          properties: {\n            code: {\n              description:\n                \"The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].\",\n              type: \"integer\",\n              format: \"int32\",\n            },\n            message: {\n              description:\n                \"A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.\",\n              type: \"string\",\n              format: \"string\",\n            },\n            details: {\n              description:\n                \"A list of messages that carry the error details. There is a common set of message types for APIs to use.\",\n              type: \"array\",\n              items: {\n                type: \"object\",\n                required: [\"@type\"],\n                properties: {\n                  \"@type\": {\n                    description:\n                      'A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\\'s path must represent the fully qualified name of the type (as in `type.googleapis.com/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). The remaining fields of this object correspond to fields of the proto messsage. If the embedded message is well-known and has a custom JSON representation, that representation is assigned to the \\'value\\' field.',\n                    type: \"string\",\n                    format: \"string\",\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n    },\n  },\n];\n\nconst transformKey = k => {\n\tconst bits = k.split(/\\./g);\n\treturn `/${bits[bits.length - 1]}-${bits[1]}-${bits[2]}.json`.toLowerCase();\n}\nconst pathsToSchemas = schemas.reduce((agg,s) => {\n\tObject.keys(s.components.schemas).forEach(k => agg[transformKey(k)] = {\n\t\tcomponents: { schemas: s.components.schemas[k] }});\n\treturn agg;\n}, {});\nmodule.exports = pathsToSchemas;","// Note: These are not official or complete. I've basically just made them up based on documentation.\n// They are good enough for now but will probably need to be updated/expanded. \n// Hopefully people start publishing OpenAPI schemas soon.\n\nconst { objectMeta } = require(\"./common.js\");\nconst entityRule = {\n  type: \"object\",\n  properties: {\n    nets: {\n      type: [\"array\", \"null\"],\n    },\n    notNets: {\n      type: [\"array\", \"null\"],\n    },\n    selector: { type: \"string\" },\n    notSelector: { type: \"string\" },\n    namespaceSelector: { type: \"string\" },\n    ports: {\n      type: [\"array\", \"null\"],\n    },\n    notPorts: {\n      type: [\"array\", \"null\"],\n    },\n    serviceAccounts: {\n      names: {\n        type: [\"array\", \"null\"],\n      },\n      selector: { type: \"string\" },\n    },\n  },\n};\nconst rule = {\n  type: \"object\",\n  properties: {\n    action: {\n      type: \"string\",\n    },\n    metadata: { annotations: {} },\n    protocol: {\n      type: \"string\",\n    },\n    notProtocol: {\n      type: \"string\",\n    },\n    icmp: {\n      type: \"object\",\n    },\n    notIcmp: {\n      type: \"object\",\n    },\n    ipVersion: {\n      type: \"integer\",\n    },\n    destination: entityRule,\n    source: entityRule,\n  },\n};\nmodule.exports = {\n  \"/networkpolicy-crd-v1.json\": {\n    $schema: \"http://json-schema.org/draft-04/schema#\",\n    type: \"object\",\n    properties: {\n      apiVersion: {\n        type: \"string\",\n      },\n      kind: {\n        type: \"string\",\n      },\n      metadata: objectMeta,\n      spec: {\n        type: \"object\",\n        properties: {\n          selector: {\n            type: \"string\",\n          },\n          order: {\n            type: \"number\",\n          },\n          serviceAccountSelector: {\n            type: \"object\",\n          },\n          types: {\n            type: \"array\",\n            items: [],\n          },\n          ingress: {\n            type: [\"array\", \"null\"],\n            items: [rule],\n          },\n          egress: {\n            type: [\"array\", \"null\"],\n            items: [rule],\n          },\n        },\n      },\n    },\n    required: [\"apiVersion\", \"kind\", \"metadata\", \"spec\"],\n  },\n};\n","// Note: These are not official or complete. I've basically just made them up based on documentation.\n// They are good enough for now but will probably need to be updated/expanded.\n// Hopefully people start publishing OpenAPI schemas soon.\n\nconst { objectMeta } = require(\"./common.js\");\n\nmodule.exports = {\n  \"/sealedsecret-bitnami-v1alpha1.json\": {\n    $schema: \"http://json-schema.org/draft-04/schema#\",\n    type: \"object\",\n    properties: {\n      apiVersion: {\n        type: \"string\",\n      },\n      kind: {\n        type: \"string\",\n      },\n      metadata: objectMeta,\n      spec: {\n        type: \"object\",\n        properties: {\n          encryptedData: {\n            type: \"object\",\n          },\n          template: {\n            type: \"object\",\n            properties: {\n              metadata: objectMeta,\n              type: {\n                type: \"string\",\n              },\n            },\n            required: [\"metadata\", \"type\"],\n          },\n        },\n        required: [\"encryptedData\"],\n      },\n    },\n    required: [\"apiVersion\", \"kind\", \"metadata\", \"spec\"],\n  },\n};\n","const http = require('http');\nconst https = require('https');\nconst schemas = require('./schemas');\nconst URL = require('url').URL; // https://stackoverflow.com/questions/52566578/url-is-not-defined-in-node-js/52566656\n\n// This basically serves our own schemas or proxies calls to https://kubernetesjsonschema.dev/\n// We have to do this cos github.com/instrumenta/kubernetes-json-schema is 4.2GB!\n\nconst defaultSchemaSite = 'https://kubernetesjsonschema.dev';\n\nconst sendError = res => err => {\n  console.warn(err);\n  res.writeHead(500);\n  res.end(JSON.stringify(err));\n};\n\nconst cache = {};\n\nconst retryOnError = (reqPath, res, opts = {}, fail) => err => {\n  if (opts.attempts || 0 > 5) {\n    fail(err)\n    return\n  }\n\n  if (err.code == \"ETIMEDOUT\") {\n    const wait = ((opts.attempts || 0) + 1) * 1000;\n    console.warn(`Request timed out attempting again in ${Math.round(wait / 1000)} seconds ${reqPath}`)\n    setTimeout(() => requestSchema(reqPath, res, { ...opts, attempts: (opts.attempts || 0) + 1 }), wait)\n    return\n  }\n\n  fail(err)\n  return\n}\n\nconst requestSchema = (reqPath, res, opts = {}) => {\n  const url = new URL((opts.schemaLocation ?? defaultSchemaSite) + reqPath);\n  const client = https.request(\n    {\n      host: url.host,\n      path: url.pathname,\n      port: url.port,\n      protocol: url.protocol,\n      headers: {\n        ...(opts.githubToken\n          ? {Authorization: `token ${opts.githubToken}`}\n          : {})\n      }\n    },\n    msg => {\n      res.writeHead(msg.statusCode, msg.headers);\n      let data = '';\n      msg.on('data', curData => {\n        data += curData;\n      });\n      msg.on('end', () => {\n        addToCache(data, msg);\n        res.end(data);\n      });\n    }\n  );\n  client.on('error', retryOnError(reqPath, res, opts, sendError(res)));\n  client.end();\n  const addToCache = (data, msg) => {\n    const roundedStatusCode = Math.round(msg.statusCode / 100) * 100;\n    if (roundedStatusCode != 200) {\n      console.warn(msg.statusCode + '\\t' + url.toString());\n      // cache[reqPath] = { code: roundedStatusCode };\n      return;\n    }\n    let json;\n    try {\n      json = data.toString('utf8');\n      const obj = JSON.parse(json);\n      cache[reqPath] = {code: roundedStatusCode, data: obj};\n    } catch (err) {\n      console.warn('Error caching', json, err);\n    }\n  };\n};\n\nconst schemaCache = next => (reqPath, res, opts = {}) => {\n  const cached = cache[reqPath];\n  if (cached && cached.code !== 200) {\n    res.writeHead(cached.code);\n    res.end(cached.data);\n    return;\n  }\n  if (cached) {\n    res.writeHead(cached.code, 'application/json');\n    res.end(JSON.stringify(cached.data));\n    return;\n  }\n  next(reqPath, res, opts);\n};\n\nconst codeSchema = next => (reqPath, res, opts = {}) => {\n  const rx = /^\\/?[^\\/]+/;\n  const key = reqPath.toLowerCase();\n  const schema = schemas[key] || schemas[key.replace(rx, '')];\n  if (!schema) {\n    next(reqPath, res, opts);\n    return;\n  }\n  res.writeHead(200, 'application/json');\n  res.end(JSON.stringify(schema));\n};\n\nconst getSchema = codeSchema(schemaCache(requestSchema));\n\nfunction start(port, schemaLocation, githubToken) {\n  return new Promise((started, rej) => {\n    let server;\n    const promise = new Promise((res, rej) => {\n      server = http.createServer(function (req, res) {\n        try {\n          getSchema(req.url, res, {\n            schemaLocation,\n            githubToken\n          });\n        } catch (err) {\n          rej(err);\n        }\n      });\n      server.listen(port);\n      started(\n        () =>\n          new Promise(res => {\n            promise.finally(res);\n            server.close();\n            setTimeout(res, 1000);\n          })\n      );\n    });\n  });\n}\n\nmodule.exports = {\n  start\n};\n","import YAML from 'yaml';\nimport {Logger} from './logger';\nimport {getLabel} from './utils';\n\nexport const hackyBoolString = \"fe6edaed2a: 1f4b9:'b989659b53d86025c\";\n\nconst simplifyRam = (input: string): string => {\n  const units = 'kmgtp';\n  const inNum = parseInt(input.match(/^\\d+/)?.shift() || '0');\n  const inUnit = input.toLowerCase().match(/\\D+$/)?.shift()?.trim();\n  let num = inNum;\n  let unit = inUnit;\n  if (!inNum || !inUnit) {\n    return input;\n  }\n  let unitIndex = units.indexOf(inUnit[0]);\n  if (unitIndex === -1) {\n    return input;\n  }\n  const divisor = inUnit.endsWith('i') ? 1000 : 1024;\n\n  while (num % divisor === 0) {\n    unitIndex++;\n    num /= divisor;\n  }\n  unit =\n    units[unitIndex].toUpperCase() +\n    (inUnit.length > 1 ? inUnit.substr(1) : '');\n\n  return num + unit;\n};\n\nconst cleanElem = (log: (s: string) => void) => (elem: any, path: string) => {\n  if (\n    (/\\/(creationtimestamp|subresources|webhooks)$/.test(path) &&\n      elem.value === null) ||\n    (/\\/(subresources|labels|annotations|status|ports)$/.test(path) &&\n      (elem.value === null ||\n        elem.value.items == null ||\n        elem.value.items.length === 0))\n  ) {\n    log(`Removed: ${path}`);\n    return true;\n  }\n  if (\n    ((typeof elem.value.value === 'string' &&\n      /^\\s*(true|false|on|off|yes|no)\\s*$/gi.test(elem.value.value)) ||\n      typeof elem.value.value === 'boolean') &&\n    (/\\/env\\/value$/.test(path) || /^\\/data\\//.test(path))\n  ) {\n    elem.value.value = elem.value.value.toString() + hackyBoolString; // I gave up, sorry\n  }\n  if (elem.value.type === 'PLAIN') {\n    if (/\\/(limits|requests|hard|soft)\\/cpu$/.test(path)) {\n      if (typeof elem.value.value === 'number') {\n        elem.value.value = elem.value.value.toString();\n      } else {\n        const newVal = elem.value.value.replace(/000m/, '');\n        if (elem.value.value !== newVal) {\n          log(`Modified: ${path} from \"${elem.value.value}\" to \"${newVal}\"`);\n          elem.value.value = newVal;\n        }\n      }\n    }\n    if (/\\/(limits|requests|hard|soft)\\/memory$/.test(path)) {\n      const newVal = simplifyRam(elem.value.value);\n      if (elem.value.value !== newVal) {\n        log(`Modified: ${path} from \"${elem.value.value}\" to \"${newVal}\"`);\n        elem.value.value = newVal;\n      }\n    }\n  }\n  return false;\n};\n\nconst descendInToProps = (\n  func: (elem: any, path: string) => boolean,\n  elem: any,\n  path: string,\n  parentNode: any\n) => {\n  if (!elem) {\n    return;\n  }\n  let curPath = path;\n  if (elem.key && elem.key.value) {\n    curPath = path + '/' + elem.key.value;\n    const remove = func(elem, curPath.toLowerCase().trim());\n    if (remove) {\n      parentNode.delete(elem.key.value);\n      return;\n    }\n  }\n  const children = elem.items || (elem.value && elem.value.items);\n  const parent = elem.value || elem;\n  if (children) {\n    children.map((e: any) => descendInToProps(func, e, curPath, parent));\n  }\n};\n\nexport const removeKustomizeValues = (\n  docs: YAML.Document[],\n  logger: Logger | undefined\n): YAML.Document[] =>\n  docs.filter(d => {\n    const toRemove =\n      d.get('apiVersion') === 'kustomize.config.k8s.io/v1' &&\n      d.get('kind') === 'Values';\n    if (toRemove) {\n      logger?.log(`Removing ${getLabel(d)}`);\n    }\n    return !toRemove;\n  });\n\nconst findUnmatchedSecrets = (\n  secrets: SecretMeta[],\n  patterns: SecretMeta[]\n) => {\n  const globMatch = (p: string, i: string) =>\n    p.indexOf('*') === -1\n      ? p === i\n      : new RegExp(p.replace(/\\*/g, '.*')).test(i);\n\n  const secretPatternMatcher = (s: SecretMeta) => (\n    a: SecretMeta | undefined,\n    p: SecretMeta | undefined\n  ) =>\n    a ||\n    (p && globMatch(p.name, s.name) && globMatch(p.namespace, s.namespace)\n      ? p\n      : undefined);\n  return secrets.reduce(\n    (a, s) => {\n      const matchingPattern = (patterns as (SecretMeta | undefined)[]).reduce(\n        secretPatternMatcher(s),\n        undefined\n      );\n      if (!matchingPattern) {\n        a.unMatchedSecrets.push(s);\n      } else {\n        a.matchedPatterns.add(\n          `${matchingPattern.namespace}/${matchingPattern.name}`\n        );\n      }\n      return a;\n    },\n    {unMatchedSecrets: [] as SecretMeta[], matchedPatterns: new Set<string>()}\n  );\n};\n\nexport const checkSecrets = (\n  docs: YAML.Document[],\n  allowedSecrets: SecretMeta[],\n  logger: Logger | undefined\n) => {\n  const secrets = docs\n    .filter(d => d.get('kind') === 'Secret')\n    .map(s => s.get('metadata'))\n    .map(m => ({name: m.get('name'), namespace: m.get('namespace')}));\n\n  logger?.log(\n    'Found secrets: ' + secrets.map(s => s.namespace + '/' + s.name).join(', ')\n  );\n  const {unMatchedSecrets, matchedPatterns} = findUnmatchedSecrets(\n    secrets,\n    allowedSecrets\n  );\n  logger?.log(\n    \"Didn't match any secrets with: \" +\n      allowedSecrets\n        .map(s => s.namespace + '/' + s.name)\n        .filter(s => !matchedPatterns.has(s))\n        .join(', ')\n  );\n\n  if (unMatchedSecrets.length > 0) {\n    throw new Error(\n      `Invalid secrets: ${unMatchedSecrets\n        .map(s => s.namespace + '/' + s.name)\n        .join(', ')}`\n    );\n  }\n};\n\nexport const cleanUpYaml = (\n  doc: YAML.Document,\n  logger?: Logger\n): {doc: YAML.Document; modified: boolean} => {\n  let modified = false;\n  descendInToProps(\n    cleanElem(s => {\n      if (!modified) {\n        logger?.log('Processing ' + getLabel(doc));\n      }\n      modified = true;\n      logger?.log(s);\n    }),\n    doc.contents,\n    '',\n    doc\n  );\n  return {doc, modified};\n};\n\nexport const customValidation = (\n  input: string,\n  customValidation: {regex: RegExp; expected: boolean; message: string}[],\n  logger: Logger | undefined\n): string[] => {\n  customValidation.forEach(v => {\n    logger?.log(\n      `Custom validation: ${v.expected ? 'failing to match' : 'matching'} ${\n        v.regex\n      } will result in ${v.message}`\n    );\n  });\n  const messages = customValidation.map(v => {\n    const m = v.regex.exec(input);\n    const fail = !!m !== v.expected;\n    logger?.log(\n      `${v.regex.source}\t:${m ? 'Matched' : 'Not matched'}\t${\n        fail ? 'Fail ' : 'Pass'\n      } \"${m && m!}\"`\n    );\n    return !fail ? '' : v.message + ((m && '\\n' + m.join('\\n')) || '');\n  });\n  return messages.filter(m => m != '');\n};\n\ntype SecretMeta = {\n  namespace: string;\n  name: string;\n};\n","import * as core from '@actions/core';\nimport YAML from 'yaml';\nimport {buildActionLogger, buildConsoleLogger, Logger} from './logger';\nimport kustomize from './kustomize';\nimport {\n  checkSecrets,\n  cleanUpYaml,\n  customValidation,\n  hackyBoolString,\n  removeKustomizeValues\n} from './cleanYaml';\nimport validateYaml from './validation';\nimport {\n  getSettings,\n  Settings,\n  validateEnvironment,\n  validateSettings\n} from './setup';\nimport {runActions} from './outputs';\nimport {getLabel, makeBox} from './utils';\nimport {Type} from 'yaml/util';\nimport {resolve} from 'path';\nimport resourceFilter from './resourceFilter';\n\nconst main = async () => {\n  const isAction = !!process.env.GITHUB_EVENT_NAME;\n  try {\n    const settings = getSettings(isAction);\n    const logger = isAction\n      ? buildActionLogger(settings)\n      : buildConsoleLogger(settings);\n    if (!isAction) {\n      logger.warn(\n        'Not running as action because GITHUB_WORKFLOW env var is not set'\n      );\n    }\n    output(logger, settings.verbose, 'Parsing and validating settings');\n    if (settings.verbose) {\n      console.log(YAML.stringify(settings));\n    }\n    await validateSettings(settings);\n    output(\n      logger,\n      settings.verbose,\n      'Validating environment (binaries, plugin path etc)'\n    );\n    await validateEnvironment(\n      settings.requiredBins,\n      settings.verbose ? logger : undefined\n    );\n    const {yaml, errors} = await getYaml(settings, logger);\n    if (settings.outputActions && settings.outputActions.length) {\n      output(logger, settings.verbose, 'Running output actions');\n      await runActions(yaml, errors, settings, logger);\n    }\n    if (errors.length) {\n      throw new Error('Errored');\n    }\n    logger.log('Finished');\n  } catch (error) {\n    const toReport = error.message ? error.message : error.toString();\n    if (isAction) {\n      core.setFailed(toReport);\n    } else {\n      console.error(toReport);\n      process.exit(1);\n    }\n  }\n};\n\nconst output = (logger: Logger, verbose: boolean, msg: string) => {\n  if (!verbose) {\n    logger.log(msg);\n    return;\n  }\n  logger.log('\\n\\n' + makeBox(msg));\n};\n\nconst getYaml = async (settings: Settings, logger: Logger) => {\n  const section = async (name: string, fn: () => Promise<unknown>) => {\n    if (!settings.verbose) {\n      output(logger, false, name);\n      return await fn();\n    }\n    // return core.group(name, async () => {\n    output(logger, true, name);\n    return await fn();\n    //   return await fn();\n    // });\n  };\n\n  const errors = [] as string[];\n  const {docs: resources, warnings} = ((await section(\n    'Running kustomize',\n    async () => {\n      return await kustomize(settings, logger);\n    }\n  )) as unknown) as {docs: YAML.Document[]; warnings: string[]};\n\n  if (warnings && warnings.length) {\n    warnings.forEach(logger.warn);\n    if (settings.reportWarningsAsErrors) {\n      errors.push(...warnings);\n    }\n  }\n\n  const docs = ((await section(\n    'Removing superfluous kustomize resources',\n    async () => {\n      return removeKustomizeValues(\n        resources,\n        settings.verbose ? logger : undefined\n      );\n    }\n  )) as unknown) as YAML.Document[];\n\n  const filteredDocs = ((await section('Filtering Documents', async () => {\n    return resourceFilter(docs, settings.verbose ? logger : undefined, {\n      filterExcludeAnnotations: settings.filterExcludeAnnotations?.split(','),\n      filterExcludeResources: settings.filterExcludeResources?.split(',')\n    });\n  }) as unknown) as YAML.Document[]);\n\n  const cleanedDocs = ((await section('Cleaning up YAML', async () => {\n    const cleaned = filteredDocs.reduce(\n      (a, d) => {\n        const {doc, modified} = cleanUpYaml(\n          d,\n          settings.verbose ? logger : undefined\n        );\n        a.cleanedDocs.push(doc);\n        a.modified = a.modified || modified;\n        return a;\n      },\n      {cleanedDocs: <YAML.Document[]>[], modified: false}\n    );\n    if (!cleaned.modified && settings.verbose) {\n      logger.log('No changes required');\n    }\n    return cleaned.cleanedDocs;\n  })) as unknown) as YAML.Document[];\n\n  await section('Checking for un-encrypted secrets', async () => {\n    checkSecrets(cleanedDocs, settings.allowedSecrets, logger);\n  });\n\n  const yaml = cleanedDocs\n    .map(d => {\n      if (d.errors.length) {\n        console.warn(\n          `Document ${getLabel(d)} has errors:\\n${YAML.stringify(d.errors)}`\n        );\n        return `# Document ${getLabel(d)} has errors:\\n${YAML.stringify(\n          d.errors\n        ).replace(/\\n/g, '\\\\n')}`;\n      }\n\n      const rx = new RegExp(hackyBoolString.replace(/[^0-9a-z]+/g, '.+'), 'g');\n      return YAML.stringify(d).replace(rx, '');\n    })\n    .join('---\\n');\n  errors.push(\n    ...(cleanedDocs\n      .filter(d => d.errors.length)\n      .reduce((a, d) => {\n        const label = getLabel(d);\n        d.errors.forEach(e => {\n          a.push(`${label} ${e.linePos} ${e.range}: ${e.message}`);\n        });\n        return a;\n      }, [] as (string | undefined)[])\n      .filter(i => i != undefined) as string[])\n  );\n\n  if (settings.validateWithKubeVal) {\n    await section('Validating YAML', async () =>\n      errors.push(\n        ...(await validateYaml(yaml, logger, {\n          schemaLocation: settings.kubevalSchemaLocation,\n          kubernetesVersion: settings.kubevalKubernetesVersion,\n          githubToken: settings.kubevalGithubToken\n        }))\n      )\n    );\n  }\n  if (settings.customValidation.length) {\n    await section('Running customValidation tests', async () => {\n      errors.push(\n        ...customValidation(\n          yaml,\n          settings.customValidation,\n          settings.verbose ? logger : undefined\n        )\n      );\n    });\n  }\n\n  return {\n    yaml,\n    errors: <string[]>(\n      errors.filter(\n        e =>\n          e !== undefined &&\n          (!settings.ignoreWarningsErrorsRegex ||\n            !settings.ignoreWarningsErrorsRegex.test(e))\n      )\n    )\n  };\n};\n\nmain();\n","import {execFile} from 'child_process';\nimport * as core from '@actions/core';\nimport fs from 'fs';\nimport path from 'path';\nimport tmp from 'tmp';\nimport YAML from 'yaml';\nimport {Logger} from './logger';\nimport {Settings} from './setup';\nimport {aggregateCount} from './utils';\n\nconst osTmpDir = process.env['RUNNER_TEMP'] || tmp.tmpdir;\n\nconst runKustomize = async (\n  rootPath: string,\n  settings: Settings,\n  logger: Logger,\n  binPath?: string\n) =>\n  new Promise<{stdOut: string; stdErr: string}>((res, rej) => {\n    const args = ['build', rootPath, ...settings.kustomizeArgs.split(/\\ +/g)];\n    logger.log('Running: ' + [binPath || 'kustomize', ...args].join(' '));\n    execFile(\n      binPath || 'kustomize',\n      args,\n      {maxBuffer: 1024 * 1024 * 1024 * 10}, // If the YAML is bigger than this then we should probably write to disk\n      (err, stdOut, stdErr) => {\n        if (settings.verbose) {\n          core.startGroup('STDOUT');\n          logger.log(stdOut);\n          core.endGroup();\n          core.startGroup('STDERR');\n          logger.log(stdErr);\n          core.endGroup();\n        }\n        if (stdErr && stdErr.length) {\n          aggregateCount(stdErr.split(/\\n/g)).forEach(logger.warn);\n        }\n        if (err) {\n          logger.error(err);\n          return rej({err, stdOut, stdErr});\n        }\n        res({stdOut, stdErr});\n      }\n    );\n  });\n\nconst prepDirectory = async (\n  rootPath: string,\n  extraResources: string[] = []\n): Promise<{dir: string; cleanUp: () => void}> => {\n  await validatePaths(rootPath, extraResources);\n  const {dir, cleanUp} = await new Promise<{dir: string; cleanUp: () => void}>(\n    (res, rej) =>\n      tmp.dir({tmpdir: osTmpDir, unsafeCleanup: true}, (err, dir, cleanUp) =>\n        err ? rej(err) : res({dir, cleanUp})\n      )\n  );\n\n  await Promise.all([\n    ...referenceFiles(dir, rootPath, extraResources),\n    createKustomization(dir, extraResources)\n  ]);\n  return {dir, cleanUp};\n};\n\nconst validatePaths = async (rootPath: string, extraResources: string[]) => {\n  const stats = await fs.promises.stat(rootPath);\n  if (!stats.isDirectory()) {\n    throw new Error(rootPath + ' is not a directory');\n  }\n  await Promise.all(\n    extraResources.map(p =>\n      fs.promises.stat(p).then(stats => {\n        if (stats.isDirectory()) {\n          throw new Error(p + ' is a directory');\n        }\n      })\n    )\n  );\n};\n\nconst referenceFiles = (\n  dir: string,\n  rootPath: string,\n  extraResources: string[]\n) =>\n  extraResources\n    .map(p => fs.promises.copyFile(p, path.join(dir, path.basename(p))))\n    .concat(fs.promises.symlink(rootPath, path.join(dir, 'root')));\n\nconst createKustomization = (dir: string, extraResources: string[]) =>\n  fs.promises.writeFile(\n    path.join(dir, 'kustomization.yaml'),\n    `\nbases:\n- root\nresources:\n${extraResources.map(p => '- ' + path.basename(p)).join('\\n')}\n`\n  );\n\nexport default async (\n  settings: Settings,\n  logger: Logger,\n  binPath?: string\n): Promise<{docs: YAML.Document.Parsed[]; warnings: string[]}> => {\n  const {dir: tmpPath, cleanUp} = await prepDirectory(\n    settings.kustomizePath,\n    settings.extraResources\n  );\n  const {stdOut, stdErr} = await runKustomize(\n    tmpPath,\n    settings,\n    logger,\n    binPath\n  );\n  cleanUp();\n  const warnings = stdErr.split(/\\n/g).filter(l => l.length > 0);\n  return {docs: YAML.parseAllDocuments(stdOut, {prettyErrors: true}), warnings};\n};\n","import * as core from '@actions/core';\nimport {defaultKustomizeArgs, Settings} from './setup';\n\nexport interface Logger {\n  log: (msg: string) => void;\n  warn: (msg: string | Error) => void;\n  error: (msg: string | Error) => void;\n}\n\nconst logPossError = (\n  msg: string | Error,\n  fn: (msg: string | Error) => void\n) => {\n  fn((<Error>msg).message ? (<Error>msg).message : msg);\n  if (msg instanceof Error) {\n    console.trace();\n  }\n};\nexport const buildActionLogger = (settings: Settings): Logger =>\n  setupLogger(\n    {\n      log: (msg: string) => core.info(msg),\n      warn: (msg: string | Error) => logPossError(msg, core.warning),\n      error: (msg: string | Error) => logPossError(msg, core.error)\n    },\n    settings\n  );\n\nexport const buildConsoleLogger = (settings: Settings): Logger =>\n  setupLogger(\n    {\n      log: (msg: string) => console.log(msg),\n      warn: (msg: string | Error) => logPossError(msg, console.warn),\n      error: (msg: string | Error) => logPossError(msg, console.error)\n    },\n    settings\n  );\n\nexport const buildTestLogger = (\n  settings?: Settings,\n  logs?: string[],\n  warnings?: (string | Error)[],\n  errors?: (string | Error)[]\n): Logger =>\n  setupLogger(\n    {\n      log: (msg: string) => logs?.push(msg),\n      warn: (msg: string | Error) => warnings?.push(msg),\n      error: (msg: string | Error) => errors?.push(msg)\n    },\n    settings || {\n      kustomizePath: '',\n      allowedSecrets: [],\n      verbose: true,\n      outputActions: [],\n      extraResources: [],\n      customValidation: [],\n      requiredBins: [],\n      kustomizeArgs: defaultKustomizeArgs,\n      validateWithKubeVal: true,\n      reportWarningsAsErrors: false,\n      ignoreWarningsErrorsRegex: undefined\n    }\n  );\n\nconst setupLogger = (logger: Logger, settings: Settings): Logger => {\n  const previousMessages = new Set() as Set<string>;\n  const possSuppressed = (\n    msg: string | Error,\n    fLog: (msg: string | Error) => void\n  ) => {\n    const key = msg + '_' + fLog.name;\n    if (\n      !previousMessages.has(key) &&\n      (!settings.ignoreWarningsErrorsRegex ||\n        !settings.ignoreWarningsErrorsRegex.test(msg.toString()))\n    ) {\n      previousMessages.add(key);\n      fLog(msg);\n    } else {\n      logger.log('Suppressed: ' + msg);\n    }\n  };\n  return {\n    log: (msg: string) => logger.log(msg),\n    warn: (msg: string | Error) =>\n      settings.reportWarningsAsErrors\n        ? possSuppressed(msg, logger.error)\n        : possSuppressed(msg, logger.warn),\n    error: (msg: string | Error) => possSuppressed(msg, logger.error)\n  };\n};\n","import * as core from '@actions/core';\nimport * as artifact from '@actions/artifact';\nimport path from 'path';\nimport tmp from 'tmp';\nimport {createWriteStream, promises} from 'fs';\nimport {Logger} from './logger';\nimport {Settings} from './setup';\nimport {getWorkspaceRoot, resolveEnvVars} from './utils';\n\nconst osTmpDir = process.env['RUNNER_TEMP'] || tmp.tmpdir;\nexport interface OutputAction {\n  type: string;\n  invoke: (\n    yaml: string,\n    errors: string[],\n    settings: Settings,\n    logger: Logger\n  ) => Promise<void>;\n}\n\nexport class LoggerOutputAction implements OutputAction {\n  type: string = 'LoggerOutputAction';\n  logErrors: boolean = true;\n  logYaml: boolean = true;\n  invoke(yaml: string, errors: string[], settings: Settings, logger: Logger) {\n    if (this.logYaml) {\n      logger.log(yaml);\n    }\n    if (this.logErrors) {\n      errors.forEach(logger.error);\n    }\n    return Promise.resolve();\n  }\n}\n\nexport class VariableOutputAction implements OutputAction {\n  type: string = 'VariableOutputAction';\n  outputVariableName: string | undefined = 'output';\n  errorsVariableName: string | undefined = 'errors';\n\n  invoke(yaml: string, errors: string[], settings: Settings, logger: Logger) {\n    if (this.outputVariableName) {\n      core.setOutput(this.outputVariableName, yaml);\n      if (settings.verbose) {\n        logger.log(`Wrote ${yaml.length} chars to ${this.outputVariableName}`);\n      }\n    }\n    if (this.errorsVariableName) {\n      core.setOutput(this.errorsVariableName, errors);\n      if (settings.verbose) {\n        logger.log(\n          `Wrote ${errors.length} errors to ${this.errorsVariableName}`\n        );\n      }\n    }\n    return Promise.resolve();\n  }\n}\n\nexport class FileOutputAction implements OutputAction {\n  type: string = 'FileOutputAction';\n  yamlFileName: string | undefined;\n  errorsFileName: string | undefined;\n  createDirIfMissing: boolean = true;\n  fileOpenFlags: string = 'w';\n  writeToFile(fileName: string, content: string, logger: Logger | undefined) {\n    return new Promise<void>((res, rej) => {\n      const str = createWriteStream(fileName, {\n        flags: this.fileOpenFlags,\n        autoClose: true\n      });\n      str.on('error', rej);\n      str.write(content, err =>\n        err\n          ? rej(err)\n          : str.end(() => {\n              logger?.log(`Wrote ${content.length} chars to file ${fileName}`);\n              res();\n            })\n      );\n    });\n  }\n  output(fileName: string, content: string, logger: Logger | undefined) {\n    if (this.createDirIfMissing) {\n      return promises\n        .mkdir(path.dirname(fileName), {recursive: true})\n        .then(() => this.writeToFile(fileName, content, logger));\n    }\n    return this.writeToFile(fileName, content, logger);\n  }\n  invoke(yaml: string, errors: string[], settings: Settings, logger: Logger) {\n    const workspaceDir = getWorkspaceRoot();\n    const getPath = (p: string) =>\n      path.isAbsolute(p) ? p : path.join(workspaceDir, p);\n\n    const l = settings.verbose ? logger : undefined;\n\n    const promises = [Promise.resolve()];\n    if (this.yamlFileName) {\n      promises.push(\n        this.output(getPath(resolveEnvVars(this.yamlFileName)), yaml, l)\n      );\n    }\n    if (this.errorsFileName) {\n      const content = JSON.stringify(errors, null, 2);\n      promises.push(\n        this.output(getPath(resolveEnvVars(this.errorsFileName)), content, l)\n      );\n    }\n    return Promise.all(promises).then(() => Promise.resolve());\n  }\n}\n\nexport const runActions = async (\n  yaml: string,\n  errors: string[],\n  settings: Settings,\n  logger: Logger\n) => {\n  const actions = settings.outputActions;\n  for (let i = 0; i < actions.length; i++) {\n    if (settings.verbose) {\n      logger.log('Invoking ' + actions[i].type);\n    }\n    await actions[i].invoke(yaml, errors, settings, logger);\n  }\n};\n\nexport const parseActions = (\n  json: string,\n  typeMappings?: any\n): OutputAction[] => {\n  const types = typeMappings || {\n    LoggerOutputAction: LoggerOutputAction,\n    VariableOutputAction: VariableOutputAction,\n    FileOutputAction: FileOutputAction,\n    ArtifactOutputAction: ArtifactOutputAction\n  };\n  const actions: Array<OutputAction> = JSON.parse(json).map((i: any) => {\n    if (Object.keys(types).indexOf(i.type) === -1) {\n      throw new Error('cant find output action ' + i.type);\n    }\n\n    const target: any = new types[i.type]();\n    for (const key in i) {\n      target[key] = i[key];\n    }\n    return target;\n  });\n  return actions;\n};\n\nexport class ArtifactOutputAction implements OutputAction {\n  type: string = 'ArtifactOutputAction';\n  name: string = 'kustomize-output';\n  yamlFileName: string | undefined;\n  errorsFileName: string | undefined;\n  async invoke(\n    yaml: string,\n    errors: string[],\n    settings: Settings,\n    logger: Logger\n  ) {\n    const {tmpDir, cleanup} = await new Promise((res, rej) =>\n      tmp.dir(\n        {tmpdir: osTmpDir, keep: true, unsafeCleanup: true},\n        (err, tmpDir, cleanup) => (err ? rej(err) : res({tmpDir, cleanup}))\n      )\n    );\n    const fileAction = new FileOutputAction();\n    const files = [] as string[];\n    if (this.yamlFileName) {\n      fileAction.yamlFileName = path.join(tmpDir, this.yamlFileName);\n      files.push(fileAction.yamlFileName);\n    }\n    if (this.errorsFileName) {\n      fileAction.errorsFileName = path.join(tmpDir, this.errorsFileName);\n      files.push(fileAction.errorsFileName);\n    }\n    await fileAction.invoke(yaml, errors, settings, logger);\n    const client = artifact.create();\n    await client.uploadArtifact(this.name, files, tmpDir);\n    cleanup();\n  }\n}\n","import YAML from 'yaml';\nimport {Logger} from './logger';\nimport {getLabel} from './utils';\n\nexport default (\n  docs: YAML.Document[],\n  logger: Logger | undefined = undefined,\n  {\n    filterExcludeAnnotations = [],\n    filterExcludeResources = []\n  }: {filterExcludeAnnotations?: string[] | undefined; filterExcludeResources?: string[] | undefined }\n): YAML.Document[] =>\n  docs.filter(d => {\n    \n    const filterAnnotation = d.get('metadata')?.get('annotations')?.get('jsretail.github.io/kustomize-action/filter')\n    const kind = d.get('kind') || \"\"\n    const apiVersion = d.get('apiVersion') || \"\"\n\n    const toRemove = filterExcludeAnnotations.includes(filterAnnotation)\n      || filterExcludeResources.includes(`${apiVersion}/${kind}`)\n\n    if (toRemove) {\n      logger?.log(`removing ${getLabel(d)}`);\n    }\n\n    return !toRemove;\n  });\n","import {getBinPath, getWorkspaceRoot, parseRx, resolveEnvVars} from './utils';\nimport * as core from '@actions/core';\nimport dotenv from 'dotenv';\nimport fs from 'fs';\nimport path from 'path';\nimport {OutputAction, parseActions} from './outputs';\nimport {Logger} from './logger';\n\nexport const validateEnvironment = async (\n  required: string[] = ['kustomize', 'kubeval', 'helm'],\n  logger: Logger | undefined\n): Promise<unknown> =>\n  Promise.all(\n    required\n      .map(\n        b =>\n          new Promise((res, rej) => {\n            getBinPath(b).then(path => {\n              if (path) {\n                logger?.log('Found ' + b + ' at ' + path);\n                res(undefined);\n              } else {\n                rej(b + ' is required');\n              }\n            });\n          })\n      )\n      .concat(createKustomizeFolder())\n  );\nexport const createKustomizeFolder = () =>\n  new Promise<void>(r => {\n    let dir;\n    if (process.env['KUSTOMIZE_PLUGIN_HOME']) {\n      dir = process.env['KUSTOMIZE_PLUGIN_HOME'];\n    } else if (process.env['XDG_CONFIG_HOME']) {\n      dir = path.join(process.env['XDG_CONFIG_HOME'], 'kustomize', 'plugin');\n    } else {\n      dir = path.join(process.env['HOME']!, 'kustomize', 'plugin');\n    }\n    fs.promises.mkdir(dir, {recursive: true}).finally(r);\n  });\n\nexport type Settings = {\n  kustomizePath: string;\n  allowedSecrets: {namespace: string; name: string}[];\n  verbose: boolean;\n  outputActions: OutputAction[];\n  extraResources: string[];\n  customValidation: {regex: RegExp; expected: boolean; message: string}[];\n  requiredBins: string[];\n  kustomizeArgs: string;\n  validateWithKubeVal: boolean;\n  kubevalKubernetesVersion?: string;\n  kubevalGithubToken?: string | undefined;\n  reportWarningsAsErrors: boolean;\n  ignoreWarningsErrorsRegex: RegExp | undefined;\n  kubevalSchemaLocation?: string;\n  filterExcludeAnnotations?: string;\n  filterExcludeResources?: string; \n};\n\nexport const parseAllowedSecrets = (secretString: string) =>\n  secretString\n    .split(/,/g)\n    .map(s => s.trim().toLowerCase())\n    .filter(i => i.indexOf('/') > -1)\n    .map(i => ({namespace: i.split(/\\//)[0], name: i.split(/\\//)[1]}));\n\nexport const parseCustomValidation = (customValidation: string | undefined) =>\n  customValidation\n    ? customValidation\n        .split(/(?<!\\\\)\\n/g)\n        .map(i => i.split(/\\|/g))\n        .map(i => {\n          if (i.length >= 3) {\n            return {\n              message: i.shift()!,\n              expected: i.shift()!.toLowerCase() === 'true',\n              regex: parseRx(i.join('|'))\n            };\n          }\n          throw new Error(\n            'Invalid custom validation rule \"' + i + '\": ' + JSON.stringify(i)\n          );\n        })\n    : [];\n\nexport const getSettings = (isAction: boolean): Settings => {\n  if (!isAction) {\n    dotenv.config();\n  }\n  const getRequiredFromEnv = (name: string) => {\n    const val = process.env[name];\n    if (val === undefined) {\n      throw new Error(`${name} is required`);\n    }\n    return val;\n  };\n  const getFromEnv = (name: string) => process.env[name];\n  const getSetting = (\n    actionSettingName: string,\n    envVarName: string,\n    required = false\n  ) =>\n    isAction\n      ? core.getInput(actionSettingName, {required: required})\n      : (required ? getRequiredFromEnv : getFromEnv)(envVarName);\n\n  const kustomizePath = getSetting('kustomize-path', 'KUSTOMIZE_PATH', true);\n  const outputActions = getSetting('output-actions', 'OUTPUT_ACTIONS', true);\n  const extraResources = getSetting('extra-resources', 'EXTRA_RESOURCES');\n  const reportWarningsAsErrors = getSetting(\n    'warnings-as-errors',\n    'WARNINGS_AS_ERRORS'\n  );\n  const ignoreRegex = getSetting('ignore-errors-regex', 'IGNORE_ERRORS_REGEX');\n  const customValidation = getSetting(\n    'custom-validation-rules',\n    'CUSTOM_VALIDATION_RULES',\n    false\n  );\n  const allowedSecrets = getSetting('allowed-secrets', 'ALLOWED_SECRETS');\n  const requiredBins = getSetting('required-bins', 'REQUIRED_BINS');\n  const verbose = getSetting('verbose', 'VERBOSE');\n  const validateWithKubeVal = getSetting(\n    'validate-with-kubeval',\n    'VALIDATE_WITH_KUBEVAL'\n  );\n  const kubevalKubernetesVersion = getSetting(\n    'kubeval-kubernetes-version',\n    'KUBEVAL_KUBERNETES_VERSION'\n  );\n\n  const kubevalSchemaLocation = getSetting(\n    'kubeval-schema-location',\n    'KUBEVAL_SCHEMA_LOCATION'\n  );\n\n  const kubevalGithubToken = getSetting(\n    'kubeval-github-token',\n    'KUBEVAL_GITHUB_TOKEN'\n  )\n\n  const filterExcludeAnnotations = getSetting(\n    'filter-exclude-annotations',\n    'FILTER_EXCLUDE_ANNOTATIONS'\n  );\n\n  const filterExcludeResources = getSetting(\n    'filter-exclude-resources',\n    'FILTER_EXCLUDE_RESOURCES'\n  )\n\n  const kustomizeArgs = getSetting('kustomize-args', 'KUSTOMIZE_ARGS');\n\n  const workspaceDir = getWorkspaceRoot();\n  const getPath = (p: string) =>\n    path.isAbsolute(p) ? p : path.join(workspaceDir, p);\n\n  const defaultActions = `[\n      { type: \"LoggerOutputAction\", logErrors: true, logYaml: false },\n      {\n        type: \"VariableOutputAction\",\n        outputVariableName: \"output\",\n        errorsVariableName: \"errors\",\n      }\n    ]\n    `;\n  return {\n    kustomizePath: getPath(resolveEnvVars(kustomizePath || '.')),\n    outputActions: parseActions(outputActions || defaultActions),\n    extraResources: extraResources\n      ? resolveEnvVars(extraResources)\n          .split(',')\n          .map(s => s.trim())\n          .map(getPath)\n      : [],\n    customValidation: parseCustomValidation(customValidation),\n    allowedSecrets: parseAllowedSecrets(resolveEnvVars(allowedSecrets || '')),\n    verbose: resolveEnvVars(verbose || '').toLowerCase() === 'true',\n    requiredBins: requiredBins\n      ? resolveEnvVars(requiredBins)\n          .split(/,/g)\n          .map(s => s.trim())\n      : ['kustomize', 'kubeval', 'helm'],\n    kustomizeArgs: resolveEnvVars(kustomizeArgs || defaultKustomizeArgs),\n    validateWithKubeVal:\n      resolveEnvVars(validateWithKubeVal || '').toLowerCase() === 'true',\n    kubevalKubernetesVersion: resolveEnvVars(kubevalKubernetesVersion || ''),\n    kubevalGithubToken: resolveEnvVars(kubevalGithubToken || undefined),\n    kubevalSchemaLocation: resolveEnvVars(kubevalSchemaLocation || undefined),\n    reportWarningsAsErrors:\n      resolveEnvVars(reportWarningsAsErrors || '').toLowerCase() === 'true',\n    ignoreWarningsErrorsRegex: ignoreRegex ? parseRx(ignoreRegex) : undefined,\n    filterExcludeAnnotations: resolveEnvVars(filterExcludeAnnotations || undefined),\n    filterExcludeResources: resolveEnvVars(filterExcludeResources || undefined)\n  };\n};\n\nconst statFile = async (p: fs.PathLike) =>\n  fs.promises.stat(p).then(r => {\n    if (!r.isFile()) {\n      throw new Error(p + ' is not a file');\n    }\n  });\n\nconst statDir = async (p: fs.PathLike) =>\n  fs.promises.stat(p).then(r => {\n    if (!r.isDirectory()) {\n      throw new Error(p + ' is not a directory');\n    }\n  });\n\nexport const validateSettings = (settings: Settings) =>\n  Promise.all([\n    statDir(settings.kustomizePath).then(() =>\n      statFile(path.join(settings.kustomizePath, 'kustomization.yaml'))\n    ),\n    ...(settings.extraResources || []).map(statFile)\n  ]);\nexport const defaultKustomizeArgs = '--enable_alpha_plugins';\n","import fs from 'fs';\nimport path, {ParsedPath} from 'path';\nimport YAML from 'yaml';\n\nexport const resolveEnvVars = (str: string | undefined) =>\n  str\n    ? str.replace(\n        /(?<!\\\\)\\$([A-Z_]+[A-Z0-9_]*)|(?<!\\\\)\\${([A-Z0-9_]*)}/gi,\n        (_, a, b) => process.env[a || b] || ''\n      )\n    : '';\n\nexport const getBinPath = (bin: string): Promise<string | undefined> =>\n  new Promise<string | undefined>(res => {\n    const possPaths = (process.env.PATH || '')\n      .replace(/[\"]+/g, '')\n      .split(path.delimiter)\n      .map(p =>\n        (process.env.PATHEXT || '')\n          .split(path.delimiter)\n          .map(ext => path.join(p, bin + ext))\n      );\n\n    const paths = ([] as string[]).concat(...possPaths);\n    let pathCount = paths.length;\n    paths.map(p =>\n      fs.exists(p, (exists: boolean) => {\n        pathCount--;\n        if (exists) {\n          return res(p);\n        }\n        if (pathCount === 0) {\n          res(undefined);\n        }\n      })\n    );\n  });\n\nexport const getWorkspaceRoot = () => {\n  const getParentGitDir = (parsed: ParsedPath): string | undefined =>\n    fs.existsSync(path.join(parsed.dir, parsed.name, '.git'))\n      ? path.join(parsed.dir, parsed.name)\n      : (parsed.dir !== parsed.root &&\n          getParentGitDir(path.parse(parsed.dir))) ||\n        undefined;\n\n  return (\n    process.env['GITHUB_WORKSPACE'] ||\n    getParentGitDir(path.parse(mockedCwd())) ||\n    mockedCwd()\n  );\n};\n\nlet curDirName = __dirname;\nexport const mockedCwd = (newDir?: string): string => {\n  if (newDir) {\n    curDirName = newDir;\n  }\n  return curDirName;\n};\n\nexport const makeBox = (\n  title: string,\n  minLen = 40,\n  maxLen = 80,\n  xPadding = 3,\n  yPadding = 1\n) => {\n  const tl = '\\u2554',\n    h = '\\u2550',\n    tr = '\\u2557',\n    v = '\\u2551',\n    bl = '\\u255A',\n    br = '\\u255D';\n  const wrap = (s: string, w: number) =>\n    s.split(/\\s+/g).reduce((a: string[], i: string) => {\n      if (a.length === 0 || a[a.length - 1].length + i.length + 1 > w) {\n        a.push('');\n      }\n      a[a.length - 1] += i + ' ';\n      return a;\n    }, []);\n  const range = (n: number) => Array.from(Array(n).keys());\n  const lines = wrap(title, maxLen);\n  const width = lines.reduce((a, i) => (i.length > a ? i.length : a), minLen);\n\n  const top = tl.padEnd(width + xPadding * 2, h) + tr;\n  const empty = v.padEnd(width + xPadding * 2, ' ') + v;\n  const text = lines.map(\n    line =>\n      v.padEnd(xPadding, ' ') +\n      (''.padEnd(Math.floor(width - line.length) / 2) + line).padEnd(\n        width,\n        ' '\n      ) +\n      ''.padEnd(xPadding, ' ') +\n      v\n  );\n  const bottom = bl.padEnd(width + xPadding * 2, h) + br;\n\n  return [\n    top,\n    ...range(yPadding).map(_ => empty),\n    ...text,\n    ...range(yPadding).map(_ => empty),\n    bottom\n  ].join('\\n');\n};\n\nexport const getLabel = (doc: YAML.Document) =>\n  (doc.get('kind') === 'Namespace'\n    ? doc.getIn(['metadata', 'name'])\n    : `${doc.getIn(['metadata', 'namespace']) || ''}/${\n        doc.getIn(['metadata', 'name']) || 'missing name'\n      }`) + ` (${doc.get('kind') || 'missing kind'})`;\n\nexport const parseRx = (str: string) => {\n  const rx = /(^[^\\/].*[^\\/]$)|^\\/(.*)\\/([igmsuy]*)$/; // Parse \"this\" \"/this/\" or \"/this/ig\"\n  const match = rx.exec(str);\n  if (!match) {\n    throw new Error('Invalid regex: ' + str);\n  }\n  return match[1] ? new RegExp(match[1]) : new RegExp(match[2], match[3]);\n};\n\nexport const aggregateCount = (msgs: string[]) => {\n  const grouped = msgs.reduce((a: any, i: string) => {\n    a[i] = (a[i] || 0) + 1;\n    return a;\n  }, {});\n  return Object.keys(grouped).map(\n    i => i + (((grouped[i] as unknown) as number) > 1 ? ' x' + grouped[i] : '')\n  );\n};\n","import tmp from 'tmp';\nimport {execFile} from 'child_process';\nimport fs from 'fs';\nimport {Logger} from '../logger';\nimport server from './server';\nimport { aggregateCount } from '../utils';\n\nconst osTmpDir = process.env['RUNNER_TEMP'] || tmp.tmpdir;\n\nconst runKubeVal = (\n  path: string,\n  port: number,\n  logger: Logger,\n  kubeValBin?: string,\n  kubernetesVersion?: string\n) =>\n  new Promise<{stdOut: string; stdErr: string}>((res, rej) => {\n\n    const kubeValArgs = [\n      '--strict',\n      '--schema-location', 'http://localhost:' + port,\n      path]\n\n    if (kubernetesVersion) {\n      kubeValArgs.push('--kubernetes-version', kubernetesVersion)\n    }\n\n    execFile(\n      kubeValBin || 'kubeval',\n      kubeValArgs,\n      (err, stdOut, stdErr) => {\n        logger.log(stdOut);\n        if (stdErr && stdErr.length) {\n          logger.warn(stdErr);\n        }\n        if (err) {\n          return rej({err, stdOut, stdErr});\n        }\n        res({stdOut, stdErr});\n      }\n    );\n  });\n\nconst getErrors = (text: string) =>\naggregateCount(text\n    .split(/\\n/g)\n    .map(line => (line.match(/^(WARN|ERR)\\s/) ? line : undefined))\n    .filter(err => err && err.length > 0) as string[]);\n\nconst main = async (\n  yaml: string,\n  logger: Logger,\n  {\n    kubeValBin,\n    kubernetesVersion,\n    schemaLocation,\n    githubToken\n  }: { kubeValBin?: string, kubernetesVersion?: string, schemaLocation?: string, githubToken?: string | undefined } = {}\n): Promise<string[]> => {\n  const port = 1025 + (Math.floor(Math.random() * 100000) % (65535 - 1025));\n  const stop = await server.start(port, schemaLocation, githubToken);\n  const {name: tmpYaml} = tmp.fileSync({tmpdir:osTmpDir});\n  await fs.promises.writeFile(tmpYaml, yaml);\n  let retVal;\n  try {\n    retVal = await runKubeVal(tmpYaml, port, logger, kubeValBin, kubernetesVersion);\n  } catch (errData) {\n    if (errData instanceof Error) {\n      logger.warn(errData);\n      throw errData;\n    }\n    retVal = errData;\n  }\n  await stop();\n  const {stdOut, stdErr, err} = retVal;\n  const errors = getErrors(stdOut + '\\n' + stdErr);\n\n  errors.forEach(logger.warn);\n  if (err) {\n    logger.error(err);\n    if (errors.length === 0) {\n      throw err;\n    }\n  }\n\n  return errors;\n};\n\nexport default main;\n","module.exports = require(\"assert\");;","module.exports = require(\"child_process\");;","module.exports = require(\"crypto\");;","module.exports = require(\"events\");;","module.exports = require(\"fs\");;","module.exports = require(\"http\");;","module.exports = require(\"https\");;","module.exports = require(\"net\");;","module.exports = require(\"os\");;","module.exports = require(\"path\");;","module.exports = require(\"perf_hooks\");;","module.exports = require(\"stream\");;","module.exports = require(\"tls\");;","module.exports = require(\"url\");;","module.exports = require(\"util\");;","module.exports = require(\"zlib\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\n__webpack_require__.ab = __dirname + \"/\";","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(6144);\n"],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AChTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACvxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACveA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AC55BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AC7WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AC3vBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AC7wBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACzWA;AACA;AACA;A;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACzQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACtvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC72BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC3gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACptDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACpkEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACjaA;AACA;AACA;A;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AChTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACroUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;AC3IA;AAEA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AAZA;AAcA;AAIA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AAGA;AAEA;AAKA;AACA;AACA;AACA;AAEA;AAGA;AAIA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAhCA;AAkCA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAlBA;AAoBA;AAKA;AACA;AAKA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAvBA;AACA;AACA;A;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9MA;AACA;AACA;AACA;AACA;AAOA;AACA;AAMA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAIA;AAGA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAOA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAGA;AACA;AAEA;AACA;AACA;A;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpNA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAEA;AAMA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AAIA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AAEA;AAMA;AACA;AAEA;;;;AAOA;AACA;AAGA;AAKA;AAIA;AAMA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzHA;AACA;AAQA;AAIA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AANA;AAUA;AAGA;AACA;AACA;AACA;AANA;AAUA;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxBA;AA2BA;AACA;AACA;AAIA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7FA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAWA;AAAA;AACA;AACA;AACA;AAUA;AATA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAeA;AAAA;AACA;AACA;AACA;AAmBA;AAjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAtBA;AAwBA;AAAA;AACA;AAGA;AACA;AA+CA;AA9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AApDA;AAsDA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAeA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtBA;AAwBA;AAAA;AACA;AACA;AA8BA;AA3BA;;AAMA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAhCA;AACA;AACA;A;;;;;;;;ACxJA;AAEA;;AAUA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;A;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AAGA;AAIA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AApBA;AAqBA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAXA;AAgCA;AAEA;AACA;AACA;AACA;AALA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAjBA;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AAKA;AACA;AACA;AACA;AAIA;AAKA;AAKA;AAKA;AAKA;AAKA;AAEA;AACA;AAGA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA9GA;AAgHA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AAGA;AACA;AANA;AAOA;AACA;AACA;A;;;;;;;;;;;;AC9NA;AACA;AAGA;AAEA;AAIA;AANA;AAQA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAxBA;AA0BA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAbA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAOA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAIA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9CA;AAgDA;AAEA;AACA;AAHA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AACA;AACA;AACA;AAGA;AARA;AACA;AACA;A;;;;;;;;;;;;;;;;;;;;AC/HA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AASA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;A;;;;;;AC1FA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5BA;AACA;ACDA;AACA;AACA;AACA;;A","sourceRoot":""}